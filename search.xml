<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深北莫算法与Quasi-Newton</title>
      <link href="2021/11/18/%E6%B7%B1%E5%8C%97%E8%8E%AB%E7%AE%97%E6%B3%95%E4%B8%8EQuasi-Newton/"/>
      <url>2021/11/18/%E6%B7%B1%E5%8C%97%E8%8E%AB%E7%AE%97%E6%B3%95%E4%B8%8EQuasi-Newton/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    优化课与同学尝试BFGS的参数选择讨论到12点@_@, 回宿舍路上口瓢把SMBU（深北莫）也读成了BFGS。觉得深北莫算法这“雅号”比BFGS更透着一股亲近感。as</p><p><img src="/2021/11/18/%E6%B7%B1%E5%8C%97%E8%8E%AB%E7%AE%97%E6%B3%95%E4%B8%8EQuasi-Newton/intro.jpeg" style="zoom:33%;"></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何反驳那些认为圣诞老人不存在的幼稚的人们</title>
      <link href="2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/"/>
      <url>2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>圣诞老人是存在的！</p><a id="more"></a><p>“<a href="http://www.guokr.com/article/3908/">圣诞怪谈</a>”中，“圣诞公公不存在”被证实为谣言：</p><blockquote><p>根据大量的历史数据以及 NORAD过去50 多年来追踪圣诞老人所收集的信息，我们坚信圣诞老人确定一定以及肯定是存在的…如今，NORAD使用四种高科技手段：雷达、卫星、Santa Cam和喷气式战斗机，来追踪圣诞老人…圣诞夜当晚，NORAD会为我们传来圣诞老人带着他的驯鹿环游世界的图像和视频…</p></blockquote><p>但是，小朋友们，虽然这更加坚定了你心中“圣诞老人存在”的信念，可如果依然有可恶的幼稚的无趣的人说“那些都是骗人的，哄小孩的，明明就没有圣诞老人”，你还是不能只凭这些来反驳。想让他们哑口无言，看看下面的教学吧（原图自<a href="http://survivingtheworld.net/">Surviving the World</a>）。</p><h2 id="圣诞老人的存在性"><a href="#圣诞老人的存在性" class="headerlink" title="圣诞老人的存在性"></a>圣诞老人的存在性</h2><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/1.jpeg" alt="img" style="zoom:50%;"></p><p>真的有圣诞老人哦</p><p>不要理那些可恶的“大孩子”们说的话</p><p>圣诞老人当然存在了！！</p><p>事实上证明这件事一点儿也不难</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/2.jpeg" alt="img" style="zoom:50%;"></p><p>首先呢，你要明白有无数多个宇宙同时存在</p><p>（小朋友们，这一点很好理解吧- __,-）</p><p>多到你根本记不住在多少个宇宙里你喷了香体喷剂，</p><p>多少个宇宙里你忘了喷，或者多少个你甚至连腋窝都没有（囧）</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/2.jpeg" alt="img" style="zoom:50%;"></p><p>所以，这就意味着圣诞老人不仅是存在的，</p><p>而且还可能有宇宙总数的一半那么多个！</p><p>（某些<a href="http://www.guokr.com/article/3914/">死理性派</a>是不是以为圣诞老人只有一个呢）</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/4.jpeg" alt="img" style="zoom:50%;"></p><p>“但是，哼哼”，某些人会说，</p><p>“就算是有一半的宇宙里存在着圣诞老人，我们也在那些圣诞老人不存在的宇宙里。”</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/5.jpeg" alt="img" style="zoom:50%;"></p><p>好吧，就算他们说的是对的</p><p>但是在这无数多个宇宙中</p><p>至少有一个圣诞老人会穿梭于不同的宇宙之间</p><p>而且至少有一个圣诞老人会穿梭到我们的宇宙来</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/4.jpeg" alt="img" style="zoom:50%;"></p><p>所以说，保持着你们童真的梦想，</p><p>开心的等着圣诞老人吧</p><p>如果那些大孩子一直反对你的观点</p><p>无视掉他们</p><p>他们不懂物理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P,NP,NPC,NP-hard</title>
      <link href="2021/07/09/P-NP-NPC-NP-hard/"/>
      <url>2021/07/09/P-NP-NPC-NP-hard/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前在最优化学习时自然是接触过P，NP等的定义，但时间久了脑海里留下的也只是相对模糊的印象，最近看到北大文学系一博主在08年发布的分析，讲的十分透彻，通篇搬运在这里，方便日后复习。</p><a id="more"></a><p>你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。</p><p>  还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘级复杂度。不会存在O(2<em>n^2)的复杂度，因为前面的那个“2”是系数，根本不会影响到整个程序的时间增长。同样地，O (n^3+n^2)的复杂度也就是O(n^3)的复杂度。因此，我们会说，一个O(0.01</em>n^3)的程序的效率比O(100*n^2)的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过O(n^2)。我们也说，O(n^100)的复杂度小于O(1.01^n)的复杂度。<br>  容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是O(1),O(log(n)),O(n^a)等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是O(a^n)和O(n!)型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><p>  自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。<a href="http://www.matrix67.com/blog/article.asp?id=62">The Halting Problem</a>就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p>  下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。P是英文单词多项式的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。<br>  接下来引入NP问题的概念。这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。在这个题中，找一个解很困难，但验证一个解很容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。<br>  之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p>  很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。<br>  NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问<br>题，好比物理学中的大统一和数学中的歌德巴赫猜想等。<br>  目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><p>  为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。<br>  简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。<br>  “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。<br>  很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。<br>  现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<br>  当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。约化的过程只有用多项式的时间完成才有意义。</p><p>  好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？答案居然是肯定的。也就是说，存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p>  NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题。首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。<br>  既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>  顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><p>  不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。<br>  下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。<br>  逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。<br>  什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br> ┌───┐<br> │ 输入1├─→┐  ┌──┐<br> └───┘  └─→┤  │<br>           │ or ├→─┐<br> ┌───┐  ┌─→┤  │  │  ┌──┐<br> │ 输入2├─→┤  └──┘  └─→┤  │<br> &amp;<br>nbsp;└───┘  │        ┌─→┤AND ├──→输出<br>        └────────┘┌→┤  │<br> ┌───┐  ┌──┐      │ └──┘<br> │ 输入3├─→┤ NOT├─→────┘<br> └───┘  └──┘<br>  这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。<br>  有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br> ┌───┐<br> │输入1 ├→─┐  ┌──┐<br> └───┘  └─→┤  │<br>           │AND ├─→┐<br>        ┌─→┤  │  │<br>        │  └──┘  │ ┌──┐<br>        │        └→┤  │<br> ┌───┐  │          │AND ├─→输出<br> │输入2 ├→─┤ ┌──┐   ┌→┤  │<br> └───┘  └→┤NOT ├→──┘ └──┘<br>          └──┘<br>  上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。<br>  回到上文，给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。<br>  逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>  有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据与隐私</title>
      <link href="2021/06/08/Data-privacy/"/>
      <url>2021/06/08/Data-privacy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img align="cente" src="/2021/06/08/Data-privacy/index.jpeg" style="zoom:67%;"></p><p>大数据技术在提升社会协作效率、给人们带来诸多便利与舒适的同时, 也逐渐引发了一系列问题, “大数据杀熟”便是恶果之一。</p><a id="more"></a><p>​    所谓“大数据杀熟”, 通俗说来就是平台(主要是互联网平台)充分利用自身所掌握的大数据技术对<strong>消费市场进行更为精准与细腻的划分</strong>, 在此基础上主要<strong>对熟人(习惯、依赖该平台的较为忠诚的用户)进行不当地利益宰割</strong>, 从而使大数据技术成为部分经营者追求超额利润的有力工具。也就是说, 面临同样的商品或服务, 具有忠诚度的用户群体看到并为此实际支付的价格反而比新客户或一般用户要贵,   而且这种行为极具隐蔽性。一言以蔽之, 大数据技术加剧了经营者和相对人之间的的信息不平等, 消费者很难通过网络对经营者价格歧视的抗辩进行甄别</p><p>​    究其本质, “大数据杀熟”的技术原理就是互联网平台凭借其所掌握的极其庞大且维度异常丰富的数据, 诸如用户的个人身份信息、位置信息、聊天记录以及支付信息等一切有可能被线上记录的数字化信息, 然后通过一整套复杂、高效而又极其先进的数据运算、分析和挖掘技术对碎片化、零散的用户数字化信息进行全方位的扫描、分析与研究(数据标注), 然后通过一些关键词的标注对用户进行细致归类, 从而生成独特的 <font color="EE695E"><strong>用户画像</strong>。</font></p><h1 id="1-主因"><a href="#1-主因" class="headerlink" title="1 主因"></a>1 主因</h1><p>1.数据高度集中，互联网的发展建立在用户数据的规模智商，用户规模越大整个互联网越能发挥出更大的效用，综合价值成集合式增长。 相较于传统经济样态, 互联网经济的边际成本非常低, 收益却可以很高,自然导致了数据的集中于垄断。</p><p>2.用户”粘性“，用户粘性是各大互联网产品重要的指标。用户长久的习惯于使用某一平台，由于用户对便利、稳定的追求使得有被”杀熟“的可能。</p><p>3.不同平台间的隐私窃取。微信与京东，支付宝与淘宝等的相互泄漏数据很易使得用户的偏好或购物倾向被泄漏，从而引导消费、杀熟等。粘贴板、输入法等获取信息。</p><font color="red">矛盾：</font><p>公司需要用户数据刻画用户画像，以此来提供服务</p><p>VS</p><p>公民隐私泄漏给互联网公司利用用户隐私数据创造价格歧视的机会</p><p>据此，按照通行的观点，价格歧视往往被分为三级：</p><p>一级价格歧视，即看人报价，报出对方能够接受的最高价，攫取最大利润；传统商业社会中，游商采用这种方式比较多；</p><p>二级价格歧视，即根据批量大小定价，从而获得最好的周转率，批量大的消费者获得实惠；从商家角度看，虽然单一商品获利降低，但由于销量增加，也可以获得更大的利润；</p><p>三级价格歧视，是根据销售区域的不同进行差异化定价。</p><p>对于大数据杀熟，我国法律中已经有相应的规则进行规范。《中华人民共和国消费者权益保护法》第十九条规定：商店提供商品应明码标价。该法第十条规定：消费者享有公平交易的权利。明码标价意味着商品价格展示不应因为消费者不同而不同，由于不同的消费者看到的价格不同，因而大数据杀熟违反了明码标价的原则。消费者权益保护法规定消费者获得公平交易的权利，也从另一个角度说明了相同商品或服务的定价应一视同仁。</p><h2 id="数据安全法，6-10通过"><a href="#数据安全法，6-10通过" class="headerlink" title="数据安全法，6.10通过"></a>数据安全法，6.10通过</h2><h1 id="2-数据中个人隐私保护的技术分析"><a href="#2-数据中个人隐私保护的技术分析" class="headerlink" title="2 数据中个人隐私保护的技术分析"></a>2 数据中个人隐私保护的技术分析</h1><h2 id="2-1-将id去敏？"><a href="#2-1-将id去敏？" class="headerlink" title="2.1  将id去敏？"></a>2.1  将id去敏？</h2><p>例如在用户数据需要被使用时，使用去敏手段，如：将名字等敏感的个人信息去除。</p><p>问题： How anonymous ?</p><p>2006 netflix收集大量用户评分一次来训练自己的评分预测功能：</p><p>1， 将uid改为无意义代码</p><p>2，随机修改部分用户评分</p><p><a href="https://ieeexplore.ieee.org/document/4531148">Robust De-anonymization of Large Sparse Datasets</a></p><p>(利用了imdb的数据库，correlation 可以)</p><p>马萨诸塞州，医疗数据。</p><font color="red">考虑彼此反推数据，如何加密？</font><h2 id="2-2-只发布粗粒度的统计数据？"><a href="#2-2-只发布粗粒度的统计数据？" class="headerlink" title="2.2 只发布粗粒度的统计数据？"></a>2.2 只发布粗粒度的统计数据？</h2><script type="math/tex; mode=display">\begin{array}{l}\begin{array}{|c|c|c|}\hline \text { Age } & \text { Gender } & \text { Employed? } \\\hline<18 & \mathrm{M} & \text { Yes } \\\hline<18 & \mathrm{~F} & \text { No } \\\hline<18 & \mathrm{M} & \text { No } \\\hline \geq 18 & \mathrm{~F} & \text { Yes } \\\hline \geq 18 & \mathrm{~F} & \text { Yes } \\\hline\end{array}\\{\text { Original dataset }}\end{array}</script><script type="math/tex; mode=display">\begin{array}{l}\begin{array}{|c|c|c|}\hline \text { Age } & \text { Employed? } & \text { Count } \\\hline<18 & \text { Yes } & 1 \\\hline<18 & \text { No } & 2 \\\hline \geq 18 & \text { Yes } & 2 \\\hline \geq 18 & \text { No } & 0 \\\hline\end{array}\\\begin{array}{|c|c|c|}\hline \text { Age } & \text { Gender } & \text { Count } \\\hline<18 & \mathrm{M} & 2 \\\hline<18 & \mathrm{~F} & 1 \\\hline \geq 18 & \mathrm{M} & 0 \\\hline \geq 18 & \mathrm{~F} & 2 \\\hline\end{array}\\\end{array}</script><p>很容易可以从发布的两份数据中反推出必有两个大于18岁女性，有工作。</p><p>（数据重构攻击）</p><p>可能解决方法：</p><p>1，对统计结果加上有权重的噪音，处理outlier</p><p>2， 统计结果上，将outlier划入相对大的群体，减少outlier</p><h2 id="2-3-Deferential-Privacy"><a href="#2-3-Deferential-Privacy" class="headerlink" title="2.3  Deferential Privacy"></a>2.3  Deferential Privacy</h2><script type="math/tex; mode=display">\exp (-\varepsilon) \leq \frac{\operatorname{Pr}[A(D)=O]}{\operatorname{Pr}\left[A\left(D^{\prime}\right)=O\right]} \leq \exp (\varepsilon)</script><p>对任意“相邻”数据集 $D$ 和 $D^{\prime}$ 及任意输出 $O$ 都成立</p><p>1,拉普拉斯噪声</p><script type="math/tex; mode=display">\operatorname{pdf}(x)=\frac{1}{2 \lambda} \exp \left(-\frac{|x|}{\lambda}\right)</script><p>lambda为 相邻数据集查询发生的最大改变量 / $\epsilon$</p><ol><li><p>random answer</p><p>引入随机量计入答案，保证统计量依然准确可感。</p></li></ol><p><img align="cente" src="/2021/06/08/Data-privacy/random_answer.png" style="zoom:67%;"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cryptocurrency</title>
      <link href="2021/06/02/Cryptocurrency/"/>
      <url>2021/06/02/Cryptocurrency/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/06/02/Cryptocurrency/BTC_Logo.svg.png" style="zoom:10%;"></p><p>Basic introduction of cryptocurrency</p><a id="more"></a><h1 id="1-What-is-cryptocurrency"><a href="#1-What-is-cryptocurrency" class="headerlink" title="1 What is cryptocurrency?"></a>1 What is cryptocurrency?</h1><p>Cryptocurrency is a form of payment that can be exchanged online for goods and services. Many companies have issued their own currencies, often called tokens, and these can be traded specifically for the good or service that the company provides. Think of them as you would arcade tokens or casino chips. You’ll need to exchange real currency for the cryptocurrency to access the good or service.</p><p>Cryptocurrencies work using a technology called <strong>blockchain</strong>. Blockchain is a <strong>decentralized</strong> technology spread across many computers that manages and records transactions. Part of the appeal of this technology is its security.</p><h1 id="2-Why-popular"><a href="#2-Why-popular" class="headerlink" title="2 Why popular?"></a>2 Why popular?</h1><p>Cryptocurrencies appeal to their supporters for a variety of reasons. Here are some of the most popular:</p><ul><li>Supporters see cryptocurrencies such as Bitcoin as the currency of the future and are racing to buy them now, presumably before they become more valuable（升值）</li><li>Some supporters like the fact that cryptocurrency removes central banks from managing the money supply, since over time these banks tend to reduce the value of money via inflation（私密）</li><li>Other supporters like the technology behind cryptocurrencies, the blockchain, because it’s a decentralized processing and recording system and can be more secure than traditional payment systems（技术控）</li></ul><h1 id="3-How-it-works？"><a href="#3-How-it-works？" class="headerlink" title="3 How it works？"></a>3 How it works？</h1><h2 id="3-1-Decentralize"><a href="#3-1-Decentralize" class="headerlink" title="3.1 Decentralize:"></a>3.1 Decentralize:</h2><p>In traditional electronic trading， there will always be a trusted third party either country\Bank or big company like Alibaba. In cryptocurrency there is no such “Center”.</p><h2 id="3-2-Block-Chain"><a href="#3-2-Block-Chain" class="headerlink" title="3.2 Block Chain:"></a>3.2 Block Chain:</h2><p>Since, there is no centralized third party we need another way to verify and record transaction. The main idea behind cryptocurrency is to let everyone keep the whole e-ledger—<strong>the block chain</strong>.</p><p>In every 5 minutes someone will pack all the transactions(<strong>block</strong>) then he will broadcast to everyone and link the new block to the block chain.Every block will be encrypted by hash function.For bitcoin, it uses POW algorithm wich is based on SHA256. </p><center>  <font color="blue">SHA256</font>(<font color="green">Plain Text</font>) = <font color="green">010101101010..0101</font>(256 bit)</center><p><img src="/2021/06/02/Cryptocurrency/blockchain_demo.png" style="zoom:50%;"></p><p>In short:</p><p><center>Ledger-Trust+Cryptography=<font color="#4182D1">Cryptocurrency</font></center></p><p><img src="/2021/06/02/Cryptocurrency/VSbank.png" style="zoom:50%;"></p><h2 id="3-3-Why-this-works"><a href="#3-3-Why-this-works" class="headerlink" title="3.3 Why this works?"></a>3.3 Why this works?</h2><ol><li><p>It satisfy the basic requirements to be used as “currency”. </p><p><strong>currency = transaction history</strong></p></li><li><p>Althoug there is no provement of non-solvable property of SHA256 but we can assume it is not possible to solve it. So it is hard(expensive, 51% attack) to forgery.</p><p><strong>Fraud is computationally infeasible</strong></p></li></ol><h1 id="4-What-is-mining"><a href="#4-What-is-mining" class="headerlink" title="4 What is mining?"></a>4 What is mining?</h1><h2 id="4-1-Block-reward"><a href="#4-1-Block-reward" class="headerlink" title="4.1 Block reward"></a>4.1 Block reward</h2><p><strong>Block Award</strong>:</p><p>Once a new block is added to the block chain, the people who finish such job will get rewarded for 25 bit coins<strong>(halve after every 210000 blocks,and for now each block is rewarded for 12.5 btc)</strong></p><h2 id="4-2-Who-can-get-reward"><a href="#4-2-Who-can-get-reward" class="headerlink" title="4.2 Who can get reward?"></a>4.2 Who can get reward?</h2><p>To get the reward one must get the opportunity to add a new block. This is where cryptography works. </p><p>SHA256 algorithms will translate plaintext into 256 binary code, the cryptocurrency protocol will announce, for example: first 30 bits should be 0 for next block. Miners will try different keys until one lucky miner find the key that satisfies the requirement.</p><p>SHA256(。。。+transaction+Time Stamp+。。。+<font color="green">key</font>) = <font color="red">0000…000</font>1010111</p><h2 id="4-3-Proof-of-work"><a href="#4-3-Proof-of-work" class="headerlink" title="4.3 Proof of work"></a>4.3 Proof of work</h2><p>The miners may get conflict signals recording conflict transactions. Miners should always t<strong>rsust one with more computational work.</strong></p><p>Some times conflict may come from the broadcast speed.For example one may get 2 blocks at the same time, then he sholud keep both blocks and one of them will gradually get longer and longer than another one, then based on <strong>proof of work</strong> protocol he should take the longer one.</p><p>Some time fraud may come from fraud. It is obvious that to make others trust your record you have to make sure your chain grows faster than the true chain, which means you have to posses at least 51% computation power which is not possible.</p><p><img src="/2021/06/02/Cryptocurrency/proofWork.png" style="zoom:50%;"></p><h1 id="5-Problems"><a href="#5-Problems" class="headerlink" title="5 Problems"></a>5 Problems</h1><h2 id="5-1-Speculation-and-fraud"><a href="#5-1-Speculation-and-fraud" class="headerlink" title="5.1 Speculation and fraud"></a>5.1 Speculation and fraud</h2><p>Cryptocurrencies have been compared to Ponzi schemes, pyramid schemes and economic bubbles, such as housing market bubbles. Howard Marks of Oaktree Capital Management stated in 2017 that digital currencies were “nothing but an unfounded fad (or perhaps even a pyramid scheme), based on a willingness to ascribe value to something that has little or none beyond what people will pay for it”, and compared them to the tulip mania (1637), South Sea Bubble (1720), and dot-com bubble (1999). The New Yorker has explained the debate based on interviews with blockchain founders in an article about the “argument over whether Bitcoin, Ethereum, and the blockchain are transforming the world”.</p><p>(泡沫与庞氏骗局)</p><h2 id="5-2-legal-concern"><a href="#5-2-legal-concern" class="headerlink" title="5.2 legal concern"></a>5.2 legal concern</h2><p>Cryptocurrency networks display a lack of regulation that has been criticized as enabling criminals who seek to evade taxes and launder money. Money laundering issues are also present in regular bank transfers, however with bank-to-bank wire transfers for instance, the account holder must at least provide a proven identity.</p><p>（洗钱，非法汇款等）</p><h2 id="5-3-Environment-concern"><a href="#5-3-Environment-concern" class="headerlink" title="5.3 Environment concern"></a>5.3 Environment concern</h2><p>挖矿带来的电力的浪费，环境污染，硬件消耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Auction Theory</title>
      <link href="2021/05/24/auction/"/>
      <url>2021/05/24/auction/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/05/24/auction/index.jpeg" style="zoom:90%;"></p><p><center>Basic Auction theory</center></p><a id="more"></a><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>​    Auction theory can be approached from different angles – from the perspective of game theory (auctions are bayesian games of incomplete information), contract or mechanism design theory (auctions are allocation mechanisms), market microstructure (auctions are models of price formation), as well as in the context of different applications (procurement, patent licensing, public finance, etc.).</p><p>​    Generally speaking, the higher the bidder offer the higher chance he will get the good but also he will get less profit, vice versa.</p><p>The basic auction environment consists of:</p><ul><li>Bidders <script type="math/tex">i=1, \ldots, n</script></li><li>One object to be sold</li><li>Bidder <script type="math/tex">i</script> observes a “signal” <script type="math/tex">S_{i} \sim F(\cdot)</script>, with typical realization <script type="math/tex">s_{i} \in</script> <script type="math/tex">[\underline{s}, \bar{s}]</script>, and assume <script type="math/tex">F</script> is continuous.</li><li>Bidders’ signals <script type="math/tex">S_{1}, \ldots, S_{n}</script> are independent.</li><li>Bidder $i$ ‘s value <script type="math/tex">v_{i}\left(s_{i}\right)=s_{i}</script></li></ul><h1 id="2-Different-Auction-Forms"><a href="#2-Different-Auction-Forms" class="headerlink" title="2 Different Auction Forms"></a>2 Different Auction Forms</h1><h2 id="1-English-auction-oral-ascending"><a href="#1-English-auction-oral-ascending" class="headerlink" title="1) English auction(oral ascending):"></a>1) English auction(oral ascending):</h2><p>All bidders start in the auction with a price of zero. The price rises continuously, and bidders may drop out at any point in time. Once they drop out, they cannot reenter. The auction ends when only one bidder is left, and this bidder pays the price at which the second-to-last bidder dropped out.</p><h2 id="2-Dutch-Auction-descending-price"><a href="#2-Dutch-Auction-descending-price" class="headerlink" title="2) Dutch Auction(descending price)"></a>2) Dutch Auction(descending price)</h2><p>A Dutch auction is one of several similar types of auctions for buying or selling goods.Most commonly, it means an auction in which the auctioneer begins with a high asking price in the case of selling, and lowers it until some participant accepts the price, or it reaches a predetermined reserve price. This type of price auction is most commonly used for goods that are required to be sold quickly such as flowers, fresh produce or  tobacco.</p><h2 id="3-First-price-sealed-bid-auction"><a href="#3-First-price-sealed-bid-auction" class="headerlink" title="3) First-price sealed-bid auction"></a>3) First-price sealed-bid auction</h2><p>Also known as blind bid all bidders simultaneously submit sealed bids so that no bidder knows the bid of any other participant. The highest bidder pays the price that was submitted.</p><h2 id="4-Second-price-sealed-bid-auction-vickery-auction"><a href="#4-Second-price-sealed-bid-auction-vickery-auction" class="headerlink" title="4) Second-price sealed-bid auction(vickery auction)"></a>4) Second-price sealed-bid auction(vickery auction)</h2><p>In a Vickrey, or second price, auction, bidders are asked to submit sealed bids <script type="math/tex">b_{1}, \ldots, b_{n}</script>. The bidder who submits the highest bid is awarded the object, and pays the amount of the second highest bid.</p><h1 id="3-First-price-sealed-bid-auction-FPSD"><a href="#3-First-price-sealed-bid-auction-FPSD" class="headerlink" title="3 First-price sealed-bid auction(FPSD)"></a>3 First-price sealed-bid auction(FPSD)</h1><p>In a FPSD auction the bidders sealed bids <script type="math/tex">b_1,b_2\dots b_n</script> the bidders who submits the highest bid is awarded the object and pays his bid.</p><p>Under these rules the bidder will not bid higher than their values, by doing so they may get negative profit. By bidding lower than their true value they may make profit some time.</p><h2 id="A-The-first-order-condition-approach"><a href="#A-The-first-order-condition-approach" class="headerlink" title="A The first order condition approach"></a>A The first order condition approach</h2><p>We will look for an equilibrium where each bidder uses a bid strategy that is a strictly increasing, continuous, and differentiable function of his value. To do this we assume that different bidders use the same bid function <script type="math/tex">b_j = b(s_j)</script> for different j. </p><p>Bidder i’s expected profit as a  function of his bid <script type="math/tex">b_i</script> and signal <script type="math/tex">s_i</script></p><script type="math/tex; mode=display">U\left(b_{i}, s_{i}\right)=\left(s_{i}-b_{i}\right) \cdot \operatorname{Pr}\left[b_{j}=b\left(S_{j}\right) \leq b_{i}, \forall j \neq i\right]</script><p>Thus, bidder i chooses b to solve:</p><script type="math/tex; mode=display">\max _{b_{i}}\left(s_{i}-b_{i}\right) F^{n-1}\left(b^{-1}\left(b_{i}\right)\right)</script><p>The first order condition is:</p><script type="math/tex; mode=display">\left(s_{i}-b_{i}\right)(n-1) F^{n-2}\left(b^{-1}\left(b_{i}\right)\right) f\left(b^{-1}\left(b_{i}\right)\right) \frac{1}{b^{\prime}\left(b^{-1}\left(b_{i}\right)\right)}-F^{n-1}\left(b^{-1}\left(b_{i}\right)\right)=0</script><p>At a symmetric equilibrium, <script type="math/tex">b_{i}=b\left(s_{i}\right)</script>, so the first order condition reduces to a differential equation (here I’ll drop the $i$ subscript):</p><script type="math/tex; mode=display">b^{\prime}(s)=(s-b(s))(n-1) \frac{f(s)}{F(s)}</script><p>This can be solved, using the boundary condition that <script type="math/tex">b(\underline{s})=\underline{s}</script>, to obtain:</p><script type="math/tex; mode=display">b(s)=s-\frac{\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}}{F^{n-1}(s)}</script><p>It is easy to check that b(s) is increasing and differentiable. So any symmetric equilibrium with these properties must involve bidders using the strategy  b(s).</p><h2 id="The-envelope-theorem-approach"><a href="#The-envelope-theorem-approach" class="headerlink" title="The envelope theorem approach"></a>The envelope theorem approach</h2><p>For bidder i, his equilibrium payoff is:</p><script type="math/tex; mode=display">U\left(s_{i}\right)=\left(s_{i}-b\left(s_{i}\right)\right) F^{n-1}\left(s_{i}\right)\label{usi_1}</script><p>Because i is playing the best-response in equilibrium, so:</p><script type="math/tex; mode=display">U\left(s_{i}\right)=\max _{b_{i}}\left(s_{i}-b_{i}\right) F^{n-1}\left(b^{-1}\left(b_{i}\right)\right)</script><p>Applying the Envelope Theorem we can get:</p><script type="math/tex; mode=display">\left.\frac{d}{d s} U(s)\right|_{s=s_{i}}=F^{n-1}\left(b^{-1}\left(b\left(s_{i}\right)\right)=F^{n-1}\left(s_{i}\right)\right.</script><p>and also:</p><script type="math/tex; mode=display">U\left(s_{i}\right)=U(\underline{s})+\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s} \label{usi_2}</script><p>As b(s) is increasing a bidder with signal $\underline{s}$ will never win the auction so we have $U(\underline{s})=0$, combine $\eqref{usi_1}$ and $\eqref{usi_2}$ we can easily get:</p><script type="math/tex; mode=display">b(s)=s-\frac{\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}}{F^{n-1}(s)}</script><h1 id="4-Vickery-auction-Second-price-auction"><a href="#4-Vickery-auction-Second-price-auction" class="headerlink" title="4 Vickery auction( Second price auction)"></a>4 Vickery auction( Second price auction)</h1><p>In a Vickrey, or second price auction, bidders are asked to submit sealed bids <script type="math/tex">b_{1}, \ldots, b_{n}</script>. The bidder who submits the highest bid is awarded the object, and pays the amount of the second highest bid.</p><p><strong>Proposition 1</strong> <em>In a second price auction, it is a weakly dominant strategy to bid one’s value <script type="math/tex">b_i(s_i) = s_i</script></em></p><p>(Easy to be proved, omitted here)</p><p>Since each bidder will bid their value, the seller’s revenue (the amount paid in equilibrium) will be equal to the second highest value. Let <script type="math/tex">S^{i: n}</script> denote the $i$ th highest of $n$ draws from distribution <script type="math/tex">F</script> (so <script type="math/tex">S^{i: n}</script> is a random variable with typical realization <script type="math/tex">\left.s^{i: n}\right)</script>. Then the seller’s expected revenue is <script type="math/tex">\mathbb{E}\left[S^{2: n}\right] .</script></p><h1 id="5-Revenue-equivalence"><a href="#5-Revenue-equivalence" class="headerlink" title="5 Revenue equivalence"></a>5 Revenue equivalence</h1><p>What is the revenue from the first price auction? It is the expected winning bid, or the expected bid of the bidder with the highest signal, <script type="math/tex">E[b(S^{1:n})]</script> To sharpen this, define <script type="math/tex">G(s)=F^{n-1}(s) .</script>Then <script type="math/tex">G</script> is the probability that if you take <script type="math/tex">n-1</script> draws from <script type="math/tex">F</script>, all will be below <script type="math/tex">s</script> (i.e. it is the cdf of <script type="math/tex">S^{1: n-1}</script> ). Then,</p><script type="math/tex; mode=display">b(s)=s-\frac{\int_{\underline{s}}^{s} F^{n-1}(\tilde{s}) d \tilde{s}}{F^{n-1}(s)}=\frac{1}{F^{n-1}(s)} \int_{\underline{s}}^{s} \tilde{s} d F^{n-1}(\tilde{s})=\mathbb{E}\left[S^{1: n-1} \mid S^{1: n-1} \leq s\right]</script><p>That is, if a bidder has signal s, he sets his bid equal to the expectation of the highest of the other n-1​ values, conditional on all those values being less than his own. Using this fact, the expected revenue is:</p><script type="math/tex; mode=display">\mathbb{E}\left[b\left(S^{1: n}\right)\right]=\mathbb{E}\left[S^{1: n-1} \mid S^{1: n-1} \leq S^{1: n}\right]=\mathbb{E}\left[S^{2: n}\right]</script><p>equal to the expectation of the second highest value. We have shown: </p><p><strong>Proposition 2</strong> <em>The first and second price auction yield the same revenue in expectation.</em></p><p>The result above is a special case of the celebrated “revenue equivalence theorem” .</p><p><strong>Revenue Equivalence Theorem</strong> :<em>Suppose n bidders have values</em> <script type="math/tex">s_{1}, \ldots, s_{n}</script> <em>identically and independently distributed with cdf <script type="math/tex">F(\cdot) .</script> Then all auction mechanisms that (i) always award the object to the bidder with highest value in equilibrium, and (ii) give a bidder with valuation <script type="math/tex">\underline{s}</script> zero profits, generates the same revenue in expectation.</em></p><p><strong>proof:</strong></p><p>We consider the general class of auctions where bidders submit bids <script type="math/tex">b_1,\dots,b_n</script>. An auction rule specifies for all i,</p><script type="math/tex; mode=display">\begin{aligned}x_{i} &: B_{1} \times \ldots \times B_{n} \rightarrow[0,1] \\t_{i} &: B_{1} \times \ldots \times B_{n} \rightarrow \mathbb{R}\end{aligned}</script><p>where <script type="math/tex">x_{i}(\cdot)</script> gives the probability $i$ will get the object and <script type="math/tex">t_{i}(\cdot)</script> gives $i$ ‘s required payment as a function of the bids <script type="math/tex">\left(b_{1}, \ldots, b_{n}\right)</script> . (For example in a first price auction, <script type="math/tex">x_{1}\left(b_{1}, \ldots, b_{n}\right)</script> equals 1 if <script type="math/tex">b_{1}</script> is the highest bid, and otherwise zero. Meanwhile <script type="math/tex">t_{1}\left(b_{1}, \ldots, b_{n}\right)</script> equals zero unless <script type="math/tex">b_{1}</script> is highest, in which case <script type="math/tex">t_{1}=b_{1}</script>)</p><p>Given the auction rule, bidder $i$ ‘s expected payoff as a function of his signal and bid is:</p><script type="math/tex; mode=display">U_{i}\left(s_{i}, b_{i}\right)=s_{i} \mathbb{E}_{b_{-i}}\left[x_{i}\left(b_{i}, b_{-i}\right)\right]-\mathbb{E}_{b_{-i}}\left[t_{i}\left(b_{i}, b_{-i}\right)\right]</script><p>Let <script type="math/tex">b_{i}(\cdot), b_{-i}(\cdot)</script> denote an equilibrium of the auction game. Bidder $i$ ‘s equilibrium payoff is:</p><script type="math/tex; mode=display">U_{i}\left(s_{i}\right)=U_{i}\left(s_{i}, b\left(s_{i}\right)\right)=s_{i} F^{n-1}\left(s_{i}\right)-\mathbb{E}_{s_{-i}}\left[t_{i}\left(b_{i}\left(s_{i}\right), b_{-i}\left(s_{-i}\right)\right]\right.</script><p>where we use (i) to write <script type="math/tex">\mathbb{E}_{s_{-i}}\left[x_{i}\left(b\left(s_{i}\right), b\left(s_{-i}\right)\right)\right]=F^{n-1}\left(s_{i}\right)</script>.<br>Using the fact that <script type="math/tex">b\left(s_{i}\right)</script> must maximize $i$ ‘s payoff given <script type="math/tex">s_{i}</script> and opponent strategies <script type="math/tex">b_{-i}(\cdot)</script>, the envelope theorem implies that:</p><script type="math/tex; mode=display">\left.\frac{d}{d s} U_{i}(s)\right|_{s=s_{i}}=\mathbb{E}_{b_{-i}}\left[x_{i}\left(b_{i}\left(s_{i}\right), b_{-i}\left(s_{-i}\right)\right)\right]=F^{n-1}\left(s_{i}\right)</script><p>and also</p><script type="math/tex; mode=display">U_{i}\left(s_{i}\right)=U_{i}(\underline{s})+\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}=\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s},</script><p>where we use $(i i)$ to write <script type="math/tex">U_{i}(\underline{s})=0</script> Combining our expressions for <script type="math/tex">U_{i}\left(s_{i}\right)</script>, we get bidder $i$ ‘s expected payment given his signal:</p><script type="math/tex; mode=display">\mathbb{E}_{s_{-i}}\left[t_{i}\left(b_{i}, b_{-i}\right)\right]=s_{i} F^{n-1}\left(s_{i}\right)-\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}=\int_{\underline{s}}^{s_{i}} \tilde{s} d F^{n-1}(\tilde{s})</script><p>where the last equality is from integration by parts. Since <script type="math/tex">x_{i}(\cdot)</script> does not enter into this expression, bidder i’s expected equilibrium payment given his signal is the same under all auction rules that satisfy (i) and (ii). Indeed, i’s expected payment given <script type="math/tex">s_{i}</script> is equal to:</p><script type="math/tex; mode=display">\mathbb{E}\left[S^{1: n-1} \mid S^{1: n-1}<s_{i}\right]=\mathbb{E}\left[S^{2: n} \mid S^{1: n}=s_{i}\right]</script><p>So the seller’s revenue is:</p><script type="math/tex; mode=display">\mathbb{E}[\text { Revenue }]=\sum \mathbb{E}_{s_{i}}\left[i \text { 's expected payment } \mid s_{i}\right]=\mathbb{E}\left[S^{2: n}\right]</script>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gurobi在python中的使用</title>
      <link href="2021/04/30/Gurobi-in-Python/"/>
      <url>2021/04/30/Gurobi-in-Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单学习了下gurobi 在python中的应用，日后估计会经常使用，在此做个记录方便以后掌握。</p><a id="more"></a><h1 id="Gurobi-配置"><a href="#Gurobi-配置" class="headerlink" title="Gurobi 配置"></a>Gurobi 配置</h1><p>在<a href="http://www.gurobi.cn/NewsView1.Asp?id=4">gurobi中国</a>按照要求填写一份pdf文档，然后需要去学信网搞一份学生身份验证。发给指定的邮箱地址后不久会有工作人员发来激活码。一个学生账户最多同时持有2份cd key，绑定机器，在激活前确定机器是否是你的常用机器。</p><p>收到回复邮件后，按邮件指示下载并激活。（gurobi.lic 许可文件要保存在相应目录下。）</p><p>可以配合anaconda在jupyter lab上使用，conda install gurobi需要加source，建议直接上网找。</p><h1 id="Gurobi-基本使用"><a href="#Gurobi-基本使用" class="headerlink" title="Gurobi 基本使用"></a>Gurobi 基本使用</h1><p>基本的使用范例为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建模型对象</span></span><br><span class="line">m=Model(name = <span class="string">&#x27;modelname&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加自变量，创建了一个长度为10的整型向量</span></span><br><span class="line">x = m.addVars(<span class="number">10</span>, lb=<span class="number">0</span>, vtype=GRB.INTEGER, name=<span class="string">&#x27;price&#x27;</span>) <span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写着写着发现官方是有资源的。。建议参考<a href="http://www.vvindsky.xyz/resources/Gurobi_tutorial.pdf">文档</a>与<a href="http://www.gurobi.cn/picexhview.asp?id=90">视频</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关今年夏天</title>
      <link href="2021/04/28/blog/"/>
      <url>2021/04/28/blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>意识到自己快要毕业这个事，是在球场上。    </p><a id="more"></a><p>盯着对面运球的人、嘴里喷着垃圾话的时候突然想到，1个月后大概就再也不会在这个场上跟对面这b打球了。</p><p>大学四年做了些什么？思来想去大概也就是写在CV上的那一页，多少觉得有些失败。TA楼顶的天台，坐着就能让目光越过丛树，望见行政楼背后的土坡卖力模仿着山脉起伏，弯下去的弧线衬起紫色的凤凰。本想着是个适合恋爱的好去处，但似乎四年也没能去上几次。</p><p>高考前对大学的期望是诗、酒与自由，料不到的是为了GPA的苟且。这个学校可以称得上是师范学院，在这里不断地上课、上课、上课，完全没有研究的时间，也没有思考的时间，更没有参加校外活动的时间。只是不断地上课、上课、上课，一直上到你的心灵枯竭，创造力也消失了。你成为了一部机器，不断地对那些如潮水般涌来的天真学生重复同样枯燥乏味的教材。</p><p>他们不了解为什么你变得这样乏味，因而对你失去了尊敬。大家也受了你的传染。不断上课、上课，上课的原因是，这是经营一所学校最经济的方法，让外界的人误以为学生得到了完整的教育。我们日复一日地过着无聊的生活，单调乏味的日子让人几年后想起来不禁怀疑，究竟自己是怎么过的，而时间已悄悄溜走了。</p><p>寻思着，除了课堂，9w5大概是花在了认识身边这群人上。半潇石、牛夹、莱昂诺·暴风、no_nick_name_pls、舒服喷子、活肌肉、批话王里的一群b…无论是学术、打球、lol或去rush b，总有一伙人一起。</p><p>毕业与分别的氛围总不可遏制地从身边传来。10:40起床遇到赶去上10:30课的蝗鸣儿：“没几节课可上了，去教室坐坐。”路过a316听到大四金融陶一舟在和家里商量什么时候先寄一批东西回家。和层小姐吃海底捞也被揶揄以后大学生优惠只能蹭她的。</p><p>有次跟软淑懵在if三楼闲聊，从代餐的佳格麦片聊到要是以后功成名就了，她就请我去“深圳最牛逼的楼顶天台”。如果我们泯然众人，就相约十年后回校我请她吃潘。转身回宿舍的时候想，以后八成不会再有她敷着面膜、我踹着拖鞋油头在三楼平台东一句、西一句扯淡的机会。</p><p>今早被闹铃吵地迷糊时，走廊里随着淋浴声传来龙大黑人的歌：</p><p><center>我怕我 没有机会</center></p><p><center> 跟你说一声再见</center></p><p><center>因为也许就再也见不到你</center></p><p><center>明天我要离开</center></p><p><center>熟悉的地方和你</center></p><p><center>要分离</center></p><p><center>我眼泪就掉下去</center></p><p align="center"><font face="STKaiti ">  </font></p><p>大学四年都不是个爱去教室上课的主，但最近喜欢赶早去会饮点杯咖啡，猫在诚道教室的最后一排刷手机发呆。偶尔在前排遇到个很久没见的熟人，摆摆手打个招呼之后总感觉有些怅然若失。他们就这样在某一天突然消失。没有解释，甚至连个像样的告别也没有，就像用一把锋锐无声的大砍刀，将温暖的血液奔流不息、脉搏还在静静跳动的纽带，一刀斩断。</p><p>村上春树在《海边的卡夫卡》里说：</p><p></p><p align="left"><font face="STKaiti "> &nbsp&nbsp&nbsp&nbsp 我们大家都在持续失去宝贵的东西。宝贵的机会和可能性，无法挽回的感情。这是生存的一个意义。  </font></p><br>我想，在夏天遇见的，就在夏天告别吧。<p></p><p>一直没能想好要起一个什么标题。if的毕业晚宴合唱了一首今年夏天，我决定拿来做标题。</p><p><img src="/2021/04/28/blog/test.png" alt="结尾"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>猫咪分类实现</title>
      <link href="2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/"/>
      <url>2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/封面.jpeg" style="zoom:25%;"></p><center>利用神经网络、残差神经网络进行猫咪分类训练。</center><a id="more"></a><h3 id="实现的主要部分有"><a href="#实现的主要部分有" class="headerlink" title="实现的主要部分有"></a>实现的主要部分有</h3><ul><li>简单的网络结构在猫的种类识别上的应用，测试准确率0.832</li><li>使用resNet50在猫的种类识别上的应用，测试准确率0.866</li><li>使用数据增强解决过拟合问题，并提高测试准确率，测试准确率0.999</li></ul><h3 id="项目文件夹说明"><a href="#项目文件夹说明" class="headerlink" title="项目文件夹说明"></a>项目文件夹说明</h3><pre><code>------cat_kind  项目文件名    |----cat_data_resNet50  存放用于resNet网络训练的数据        |----train      训练数据        |----test       测试数据    |----cat_kind_data  存放用于简单案例网络训练的数据（train.py）        |----train      训练数据        |----test       测试数据    |----dataAug    数据增强后存放训练集的位置    |----models     保存训练模型的位置    |----resnet_example     使用resnet网络的文件夹        |----predict_on_resnet.py   预测的时候使用的文件        |----resnet50.py    定义resnet网络的文件        |----train_on_resnet.py     训练resnet的文件    |----source_images      数据集的原始文件夹        |----0类猫        |----1类猫        |----2类猫        |----3类猫        ...        |----n类猫    |----tools      工具文件夹        |----data_aug.py    数据增强        |----prepare_data.py    数据预处理    |----predict.py     使用简单网络进行预测的文件    |----requirement.txt    环境依赖    |----train.py       使用简单网络进行训练的文件</code></pre><h4 id="step1-数据集预处理"><a href="#step1-数据集预处理" class="headerlink" title="step1 数据集预处理"></a>step1 数据集预处理</h4><p>使用文件：prepare_data.py</p><p>包括的操作有：</p><h5 id="图片重命名"><a href="#图片重命名" class="headerlink" title="图片重命名"></a>图片重命名</h5><ul><li>在renameJPG()方法实现，重命名的意图有两个，第一是将图片都统一为一种图片类型，第二个目的是给图片添加训练标签（当然也可以将标签写在文件当中，这里只是一种简便的做法）</li></ul><h5 id="图片转换为统一的格式"><a href="#图片转换为统一的格式" class="headerlink" title="图片转换为统一的格式"></a>图片转换为统一的格式</h5><ul><li>图片重命名保存的过程中将图片统一格式</li></ul><h5 id="图片统一大小"><a href="#图片统一大小" class="headerlink" title="图片统一大小"></a>图片统一大小</h5><ul><li>该网络要求输入图片的大小为(100,100),所以运行时要修改out_img_size为(100,100)，数据集保存位置save_dir为cat_kind_data</li></ul><h5 id="将图片按照一定的比例划分"><a href="#将图片按照一定的比例划分" class="headerlink" title="将图片按照一定的比例划分"></a>将图片按照一定的比例划分</h5><ul><li>按照比例9:1将数据划分为训练集和测试集,默认参数为0.9</li></ul><h4 id="step2-训练"><a href="#step2-训练" class="headerlink" title="step2 训练"></a>step2 训练</h4><ul><li>使用文件：train.py，直接执行</li></ul><h4 id="step3-测试"><a href="#step3-测试" class="headerlink" title="step3 测试"></a>step3 测试</h4><ul><li>使用文件：predict.py，直接执行</li></ul><h3 id="二-使用经典网络ResNet50实现猫的种类识别"><a href="#二-使用经典网络ResNet50实现猫的种类识别" class="headerlink" title="二 使用经典网络ResNet50实现猫的种类识别"></a>二 使用经典网络ResNet50实现猫的种类识别</h3><ul><li>由于resnet网络较为复杂，在少量的数据集情况下结果容易出现过拟合，所以首先进行数据增强的处理</li></ul><h4 id="step1-数据增强"><a href="#step1-数据增强" class="headerlink" title="step1 数据增强"></a>step1 数据增强</h4><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/sample.png" alt></p><p>直接运行data_aug.py，然后会在dataAug文件夹下生成12个对应猫种类的文件夹，相应的参数可以在data_aug.py调整</p><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/data_aug.png" alt></p><h4 id="step2-数据集预处理"><a href="#step2-数据集预处理" class="headerlink" title="step2 数据集预处理"></a>step2 数据集预处理</h4><p>使用文件：prepare_data.py</p><p>包括的操作有：</p><h5 id="图片重命名-1"><a href="#图片重命名-1" class="headerlink" title="图片重命名"></a>图片重命名</h5><ul><li>在renameJPG()方法实现，重命名的意图有两个，第一是将图片都统一为一种图片类型，<br>第二个目的是给图片添加训练标签（当然也可以将标签写在文件当中，这里只是一种简便的<br>做法）</li></ul><h5 id="图片转换为统一的格式-1"><a href="#图片转换为统一的格式-1" class="headerlink" title="图片转换为统一的格式"></a>图片转换为统一的格式</h5><ul><li>图片重命名保存的过程中将图片统一格式</li></ul><h5 id="图片统一大小-1"><a href="#图片统一大小-1" class="headerlink" title="图片统一大小"></a>图片统一大小</h5><ul><li>在resNet中要求图片的大小在197——224之间，这里将图片的大小统一在224*224</li></ul><h5 id="将图片按照一定的比例划分-1"><a href="#将图片按照一定的比例划分-1" class="headerlink" title="将图片按照一定的比例划分"></a>将图片按照一定的比例划分</h5><ul><li>按照比例9:1将数据划分为训练集和测试集</li></ul><h4 id="step3-定义网络结构"><a href="#step3-定义网络结构" class="headerlink" title="step3 定义网络结构"></a>step3 定义网络结构</h4><ul><li><p>网络结构采用Keras搭建好的resNet50，使用文件：resnet_example/resnet50.py</p></li><li><p>使用文件：resnet_example/resnet50.py,原始文件可从<a href="https://github.com/fchollet/deep-learning-models">deep-learning-models</a><br>获取，为了使得该文件能适应训练加测试，我做了相应的修改</p></li></ul><h4 id="step4-训练"><a href="#step4-训练" class="headerlink" title="step4 训练"></a>step4 训练</h4><ul><li>使用文件：resnet_example/train_on_resnet.py</li></ul><h4 id="step5-测试"><a href="#step5-测试" class="headerlink" title="step5 测试"></a>step5 测试</h4><ul><li>使用文件：resnet_example/predict_on_resnet.py</li></ul><h3 id="三-模型文件及数据集下载"><a href="#三-模型文件及数据集下载" class="headerlink" title="三 模型文件及数据集下载"></a>三 模型文件及数据集下载</h3><p>数据集使用的是来自百度公开数据集的猫咪12分类数据</p><p><a href="https://aistudio.baidu.com/aistudio/datasetDetail/10954">12分类数据集</a></p><p><a href="http://www.vvindsky.xyz/cat_kind.zip">代码下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春晚</title>
      <link href="2021/04/21/2021%E6%98%A5%E6%99%9A/"/>
      <url>2021/04/21/2021%E6%98%A5%E6%99%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/logo.png" style="zoom:30%;"></p><center>你的下一片a14何必是a14</center><a id="more"></a><p>没有全程跟着发布会看，但发布会结束的时候还没睡，所以算是第一时间知道了发布会的消息，当天晚上在论坛逛到三点半讨论新的ipad pro ，不得不说cook牛逼。</p><p>一个个来吧。</p><h1 id="AirTag"><a href="#AirTag" class="headerlink" title="AirTag"></a>AirTag</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/airtag.png" style="zoom:30%;"></p><p>没啥好说的，有钱可以玩玩。</p><p>目前看了一些评测，远距离就像是个查找我的iphone一样不够灵敏。10m之内才能使用最新的UWB技术精准制导。</p><p>以前想的给猫猫狗狗带一个来防走失看来也不是那么可行。</p><p>只能说一个蜂鸣器+蓝牙+UWB不值这个价格，logo值👍。</p><h1 id="iMac"><a href="#iMac" class="headerlink" title="iMac"></a>iMac</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/imac.png" style="zoom:50%;"></p><p>苹果还是放不下🌈的，更令人眼前一亮的是妙控三件套的新配色。鼠标、键盘和触控板的那个薄荷绿色看起来很舒服。不过至于imac的话其实个人感觉新配色有些张扬，这个苹果设计还是太空灰的性冷淡风更对味道。</p><p>看到论坛上很多hackintosh的老哥们很欣喜因为新版的妙控键盘支持指纹解锁，这大概是指纹解锁首次下放黑果群体。</p><p>配置上升级为m1,屏幕统一变为24寸5k，前置摄像头由万年不变的720升级成了1080，发布会上还重点宣传了音频系统的提升。</p><p>接口方面，2个雷电4+两个普通type c，新版更新了磁力充电口，并且网线可以插在电源适配器上（虽然不知道为什么突兀加了这么个设计）。看到演示会演示充电方式的时候我第一反应是：</p><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/胖虎.jpg" style="zoom:50%;"></p><p>不得不吐槽这个充电线的外观缺了点苹果的elegant味。</p><p>总的来说可以定义为一款桌面端的MacBook air吧，下次回家给家里爸妈整一台，他们不需要游戏性能，能看个剧、处理下简单的办公就够用，也看着很漂亮，完美。</p><h1 id="新配色iphone"><a href="#新配色iphone" class="headerlink" title="新配色iphone"></a>新配色iphone</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/iphone.jpg" style="zoom:50%;"></p><p>好看，买。</p><p>🌈+紫，cook的心意够明显了。</p><h1 id="革命者"><a href="#革命者" class="headerlink" title="革命者"></a>革命者</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/ipad.png" style="zoom:20%;"></p><p>以下内容是我主观想法，如果日后发现我的观点是错的，那我就回来改，所以我大概率永远是对的😊。</p><p>先谈性能，很多人在吹M1多牛逼，ipad背刺air云云。。但就我手里的这款ipad pro 2018而言，在2018年他发售之时就开始有这样的论调了。A12X或是A12Z都远远不是ipad与笔记本竞争的关键，系统才是。</p><p>ipad pro这么香都不耽误mba出货无非就是生态。我买个mba，软件生态齐活了。但我买个ipad，不配键鼠套装就是一纯爱奇艺浏览器，顶天写个笔记看个课件，办公就别想了。</p><p>那么如果我配键鼠呢？一代键鼠的价格和使用体验太拉了，罗技等厂家的二创比他高到不知哪里，二代键鼠体验要好上不少。但依然无法摆脱一个问题，笔记本10分钟做完的ppt，我在ipad上要做半个小时。笔记本上剪个视频、修个图各种快捷键素材库云云都很完善，而ipad根本没有跟上。</p><p>那我为什么说这款ipad pro是个革命者呢？</p><p>apple下场做芯片了，Intel命数已尽。这样一个牙膏厂能霸占市场这么久真是天下苦intel久矣。m1芯片的大规模量产铺货乃至推广到ipad pro上基本宣告apple自研芯片的成熟。而且以苹果更新迭代的速度，年年都是宣传性能40、50%这样子往上飞跃，intel哪里见过这阵仗，到现在都守着14nm老本。Apple yes! </p><p>之前看到过一句话，<strong>一个行业的改革多由其他行业的佼佼者入场而引发</strong>。</p><p>说回pad本身，基本宣告安卓系pad的出局，这价格，这品质，这logo（笑。其他厂商没得打，能击败这代ipad pro的只有可能是下一代ipad pro。</p><p>手持ipad pro2018也在考虑是否更换iPad pro2021，主要看头在WWDC上，我个人感觉ipad OS应该有大动作，不然没有理由不上A14X、A14Z而上M1，此前我一直以为M1 的M是for Mac的意思。</p><p>如果ipad os能有合适的作为，整个操作系统又是一次大洗牌。开发者一份工挣ipad群体和mac群体两份钱，这势必会带动mac os软件生态改善，又接着带来更多用户加入mac os生态，一个良性组合拳打的漂亮。</p><p>当然一切都是颅内臆想出来的，ipad os怎么向mac os融合是个麻烦，这两套设备硬件上的差别太大了，如何设计交互是个大问题，但这是苹果，值得一个期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只狼-影逝二度</title>
      <link href="2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/"/>
      <url>2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/index.jpeg" style="zoom:33%;"></p><center> 有死之荣，无生之辱</center><p>只狼打通了回来补一个通关感受，这个游戏是我目前为止游玩时间最长的单机游戏，也是我第一个肝到全成就的游戏。跟舍友一起打的剑圣，犹记得剑圣跪地时舍友的欢呼和我把手柄一甩的仰天长啸。</p><p>宫崎英高，yyds。</p><a id="more"></a><p>这里只想谈谈对整个游戏的感受，至于打法攻略很多up都有做总结， 推荐<a href="https://www.bilibili.com/video/BV1Nb41177ja?from=search&amp;seid=3555517953000752865">老戴</a>的只狼攻略视频，手残友好。</p><h1 id="故事主线"><a href="#故事主线" class="headerlink" title="故事主线"></a>故事主线</h1><p>先讲一下主线，这次主线的叙事不同于以往的魂系列。剧情还是相对明了的，认真玩过不跳过场动画的人都能大致知道。不过由于运用“插叙”的展开方式，有些内容玩到后期才能理解，这里顺序介绍故事剧情。</p><p>一心盗国二十余年，苇名国以日暮途穷。而此时，日本正处于战国末期，烽火连天，即使是位于山林深处的苇名国也被不少人耽视。但忌惮于剑圣一心的实力，不敢妄动。直到剑圣一心患上不治之症，敌国甚至开始大张旗鼓的准备起战事。</p><p>一心盗国时，其得力手下有四：巨型忍者“枭”、蝴蝶夫人、猿之忍者、医师道玄。</p><p>其中猿之忍者由于过重的罪业，化身为修罗。被剑圣一心砍断左手才恢复神智，最后隐居某个破旧的寺庙之中，想通过雕刻佛像来偿还自己的罪业。</p><p>突然有一天，苇名国一个叫平田的小城被大量的土匪入侵，而且这次土匪入侵并不一般：他们甚至花了大价钱雇佣强力的僧兵来作战，巨型忍者“枭”的义子，御子（中文翻译为皇子，有点误导。九郎并不是皇室，和苇名一族也没有血源关系，也没有管理国家的责任）的贴身的忍者“狼”也被僧兵击败负伤。即使巨型忍者“枭”和蝴蝶夫人前去帮助也无法阻止。</p><p>原来策划这起入侵的人，正是巨型忍者“枭”。他策反了蝴蝶夫人，让她绑走年幼的御子九郎，而自己假装不敌诈死，以掩人耳目。</p><p>“枭”的计划几乎快要成功之时，突然杀出了一位断臂的忍者。这名忍者就是三年后顺着记忆穿越而来的“狼”。</p><p>（这里有两种说法，一种就是物理穿越，还有一种就是单纯的回忆，我更偏向于物理穿越。一直在找证据：下方会有两种说法的具体分析）</p><p>断臂的只狼一路杀伐，甚至斩杀了自己的老师-蝴蝶夫人。在即将救到御子时，被诈死的“枭”偷袭，死在了大火之中。</p><p>年幼的皇子从大火和废墟之中救出了“狼”，并赋予了自己的龙胤之力，“狼”获得了重生。</p><p>“枭”如此大费周张的策划这起事件的原因，也正是因为想得到这“龙胤之力”不朽的力量。</p><p>不朽之法有四种：龙胤之力、京城水、变若水和附虫。虽说是三种，其实都是一个根源-从古老的西方（中国）被驱逐而来的樱龙（就是被狼用巨雷枪射爆的那位）。</p><p>龙胤，顾名思义就是龙的子嗣，龙力量的继承人。龙胤本身不会死亡，即使被砍伤也不会流出一滴血，伤口会瞬间愈合。并且龙胤可以把这个力量分享给别人，被分享力量的人会受伤，但死亡后会重生。这个重生的力量就被称为“龙胤之力”。</p><p>龙胤之力是三种不朽之法中最纯正的，代价最小的。但依然有代价：每次死亡与重生，都会吸取与你有过交集之人的生命力，使之患上名为“龙咳”的病症，且唯一治疗的方法就是用“龙胤滴露”将生命力归还于患有“龙咳”者。</p><p>不朽之法其二：京城水。樱龙来到日本后，找到了一块风水之地盘旋与栖息，这块风水之地就是“源之宫”。</p><p>但樱龙强大的力量也给源之宫带来了翻天覆的改变：首先是水，生活在上游源头的淤加美贵族外形办成了非人非龙的模样，且寿命变得极长，甚至还可以再用某种办法无限延续自己的寿命：吞噬别人的寿命（俗称+1s）。</p><p>不朽之法其三：附虫。水质的改变产生了巨大的王鲤鱼。王鲤鱼一共有两头，也拥有不朽之力。其中一头死后（死因不详）尸体被蠕虫吞噬，这些吞噬王鲤鱼的蠕虫，变成了不朽的附虫，这些附虫在水中不断产卵繁殖。</p><p>源之宫，顾名思义，这里是苇名地区水的源头（点击佛渡，手柄按Y键即可查看古地图）。附虫卵随着水源流动到苇名各地，不幸服下卵的人，就会变为附虫者，拥有不死之身，比如狮子猿、死兵卫和仙峰寺上长有附虫的长老。</p><p>但附虫可以说是代价非常之大的不死之法：大部分其实都被附虫所控制：二阶段的狮子猿、仙峰寺的长老。即使不被控制，也会相当痛苦，求死不能：死兵卫。</p><p>最后是变若水，变若水其实是人为研究的产物，通过研究附虫，试图人造出龙胤。且研究过程中付出了极大的代价：苇名之底的水生村就是试验场，所有的村民都变成了没有意识到活尸（且并没有不死之身）。</p><p>水生村本是一个贫穷幽静的村庄，村民淳朴的不像话，他们都无条件的信任着神官大人，而神官本人也憨厚的一匹。</p><p>有一天，一个人（还不清楚是谁，有评论说是水生村之前的那个淤加美吹箫哥。可能性很高）找到了神官，让他酿造一种酒（实为变若水），并许诺，只要酿造成功，就能让他成为京城人，可以在源之宫生活。</p><p>神官很高兴的将这个消息分享给大家，让大家能一起变为京城人。神官不断的酿造和尝试，给大家分享酿出的酒（变弱水）。最终，全部村民都因为劣质的变若水兽化，失去意识变为活尸。</p><p>最后当狼找到以变为活尸的神官时，他还在不断的酿造，不断的呢喃着让大家都变成京城人。</p><p>除了水生村外，仙峰寺也在尝试制作变若水，只是不知道是有人指使还是本身被对永生的贪婪。他们抓来前来朝拜的年轻人开始研究，直到狼来到先锋寺时，都能看到遍地的尸体。</p><p>仙峰寺里有一种不带附虫的不死老者，应该就劣质变若水的产物（但比水生村强多了）。最终在付出巨大代价后，仙峰寺也确实成功了，他们制作出了非常接近龙胤的赝品：唯一的一个变若之子。并将变若之子藏于内殿之中。</p><p>这一节对于龙胤、附虫、变若水的补充信息量有点多，但还是很有必要的。</p><p>书接上文，虽然“枭”在“狼”击败蝴蝶夫人后，背后一刀捅死了“狼”泄愤，但他最终还是失败了，以诈死的他不便出手再挟持御子。</p><p>物理穿越的“狼”被御子赐予龙胤之力后，取得了回忆，回到了三年之后。</p><p>而原本时间线的狼并不知道发生了什么，而且也没有龙胤之力。</p><p>最后御子被接到了苇名城保护起来，说是保护，实际上是监禁。而正常时间线上的狼，被告知义父和御子已死。这一切应该是苇名一心的义孙，苇名弦一郎搞的鬼。原因当然也是想得到“龙胤之力”。（至于为什么没把狼杀掉，有可能是出于一心的保护，也有可能是出于弦一郎的自大）</p><p>狼失去了活着的目标和动力，被囚禁于废弃的井底，一晃就是三年。</p><p>突然有一天，一心让道玄的义女，自己的学生和最信任的人“花菖蒲”（也就是医师永真）找到狼，告诉狼御子还活着，并让狼带着御子永远的逃离苇名城。</p><p>忍者知道后立刻动身救出了御子，在即将逃出苇名城的一刻，被弦一郎亲自埋伏，但不敌狼，最后用卑鄙手段砍断了狼的左手，再次抢回御子。</p><p>这时弦一郎已经坐不住了，他带着御子去到苇名主城，用各种办法：晓之以情，动之以理，威逼利诱，用各种办法想让御子直接把龙胤之力给他。</p><p>而狼在医师永真和一位雕佛师的帮助下，杀进了苇名城，再次击败弦一郎，但弦一郎复活了，原来弦一郎自己也喝了变若水。前面我已经提到了变若水，可能弦一郎疯狂的执念和这变若水有关，也可能无关。</p><p>自知不敌的弦一郎一个漂亮的背跃式跳高（跳了半米高）逃跑了。狼成功的救下了御子，他的最高任务是保护御子的周全，并按照原先的计划，想带着御子永远离开苇名。</p><p>但御子拒绝了，他要留在苇名，因为御子讨厌自己的龙胤之血，而且在经历了这么多祸端之后，决心要彻底消除它。狼很纠结，因为如果答应御子，等于违抗了义父命令，等于背弃了忍者的信条。</p><p>但他最后还是答应了，开始寻找清除龙胤需要的材料：龙之泪。</p><p>要获得龙之泪，就要到达“仙乡”，也就上文提到的“源之宫”。</p><p>要去往“仙乡”，需要几种“香料”。</p><p>其中一种，就是龙胤之血。前面我也提到龙胤即使受伤也不会流血，且伤口会瞬间愈合。</p><p>但苇名一心告诉狼：世界上有一种叫做“不死斩”的刀。可以杀死无法死去之人，也可以伤到龙胤。藏于仙峰寺内，让狼去取得。</p><p>实际上，“不死斩”一共有两把，一把是赤红色的“拜泪”（败类……中文翻译者是认真的吗？）；另一把是黑色的“开门”。</p><p>“开门”可以以无法死去之人为贡品，开启黄泉的大门。一心是知道两把不死斩的存在的，但只告诉了狼“拜泪”的存在和位置。</p><p>狼先后到了菩萨谷、水生村和仙峰寺寻找香料，在仙峰寺见到了唯一一个成功的若水之子，取得了不死斩“拜泪”。在于若水之子的交流中得知：即使斩断不死，去除御子龙胤，还是会有新的龙胤产生。一切只不过是轮回罢了，唯一的办法，就是将龙胤送回他的故乡-中国。只有那里，龙出生的地方，才能承受龙胤的力量。</p><p>为此狼为变若之子收集了两个蛇神的内脏，变若之子吞下后，化作摇篮。并且流出的眼泪化作了宝石-冰泪。只要御子将冰泪和樱龙之泪一同服下，就能完成摇篮的仪式。</p><p>在狼前往苇名各处寻找前往仙乡的材料时，他的义父，巨型忍者“枭”带着忍者突然闯入了苇名，他到这里的目的也只有一个：御子的龙胤之力。</p><p>看到御子不合作，“枭”直接命令狼：终止保护御子的命令，现在你和御子已经没有任何关系了。狼其实早已背弃了命令，所以丝毫没有犹豫的拒绝了。</p><p>枭想像三年前那样背后偷袭狼，被狼识破并斩杀。</p><p>（再补充一下修罗结局：如果这时狼选择遵从意旨，舍弃御子。则代表狼已经放弃了自己最后一丝人性，化为修罗。这时，永真说你已经成为了修罗，并且试图唤醒你。之前和永真对话，狼会问：你的剑术是谁教的？永真会说：我是医生不是武士，怎么会剑术。狼：那如何解释你身上的剑气？永真：因为感兴趣，一心曾教过我一点剑法。狼：这样的剑气绝不可能是感兴趣。永真：我绝对不会杀人的，如果有鬼的话，我会杀鬼吧。当你斩杀阻止你的永真后，年迈的剑圣一心会到来，捧着永真的尸体，说我曾经斩过修罗一样的人，没想到还会斩第二次。随后开战，不得不说，年迈的一心并不比年轻时弱很多。相对于年轻时右手拿刀左手拿钺，裤裆里还藏着五连发手枪，年迈的一心更配得上剑圣这个称号。当你斩杀一心后，枭回来了，手里拿着黑色不死斩，说明弦一郎这只鸡已经被他干掉，他看到一心的尸体说：即使是年迈的一心，你能战胜他我也很震惊，不愧是我的儿子。仰天大笑，这个国家已经在他手中了。然后被狼一刀捅死，枭问为什么，直到他看了狼一眼，大叫一声修罗。狼拿过那把黑色不死斩高举端详，从他沉醉的背影看得出来已经魔化。这一幕正好被御子看到，即使是这样御子也不愿意相信，“你不可能是修罗！”在御子的悲鸣中，修罗路线结束）</p><p>御子对狼为了自己手刃义父的事情很自责，其实对于狼来讲，这是他挣脱信条的束缚，获得自我的标志。</p><p>在狼踏上仙乡收集龙之泪的最后阶段，剑圣苇名一心终于病死。德川家康如同秃鹫一般嗅到了一心死亡的信息。早已备好的军队瞬间涌入苇名，战争之火瞬间烧毁了半个苇名城。</p><p>医师守在死去的一心前告诉狼：御子通过之前密道先逃出了苇名，让狼紧随其后。狼到达时，又遇到了弦一郎，这次弦一郎也拿到了另一把不死斩“开门”来抢夺皇子的龙胤之力，但并没有什么卵用（反而比以前更菜了），依然被狼按在地上暴打。</p><p>鼻青脸肿的弦一郎终于意识到了自己的无能，用自己手中的“开门”割破了自己的脖子，以执念召唤出了年轻的、鼎盛时期的剑圣苇名一心。不知是变若水的影响还是“开门”的影响，决定要杀光所有的入侵者。</p><p>被狼艰难击败，最后一心似乎恢复了神智，用尽全力控制住自己的身体端坐，狼将其斩首，再次送入黄泉。</p><p>随后，狼喂御子服用了樱龙之泪于冰泪，带到了变若之子面前，装进了以化作摇篮的身体。</p><p>最后，御子、变若之子和狼将踏上遥远的旅途：将龙送回中国。</p><p>以上为“龙之归乡”任务剧情。</p><h1 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h1><p>刚开始玩的时候是真的玩不进去，故事叙述风格也迷，开头的苇名国建国史看不懂就算了和后面我要干嘛有什么关系？没有地图引导，去哪里我都搞不灵清，开局就有一个boss两刀砍死我。宫崎英高，屌人搞我，大概就这种感受。</p><p>新学期开学后cyw、lbj我们一起一个个boss刷下去，开始能慢慢体会到魂类游戏的魅力。</p><p>//TODO：对魂类游戏的观感、关卡设计、美术风格、战斗交互。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.png" alt="新建" style="zoom: 33%;"></p><p>每次提到排序印象都是，学过排序，但脑子里就剩下个快排，抽个空把所有叫得上名字的排序整理下，日后复习起来也简单些。</p><a id="more"></a><p>​    分类</p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p>​    基本概念介绍</p><h1 id="1-冒泡排序-Bubble-Sort"><a href="#1-冒泡排序-Bubble-Sort" class="headerlink" title="1 冒泡排序 Bubble Sort"></a>1 冒泡排序 Bubble Sort</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    比较基本的排序算法，在每次循环开始时从一端的元素开始向另一端循环，遇到右&gt;左则换位，这样在第一遍循环之后 我们可以保证数组的最右端是最大元素。依次重复n此后可保证数组按顺序排列完毕。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/bubble.gif" alt></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index &lt;len ;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                value = *pivot;</span><br><span class="line">                *pivot = arr[index];</span><br><span class="line">                pivot = &amp; arr[index];</span><br><span class="line">                *pivot = value;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h1 id="2-选择排序-Selection-Sort"><a href="#2-选择排序-Selection-Sort" class="headerlink" title="2  选择排序 Selection Sort"></a>2  选择排序 Selection Sort</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    也是一个比较基本的排序算法，每次循环时找到数组中最小的元素将其放在数组最左端。循环n次后得到排序完成的数组。</p><h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/selection.gif" alt></p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index&lt;len;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                pivot = &amp;arr[index]; <span class="comment">//指向新的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//与未排序部分的第一位进行替换</span></span><br><span class="line">        value = *pivot;</span><br><span class="line">        *pivot = arr[i];</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h1 id="3-插入排序-Insertion-Sort"><a href="#3-插入排序-Insertion-Sort" class="headerlink" title="3 插入排序 Insertion Sort"></a>3 插入排序 Insertion Sort</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    大体思想为，循环i次时，保证数组的前i位元素都为已经排序好的，每次到i元素</p><h2 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/insertion.gif" alt></p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index&lt;len;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                pivot = &amp;arr[index]; <span class="comment">//指向新的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//与未排序部分的第一位进行替换</span></span><br><span class="line">        value = *pivot;</span><br><span class="line">        *pivot = arr[i];</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><h1 id="4-希尔排序-Shell-Sort"><a href="#4-希尔排序-Shell-Sort" class="headerlink" title="4 希尔排序 Shell Sort"></a>4 希尔排序 Shell Sort</h1><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；(不同颜色表示不同序列 )</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h2 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/shell.gif" alt></p><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">shellSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(vargap = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = Math.<span class="built_in">floor</span>(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class="line">        <span class="keyword">for</span>(vari = gap; i &lt; len; i++) &#123;</span><br><span class="line">            varj = i;</span><br><span class="line">            varcurrent = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><h1 id="5-归并排序-Merge-Sort"><a href="#5-归并排序-Merge-Sort" class="headerlink" title="5 归并排序 Merge Sort"></a>5 归并排序 Merge Sort</h1><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/merge.gif" alt></p><h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">mergeSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        returnarr;</span><br><span class="line">    &#125;</span><br><span class="line">    varmiddle = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    returnmerge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">merge</span><span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    varresult = [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    returnresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><h1 id="6-快速排序-Quick-Sort"><a href="#6-快速排序-Quick-Sort" class="headerlink" title="6 快速排序 Quick Sort"></a>6 快速排序 Quick Sort</h1><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quicksort.gif" alt></p><h2 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">quickSort</span><span class="params">(arr, left, right)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left =typeofleft !=&#x27;number&#x27;? 0 : left,</span><br><span class="line">        right =typeofright !=&#x27;number&#x27;? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">partition</span><span class="params">(arr, left ,right)</span> </span>&#123;    <span class="comment">// 分区操作</span></span><br><span class="line">    varpivot = left,                     <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(vari = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    returnindex<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">    vartemp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><h1 id="7-堆排序-Heap-Sort"><a href="#7-堆排序-Heap-Sort" class="headerlink" title="7 堆排序 Heap Sort"></a>7 堆排序 Heap Sort</h1><h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">参考博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thompson Sampling笔记</title>
      <link href="2021/01/30/Thompson%20Sampling%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/30/Thompson%20Sampling%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提利昂·兰尼斯特是龙还是狮的一些猜想</title>
      <link href="2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/"/>
      <url>2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/提利昂插画.png" alt="提利昂插画" style="zoom:33%;"></p><p>​    提利昂·兰尼斯特斯特的出身问题一直是冰火论坛里争论不休的热点话题。附庸风雅地来总结下我看到的双方观点论据。</p><a id="more"></a><p>​    在开始讲两派观点之前先声明下我的观点，我认为小恶魔是龙家，主观上纯粹因为爽，一个如此讨喜的人物配拥有一身龙血，并且可以规避弑亲必死的因果律武器。客观原因在以下的论据中体现，我按我认为的可信度强弱将证据进行了排序。</p><h1 id="观点1：小恶魔是龙家的"><a href="#观点1：小恶魔是龙家的" class="headerlink" title="观点1：小恶魔是龙家的"></a>观点1：小恶魔是龙家的</h1><h2 id="证据1-发色与异色瞳（难以辩驳的铁证）"><a href="#证据1-发色与异色瞳（难以辩驳的铁证）" class="headerlink" title="证据1 发色与异色瞳（难以辩驳的铁证）"></a>证据1 发色与异色瞳（难以辩驳的铁证）</h2><p>马丁在人的发色和身材外貌描写上是很注重细节的，无论是私生还是嫡生都可以看到很多关于父子或一个家族中相近的特点存在，如狮子家的金发、龙家的白化病（笑）、大小剥皮的瞳孔，这些细节让冰火的世界充满味道。</p><p>说回重点，这是小恶魔在卷一出场时的描写：</p><p>「    <strong><em>琼恩发觉自己几乎无法将视线从他身上抽离，他暗想，这才是王者应有的风范。接着他望向兰尼斯特雄狮的弟弟，小恶魔提利昂，此人正摇摇摆摆走在哥哥身边，他是个身高只有哥哥一半的侏儒，鼓动着畸形的双腿努力追上哥哥的脚步，他的头大得不成比例，鼓胀额头下是一张扭曲的怪脸，双眼一碧一黑，从满头长直金发下面向外窥视，他头发的颜色几乎金亮成白。</em></strong>」</p><p>重点在 <strong>一碧一黑 </strong>与 <strong>金亮成白</strong>，先说异色瞳这一点，这在冰火世界中目前提到的还有两例分别为<strong>西蕊洋星</strong>与<strong>阿莱莎·坦格利安</strong>，这两人都是龙血。</p><p>西蕊洋星是庸王伊耿四世的私生女，寒铁、血鸦都在追求的大美女，她的瞳色是一蓝一绿。（TheMico的西蕊洋星插画👇）</p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/西蕊洋星.png" alt></p><p>阿莱莎·坦格利安是外传血与火中出场的人物，是国王杰赫里斯一世与王后亚莉珊·坦格利安的第二个孩子，一名御龙者，她的龙是红龙梅利亚斯。她天生异瞳，一只是紫罗兰色，另一只是绿色。</p><p>「它和我都曾是紅色處女，現在我們都被騎了。</p><p>​                                            —— 阿萊莎在駕馭她的龍後，評價她自己和梅麗亞斯」</p><p>「我壓在他身上，反覆騎他。今晚我還要再好好享受，我喜歡騎他。</p><p>​                                            —— 阿萊莎在她的新婚之夜次日清晨宣稱    」</p><p>还有<strong>发色金的发白</strong>，我个人认为这是几乎明示提利昂有龙血了。父亲是泰温，母亲是乔安娜，两只狮子血脉的孩子发色应该是纯正的金色（参考瑟曦与詹姆）但这里描写提利昂发色金的发白就很微妙了。</p><h2 id="证据2-病态地迷恋龙"><a href="#证据2-病态地迷恋龙" class="headerlink" title="证据2 病态地迷恋龙"></a>证据2 病态地迷恋龙</h2><p>提利昂从小便对龙很痴迷，在他的命名仪式上，他的叔叔吉利安问他：想要什么东西？幼小的半人说，他想要一条未成年的龙。众人听罢纷纷讪笑，因为最后的龙已经死了一个多世纪——再也没有龙了。甚少哭泣的提利昂知道后，哭了很久。</p><p>他熟读《龙、蜥龙和长翼龙：龙族的非自然演化史》、《血龙狂舞真史》等各类有关于龙的书籍。他也因此掌握了许多有关魔龙的知识，例如什么龙骨含铁量极高啊、龙口散播死亡啊、龙的唯一弱点是眼睛blabla，都是马丁老爷子借他的口告诉我们的。</p><p>很久以后，提利昂告诉雪诺，他小时候曾经非常认真地想要一条幼龙。雪诺表示难以置信，毕竟这种违反常识的愿望，跟现实睿智的半人联系不到一起。但提利昂却说：</p><p>「<strong><em>……只要能骑在龙背上，即便是发育不良，畸形扭曲的丑陋小男孩也可以睥睨全世界。”提利昂推开熊皮，站起身来。“以前我常躲在凯岩城深处的地道，燃起火堆，望着熊熊烈焰，一望就是好几个钟头，一边幻想那是魔龙吐出的烈火。有时候我会幻想我老爸被火烧死，有时候则是我老姐。</em></strong>」</p><p>剧中也有提利昂与龙亲密接触龙对他显示亲昵姿态的场面    </p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/龙提.png" alt></p><p>从这里可以看出提利昂应该是有龙血才能和龙有比较亲密的关系。</p><h2 id="证据3-龙的三首与出生害死母亲"><a href="#证据3-龙的三首与出生害死母亲" class="headerlink" title="证据3 龙的三首与出生害死母亲"></a>证据3 龙的三首与出生害死母亲</h2><p>这个证据我个人是很推崇的，因为这样的话文章会对仗工整顺畅。</p><p>首先说回龙家的族徽:黑底红色三头龙，龙有三个头，这并不是说一条龙长着三个头，而是指三这个数字与龙家割舍不了的关系。</p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/坦格利安族徽.png" alt></p><p>三百多年前，伊耿·坦格利安与他的一个姐姐和一个妹妹，三个人分别骑着三头巨龙，征服了整个维斯特洛大陆，开启了坦格利安王朝。如今，丹妮莉丝带着三条龙再次杀回，龙有了，人呢？如今，我们知道了琼恩·雪诺也是龙家人（书里还是没实锤不过要是囧都不是龙家我就弃坑了）。只剩下最后一个名额，而纵观全局，剩下的那个巨头，就是提利昂。</p><p>并且龙妈、囧、提利昂这三人还有一个巧合就是诞生时害死了母亲， 囧、龙妈和小恶魔都是出生时母亲去世，也能从某种程度上构成巧合。</p><h2 id="证据4-疯王痴迷乔安娜"><a href="#证据4-疯王痴迷乔安娜" class="headerlink" title="证据4 疯王痴迷乔安娜"></a>证据4 疯王痴迷乔安娜</h2><p>疯王对泰温的老婆乔安娜的迷恋有很多的描写。伊里斯在泰温结婚时闹洞房十分积极，有学士隐晦地记载，伊里斯<strong>“获得了过分的自由”</strong>，伊里斯甚至表示<strong>要是初夜权没废除就好了</strong>，可以说下流猥琐至极。</p><p>在泰温当国王之手初期，乔安娜也是随自己丈夫住在君临的，但没多久就被当时的雷拉王后赶回凯岩城，这俩人可是好闺蜜。这之后，乔安娜在凯岩城生下了金色双胞胎。伊里斯听说了乔安娜的生产后曾说<strong>“我娶了错误的女人。”</strong>他派人送去礼金，要求泰温在双胞胎长大后把他们带来君临，并要求乔安娜同往，因为他“太久没瞧见那张俏丽的脸了”。</p><p>272AC，伊里斯加冕十年庆典的比武大会上，乔安娜带着两个孩子拜见了伊里斯，醉酒的伊里斯问乔安娜给孩子们喂奶是不是“毁了你那对儿坚挺又骄傲的奶子”。这句话让乔安娜遭到了极大羞辱。273AC，乔安娜在凯岩城生下提利昂并难产而死。</p><p>值得一提的是如果确实是疯王侮辱了乔安娜并生下小恶魔，那么疯王侮辱乔安娜就是发生在272AC比武大会的这段时间中。</p><h1 id="观点2：小恶魔不是龙家的"><a href="#观点2：小恶魔不是龙家的" class="headerlink" title="观点2：小恶魔不是龙家的"></a>观点2：小恶魔不是龙家的</h1><h2 id="证据1-泰温太骄傲了，不可能吃别人的残羹剩饭"><a href="#证据1-泰温太骄傲了，不可能吃别人的残羹剩饭" class="headerlink" title="证据1 泰温太骄傲了，不可能吃别人的残羹剩饭"></a>证据1 泰温太骄傲了，不可能吃别人的残羹剩饭</h2><p>泰温对乔安娜的爱可以从书中很多细节中看出，据说他们结婚当日泰温露出了笑容，对于泰温来说这是极其少见的情绪外露。各方面的线索都显示他们的婚姻非常幸福，乔安娜深受泰温的信任，不止作为他的妻子，还是他的参谋和朋友。许多人都知道一句俗语描述她对丈夫的影响“泰温大人统治七国”（作为国王之手）但是“乔安娜夫人统治着泰温大人。并且乔安娜死后，泰温再也没有笑过（也受他父亲，笑狮泰陀斯的影响）。</p><p>这样一个人物，如此爱自己的妻子，更不可能容许自己的妻子被玷污的。有谣言称乔安娜的初夜在杰赫里斯加冕的当晚就给了伊里斯，并且在伊里斯称王之后还当过一段疯王的情妇。这种说法被派席尔国师否定。在他的信中，他声称“骄傲的泰温伯爵绝不可能吃别人的残羹剩饭”。</p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/乔安娜.png" alt></p><h2 id="证据2-泰温对伊里斯挑衅的反应"><a href="#证据2-泰温对伊里斯挑衅的反应" class="headerlink" title="证据2 泰温对伊里斯挑衅的反应"></a>证据2 泰温对伊里斯挑衅的反应</h2><p>疯王和泰温在年轻时（疯王未疯时）是挚友，也因此疯王力排众议将当时尚且年轻的泰温扶上国王之手的位置。但是随着时间的推移，疯王对泰温的感情逐渐转为了嫉妒。也因此支持提利昂非龙的人们认为疯王对乔安娜的轻浮言论只是为了挑衅和激怒泰温。</p><p>除次之外更要提的是，疯王三番五次出言挑逗乔安娜泰温都能忍下来，如果疯王真的与乔安娜有染泰温不可能再给他继续兢兢业业地做国王之手（龙血党认为这只是因为疯王与乔安娜有染这一事未被泰温知晓）。让泰温卸下国王之手位置的居然是疯王给詹姆披上白袍（削去了詹姆继承权，迫使泰温传凯岩城给小恶魔），这对骄傲的泰温来说是很不合理的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 冰火 </tag>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAB学习笔记</title>
      <link href="2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/sample.png" alt="新建" style="zoom:=40%;"></p><p>​    <strong>M</strong>ulti <strong>A</strong>rmed <strong>B</strong>andit(<strong>MAB</strong>) is a simple but very powerful framework for algorithms that make decisions over time under uncertainty. An enormous body of work has accumulated over the years.</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    </p><p>​    与多臂老虎机相类似的问题还有餐馆选择问题，当我们到达一个新地方不久，是每次去我们熟悉的最好吃的餐馆还是去探索新餐馆找可能更好吃的菜品。</p><p>下面是摘自wiki的一段描述:</p><p>​    In probability theory, the multi-armed bandit problem (sometimes called the K-or N-armed bandit problem) is a problem in which a fixed limited set of resources must be allocated between competing (alternative) choices in a way that maximizes their expected gain, when each choice’s properties are only partially known at the time of allocation, and may become better understood as time passes or by allocating resources to the choice.</p><p>​    通俗点讲,当我们在玩老虎机时，老虎机有多个摇臂可供选择，每个摇臂对应的收益分布是固定但未知的，玩家需要在有限次的次数下做出最合适的选择。那么极端地想，我们每次摇臂就有两种倾向：</p><ul><li>尝试新的“老虎臂”，也许会得到比之前更好的结果(Explore)</li></ul><ul><li>利用已知的老虎臂做最好的选择(Exploit)</li></ul><p>下面介绍一些基本的算法</p><h1 id="1-Unioform-Exploration"><a href="#1-Unioform-Exploration" class="headerlink" title="1. Unioform Exploration"></a>1. Unioform Exploration</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>​    这个均匀探索算法的思想很简单，是一个 <em>Explore-first</em> 的算法。首先确定好Exploration Phase 和 Exploitation Phase的大小，然后在Exploration Phase中均匀地探索每个摇臂，用期望来描述这个摇臂对应的收益，之后在Exploitation Phase中根据之前的最大收益选择进行游戏。</p><p>​    大体流程如下:</p><ol><li>Exploration Phase: try  each arm N times</li><li>Select the arm $\hat{\alpha}$ with the highest reward </li><li>Explotiation Phase: play arm $\hat{\alpha}$  in all remaining rounds</li></ol><h2 id="Regret-analysis"><a href="#Regret-analysis" class="headerlink" title="Regret analysis"></a>Regret analysis</h2><p>​    在进行exploit的时候我们会用之前explore得到的收益的平均值$\bar{\mu}(\alpha)$ 作为对真实期望$\mu(\alpha)$的估计，如果想要最后分析得到的结果准确我们应使这两个结果之间的差值尽量小，我们这里使用Hoeffding inequality对其进行分析。</p><p>​    By defining the confidence radius $r(\alpha) = \sqrt{\frac{2logT}{N}}$ , using  Hoeffding inequality, we get :</p><script type="math/tex; mode=display">\operatorname{Pr}\{|\bar{\mu}(a)-\mu(a)| \leq r(a)\} \geq 1-\frac{2}{T^{4}}</script><p>​    我们定义$\bar{\mu}(\alpha)$ 在这个范围内为 <strong>clean event</strong>, 反之为 <strong>bad event</strong>.可以看到bad event的order 为 $T^{-4}$可以忽略不计，在后面的推导证明中，可以姑且不考虑bad event的影响。</p><p>​    后面的证明推导将采用英文QAQ。</p><p>​    For simplicity, let us start with the case of K = 2 arms. Consider the clean event. We will show that if we chose the worse arm, it is not so bad because the expected rewards for the two arms would be close.</p><p>​    Let the best arm be $\alpha^{✳️}$ and suppose the algorithm chooses the other arm $a \neq a^{✳️} .$ This must have been because its average reward was better than that of $a^{✳️} ;$ in other words, $\bar{\mu}(a)&gt;\bar{\mu}\left(a^{✳️}\right) .$ Since this is a clean event, we have:</p><script type="math/tex; mode=display">\mu(a)+r(a) \geq \bar{\mu}(a)>\bar{\mu}\left(a^{*}\right) \geq \mu\left(a^{*}\right)-r\left(a^{*}\right)</script><p>​    Re-arranging the terms, it follows that</p><script type="math/tex; mode=display">\mu\left(a^{*}\right)-\mu(a) \leq r(a)+r\left(a^{*}\right)=O\left(\sqrt{\frac{\log T}{N}}\right)</script><p>​    Thus, each round in the exploitation phase contributes at most $O\left(\sqrt{\frac{\log T}{N}}\right)$ to regret. And each round in exploration trivially contributes at most $1 .$ We derive an upper bound on the regret, which consists of two parts: for the first N rounds of exploration, and then for the remaining T - 2N rounds of exploitation:</p><p>​    Recall that we can select any value for $N,$ as long as it is known to the algorithm before the first round. So, we can choose $N$ so as to (approximately) minimize the right-hand side. Noting that the two summands are, resp., monotonically increasing and monotonically decreasing in $N,$ <strong>we set $N$ so that they are (approximately) equal</strong>. For $N=T^{2 / 3}(\log T)^{1 / 3},$ we obtain:</p><script type="math/tex; mode=display">R(T) \leq O\left(T^{2 / 3}(\log T)^{1 / 3}\right)</script><p>​    To complete the proof, we have to analyze the case of the “bad event”. Since regret can be at most T (because each round contributes at most 1), and the bad event happens with a very small probability (1/T 4), the (expected) regret from this case can be neglected. Formally,</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[R(T)] &=\mathbb{E}[R(T) \mid \text { clean event }] \times \operatorname{Pr}[\text { clean event }]+\mathbb{E}[R(T) \mid \text { bad event }] \times \operatorname{Pr}[\text { bad event }] \\& \leq \mathbb{E}[R(T) \mid \text { clean event }]+T \times O\left(T^{-4}\right) \\& \leq O\left(\sqrt{\log T} \times T^{2 / 3}\right)\end{aligned}</script><p>​    This complete the proff of K=2 arms.</p><p>​    For $K&gt;2$ arms, we have to apply the union bound for (1) over the $K$ arms, and then follow the same argument as above. Note that the value of $T$ is greater than $K,$ since we need to explore each arm at least once. For the final regret computation, we will need to take into account the dependence on $K$ :<br>specifically, regret accumulated in exploration phase is now upper-bounded by $K N .$ Working through the proof, we obtain $R(T) \leq N K+O\left(\sqrt{\frac{\log T}{N}} \times T\right) .$ As before, we approximately minimize it by approximately minimizing the two summands. Specifically, we plug in $N=(T / K)^{2 / 3} \cdot O(\log T)^{1 / 3} .$ Completing the proof same way as in $(5)$ we obtain:</p><p><strong><em>Explore First Algortihm achieves regret:</em></strong>$\mathbb{E}[R(T)] \leq T^{2 / 3} \times O(K \log T)^{1 / 3}$</p><h1 id="2-Adaptive-Exploration"><a href="#2-Adaptive-Exploration" class="headerlink" title="2 Adaptive Exploration"></a>2 Adaptive Exploration</h1><p>​    Both exploration-first and epsilon-greedy have a big flaw that the exploration schedule does not depend on the history of the observed rewards. Whereas it is usually better to adapt exploration to the observed rewards. Informally, we refer to this distinction as adaptive vs non-adaptive exploration. In the remainder of this article we present two algorithms that implement adaptive exploration and achieve better regret. </p><p>​    Let’s start with the case of $K=2$ arms. One natural idea is to alternate them until we find that one armi s much better than the other, at which time we abandon the inferior one. But how to define “one arm is much better” exactly?</p><h2 id="Clean-evnt-and-confidence-bounds"><a href="#Clean-evnt-and-confidence-bounds" class="headerlink" title="Clean evnt and confidence bounds"></a>Clean evnt and confidence bounds</h2><p>​    Let us flesh out the idea mentioned above; this would also set up the stage for some other algorithms. Fix round $t .$ Let $n<em>{t}(a)$ be the number of samples from $\operatorname{arm} a$ in round $1,2, \ldots, t . \bar{\mu}</em>{t}(a)$ be the average reward of arm $a$ so far. We would like to use Hoeffding Inequality to derive</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下搭建hexo个人博客并部署到github</title>
      <link href="2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
      <url>2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要内容：</p><ul><li><p>github注册与创建仓库</p></li><li><p>安装git、nodejs、hexo</p></li><li><p>初始化+创建hexo博客</p></li><li><p>部署到github上+自动化 </p></li><li><p>绑定域名、更换主题、设置评论区…（//TODO）</p> <a id="more"></a>     </li></ul><h3>  1.前言</h3>​    河北疫情导致圣诞与春节间的小假期无法返校，在家上网课而且空余时间没法打发，于是想着扩充下自己的技能树。再加上很久之前就有弄一个自己的博客的想法所以开始着手上网找教程了。不想自己花钱买服务器所以决定用github几番对比之后决定使用hexo。​    网上的教程有些或多或少的bug。。。导致自己琢磨一些很弱智的问题浪费了很多时间我把自己参考多份方案后的内容总结下来做参考。<h3>2. github注册与创建仓库</h3><ul><li>在<a href="https://github.com/">github</a> 官网注册账号，可能需要🚀</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/join.png" alt="新建" style="zoom:30%;"></p><ul><li>新建一个仓库</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/create1.png" alt="新建" style="zoom:30%;"></p><p>注意仓库的名字必须是 (username/ +) <strong>usrname.github.io</strong> (由于我之前注册过这个名字的仓库，所以github这里提示我名字重复)</p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/create2.png" alt="新建" style="zoom:30%;"></p><h3>  3.安装nodejs、git、hexo</h3><ul><li><a href="https://nodejs.org/en/">node.js</a>下载后安装</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/nodejs.png" alt="新建" style="zoom:50%;"></p><p>终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v <span class="comment">#是否出现安装版本信息，出现说明已经安装了</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://git-scm.com/downloads">Git下载</a>后安装</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/git.png" alt="新建" style="zoom:50%;"></p><p>终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version <span class="comment">#是否出现安装版本信息，出现说明已经安装了</span></span><br></pre></td></tr></table></figure><ul><li>Hexo下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装成功后在你想要存储博客项目的位置创建你的文件夹，我这里将路径设为“PATH/blog”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在你的家目录下创建一个blog文件夹</span></span><br><span class="line">mkdir PATH/blog</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> PATH/blog</span><br><span class="line"><span class="comment"># 初始化目录</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment">#安装必备组件</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 开启本地服务 </span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时打开<a href="http://localhost:4000/">http://localhost:4000/</a> 就可以看到运行在本地的hexo页面</p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/hello_world.png" alt="新建" style="zoom:50%;"></p><h3>  4. 部署到github</h3><ul><li><p>将博客关联到之前创建的github仓库上去，打开/blog文件夹下的“_config.yml”文件，这个文件存储的是博客的配置内容。</p></li><li><p>打开这个文件后在最下找到配置相关的部分将deploy的内容替换为(注意将我repository中的用户名替换为自己的用户名)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;windskyshaoyu&#x2F;windskyshaoyu.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>！ 注意这里有一个神坑，大部分教程最后branch给的是“master”因为github创建仓库时的默认分支是master。但受自由美利坚种族冲突的影响，自2020.10.1起，github取消“master”这一可能带有种族歧视的词汇，默认分支更名为main。所以在部署时应部署到main分支上，也可以在设置中设置其他分支为显示页面可自行摸索。</p></li></ul><p>终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除之前的记录</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># g for generate 编译</span></span><br><span class="line">hexo g </span><br><span class="line"></span><br><span class="line"><span class="comment">#d for deploy 部署到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时若运行正常网速正常的情况下，便可以在<a href="https://your_user_name.github.io/下看到自己的博客主页。">https://your_user_name.github.io/下看到自己的博客主页。</a></p><ul><li>每次输入账号密码过于繁琐——关联Github账号，免密提交。</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用你注册GitHub时的邮箱号，进行秘钥生成</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxxxx@gmail.com&quot;</span></span><br><span class="line"><span class="comment"># 系统就会生成一个隐藏文件夹.ssh</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 应该能看到id_rsa.pub文件</span></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制其中全部内容</span></span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><p>  打开设置 —&gt; 选择SSH and GPG keys  —&gt; 新建一个ssh key将密钥复制进去，title可以随便填写</p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh1.png" alt="新建" style="zoom:30%;"></p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh2.png" alt="新建" style="zoom:30%;"></p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh3.png" alt="新建" style="zoom:25%;"></p><h3>  5. //TODO</h3><p>关于更换主题，设置评论区等内容我也花了不小的精力探索，主要是评论区的运营商更新比较频繁。。。之前的教程与现在的版本间隔过远需要自己摸索，日后有时间将其整理出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="2021/01/17/My-New-Post/"/>
      <url>2021/01/17/My-New-Post/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
