<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021春晚</title>
    <url>/2021/04/21/2021%E6%98%A5%E6%99%9A/</url>
    <content><![CDATA[<p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/logo.png" style="zoom:30%;"></p>
<center>你的下一片a14何必是a14</center>

<a id="more"></a>
<p>没有全程跟着发布会看，但发布会结束的时候还没睡，所以算是第一时间知道了发布会的消息，当天晚上在论坛逛到三点半讨论新的ipad pro ，不得不说cook牛逼。</p>
<p>一个个来吧。</p>
<h1 id="AirTag"><a href="#AirTag" class="headerlink" title="AirTag"></a>AirTag</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/airtag.png" style="zoom:30%;"></p>
<p>没啥好说的，有钱可以玩玩。</p>
<p>目前看了一些评测，远距离就像是个查找我的iphone一样不够灵敏。10m之内才能使用最新的UWB技术精准制导。</p>
<p>以前想的给猫猫狗狗带一个来防走失看来也不是那么可行。</p>
<p>只能说一个蜂鸣器+蓝牙+UWB不值这个价格，logo值👍。</p>
<h1 id="iMac"><a href="#iMac" class="headerlink" title="iMac"></a>iMac</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/imac.png" style="zoom:50%;"></p>
<p>苹果还是放不下🌈的，更令人眼前一亮的是妙控三件套的新配色。鼠标、键盘和触控板的那个薄荷绿色看起来很舒服。不过至于imac的话其实个人感觉新配色有些张扬，这个苹果设计还是太空灰的性冷淡风更对味道。</p>
<p>看到论坛上很多hackintosh的老哥们很欣喜因为新版的妙控键盘支持指纹解锁，这大概是指纹解锁首次下放黑果群体。</p>
<p>配置上升级为m1,屏幕统一变为24寸5k，前置摄像头由万年不变的720升级成了1080，发布会上还重点宣传了音频系统的提升。</p>
<p>接口方面，2个雷电4+两个普通type c，新版更新了磁力充电口，并且网线可以插在电源适配器上（虽然不知道为什么突兀加了这么个设计）。看到演示会演示充电方式的时候我第一反应是：</p>
<p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/胖虎.jpg" style="zoom:50%;"></p>
<p>不得不吐槽这个充电线的外观缺了点苹果的elegant味。</p>
<p>总的来说可以定义为一款桌面端的MacBook air吧，下次回家给家里爸妈整一台，他们不需要游戏性能，能看个剧、处理下简单的办公就够用，也看着很漂亮，完美。</p>
<h1 id="新配色iphone"><a href="#新配色iphone" class="headerlink" title="新配色iphone"></a>新配色iphone</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/iphone.jpg" style="zoom:50%;"></p>
<p>好看，买。</p>
<p>🌈+紫，cook的心意够明显了。</p>
<h1 id="革命者"><a href="#革命者" class="headerlink" title="革命者"></a>革命者</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/ipad.png" style="zoom:20%;"></p>
<p>以下内容是我主观想法，如果日后发现我的观点是错的，那我就回来改，所以我大概率永远是对的😊。</p>
<p>先谈性能，很多人在吹M1多牛逼，ipad背刺air云云。。但就我手里的这款ipad pro 2018而言，在2018年他发售之时就开始有这样的论调了。A12X或是A12Z都远远不是ipad与笔记本竞争的关键，系统才是。</p>
<p>ipad pro这么香都不耽误mba出货无非就是生态。我买个mba，软件生态齐活了。但我买个ipad，不配键鼠套装就是一纯爱奇艺浏览器，顶天写个笔记看个课件，办公就别想了。</p>
<p>那么如果我配键鼠呢？一代键鼠的价格和使用体验太拉了，罗技等厂家的二创比他高到不知哪里，二代键鼠体验要好上不少。但依然无法摆脱一个问题，笔记本10分钟做完的ppt，我在ipad上要做半个小时。笔记本上剪个视频、修个图各种快捷键素材库云云都很完善，而ipad根本没有跟上。</p>
<p>那我为什么说这款ipad pro是个革命者呢？</p>
<p>apple下场做芯片了，Intel命数已尽。这样一个牙膏厂能霸占市场这么久真是天下苦intel久矣。m1芯片的大规模量产铺货乃至推广到ipad pro上基本宣告apple自研芯片的成熟。而且以苹果更新迭代的速度，年年都是宣传性能40、50%这样子往上飞跃，intel哪里见过这阵仗，到现在都守着14nm老本。Apple yes! </p>
<p>之前看到过一句话，<strong>一个行业的改革多由其他行业的佼佼者入场而引发</strong>。</p>
<p>说回pad本身，基本宣告安卓系pad的出局，这价格，这品质，这logo（笑。其他厂商没得打，能击败这代ipad pro的只有可能是下一代ipad pro。</p>
<p>手持ipad pro2018也在考虑是否更换iPad pro2021，主要看头在WWDC上，我个人感觉ipad OS应该有大动作，不然没有理由不上A14X、A14Z而上M1，此前我一直以为M1 的M是for Mac的意思。</p>
<p>如果ipad os能有合适的作为，整个操作系统又是一次大洗牌。开发者一份工挣ipad群体和mac群体两份钱，这势必会带动mac os软件生态改善，又接着带来更多用户加入mac os生态，一个良性组合拳打的漂亮。</p>
<p>当然一切都是颅内臆想出来的，ipad os怎么向mac os融合是个麻烦，这两套设备硬件上的差别太大了，如何设计交互是个大问题，但这是苹果，值得一个期待。</p>
]]></content>
      <tags>
        <tag>科技</tag>
      </tags>
  </entry>
  <entry>
    <title>MAB学习笔记</title>
    <url>/2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="/2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/sample.png" alt="新建" style="zoom:=40%;"></p>
<p>​    <strong>M</strong>ulti <strong>A</strong>rmed <strong>B</strong>andit(<strong>MAB</strong>) is a simple but very powerful framework for algorithms that make decisions over time under uncertainty. An enormous body of work has accumulated over the years.</p>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    </p>
<p>​    与多臂老虎机相类似的问题还有餐馆选择问题，当我们到达一个新地方不久，是每次去我们熟悉的最好吃的餐馆还是去探索新餐馆找可能更好吃的菜品。</p>
<p>下面是摘自wiki的一段描述:</p>
<p>​    In probability theory, the multi-armed bandit problem (sometimes called the K-or N-armed bandit problem) is a problem in which a fixed limited set of resources must be allocated between competing (alternative) choices in a way that maximizes their expected gain, when each choice’s properties are only partially known at the time of allocation, and may become better understood as time passes or by allocating resources to the choice.</p>
<p>​    通俗点讲,当我们在玩老虎机时，老虎机有多个摇臂可供选择，每个摇臂对应的收益分布是固定但未知的，玩家需要在有限次的次数下做出最合适的选择。那么极端地想，我们每次摇臂就有两种倾向：</p>
<ul>
<li>尝试新的“老虎臂”，也许会得到比之前更好的结果(Explore)</li>
</ul>
<ul>
<li>利用已知的老虎臂做最好的选择(Exploit)</li>
</ul>
<p>下面介绍一些基本的算法</p>
<h1 id="1-Unioform-Exploration"><a href="#1-Unioform-Exploration" class="headerlink" title="1. Unioform Exploration"></a>1. Unioform Exploration</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>​    这个均匀探索算法的思想很简单，是一个 <em>Explore-first</em> 的算法。首先确定好Exploration Phase 和 Exploitation Phase的大小，然后在Exploration Phase中均匀地探索每个摇臂，用期望来描述这个摇臂对应的收益，之后在Exploitation Phase中根据之前的最大收益选择进行游戏。</p>
<p>​    大体流程如下:</p>
<ol>
<li>Exploration Phase: try  each arm N times</li>
<li>Select the arm $\hat{\alpha}$ with the highest reward </li>
<li>Explotiation Phase: play arm $\hat{\alpha}$  in all remaining rounds</li>
</ol>
<h2 id="Regret-analysis"><a href="#Regret-analysis" class="headerlink" title="Regret analysis"></a>Regret analysis</h2><p>​    在进行exploit的时候我们会用之前explore得到的收益的平均值$\bar{\mu}(\alpha)$ 作为对真实期望$\mu(\alpha)$的估计，如果想要最后分析得到的结果准确我们应使这两个结果之间的差值尽量小，我们这里使用Hoeffding inequality对其进行分析。</p>
<p>​    By defining the confidence radius $r(\alpha) = \sqrt{\frac{2logT}{N}}$ , using  Hoeffding inequality, we get :</p>
<script type="math/tex; mode=display">
\operatorname{Pr}\{|\bar{\mu}(a)-\mu(a)| \leq r(a)\} \geq 1-\frac{2}{T^{4}}</script><p>​    我们定义$\bar{\mu}(\alpha)$ 在这个范围内为 <strong>clean event</strong>, 反之为 <strong>bad event</strong>.可以看到bad event的order 为 $T^{-4}$可以忽略不计，在后面的推导证明中，可以姑且不考虑bad event的影响。</p>
<p>​    后面的证明推导将采用英文QAQ。</p>
<p>​    For simplicity, let us start with the case of K = 2 arms. Consider the clean event. We will show that if we chose the worse arm, it is not so bad because the expected rewards for the two arms would be close.</p>
<p>​    Let the best arm be $\alpha^{✳️}$ and suppose the algorithm chooses the other arm $a \neq a^{✳️} .$ This must have been because its average reward was better than that of $a^{✳️} ;$ in other words, $\bar{\mu}(a)&gt;\bar{\mu}\left(a^{✳️}\right) .$ Since this is a clean event, we have:</p>
<script type="math/tex; mode=display">
\mu(a)+r(a) \geq \bar{\mu}(a)>\bar{\mu}\left(a^{*}\right) \geq \mu\left(a^{*}\right)-r\left(a^{*}\right)</script><p>​    Re-arranging the terms, it follows that</p>
<script type="math/tex; mode=display">
\mu\left(a^{*}\right)-\mu(a) \leq r(a)+r\left(a^{*}\right)=O\left(\sqrt{\frac{\log T}{N}}\right)</script><p>​    Thus, each round in the exploitation phase contributes at most $O\left(\sqrt{\frac{\log T}{N}}\right)$ to regret. And each round in exploration trivially contributes at most $1 .$ We derive an upper bound on the regret, which consists of two parts: for the first N rounds of exploration, and then for the remaining T - 2N rounds of exploitation:</p>
<p>​    Recall that we can select any value for $N,$ as long as it is known to the algorithm before the first round. So, we can choose $N$ so as to (approximately) minimize the right-hand side. Noting that the two summands are, resp., monotonically increasing and monotonically decreasing in $N,$ <strong>we set $N$ so that they are (approximately) equal</strong>. For $N=T^{2 / 3}(\log T)^{1 / 3},$ we obtain:</p>
<script type="math/tex; mode=display">
R(T) \leq O\left(T^{2 / 3}(\log T)^{1 / 3}\right)</script><p>​    To complete the proof, we have to analyze the case of the “bad event”. Since regret can be at most T (because each round contributes at most 1), and the bad event happens with a very small probability (1/T 4), the (expected) regret from this case can be neglected. Formally,</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathbb{E}[R(T)] &=\mathbb{E}[R(T) \mid \text { clean event }] \times \operatorname{Pr}[\text { clean event }]+\mathbb{E}[R(T) \mid \text { bad event }] \times \operatorname{Pr}[\text { bad event }] \\
& \leq \mathbb{E}[R(T) \mid \text { clean event }]+T \times O\left(T^{-4}\right) \\
& \leq O\left(\sqrt{\log T} \times T^{2 / 3}\right)
\end{aligned}</script><p>​    This complete the proff of K=2 arms.</p>
<p>​    For $K&gt;2$ arms, we have to apply the union bound for (1) over the $K$ arms, and then follow the same argument as above. Note that the value of $T$ is greater than $K,$ since we need to explore each arm at least once. For the final regret computation, we will need to take into account the dependence on $K$ :<br>specifically, regret accumulated in exploration phase is now upper-bounded by $K N .$ Working through the proof, we obtain $R(T) \leq N K+O\left(\sqrt{\frac{\log T}{N}} \times T\right) .$ As before, we approximately minimize it by approximately minimizing the two summands. Specifically, we plug in $N=(T / K)^{2 / 3} \cdot O(\log T)^{1 / 3} .$ Completing the proof same way as in $(5)$ we obtain:</p>
<p><strong><em>Explore First Algortihm achieves regret:</em></strong>$\mathbb{E}[R(T)] \leq T^{2 / 3} \times O(K \log T)^{1 / 3}$</p>
<h1 id="2-Adaptive-Exploration"><a href="#2-Adaptive-Exploration" class="headerlink" title="2 Adaptive Exploration"></a>2 Adaptive Exploration</h1><p>​    Both exploration-first and epsilon-greedy have a big flaw that the exploration schedule does not depend on the history of the observed rewards. Whereas it is usually better to adapt exploration to the observed rewards. Informally, we refer to this distinction as adaptive vs non-adaptive exploration. In the remainder of this article we present two algorithms that implement adaptive exploration and achieve better regret. </p>
<p>​    Let’s start with the case of $K=2$ arms. One natural idea is to alternate them until we find that one armi s much better than the other, at which time we abandon the inferior one. But how to define “one arm is much better” exactly?</p>
<h2 id="Clean-evnt-and-confidence-bounds"><a href="#Clean-evnt-and-confidence-bounds" class="headerlink" title="Clean evnt and confidence bounds"></a>Clean evnt and confidence bounds</h2><p>​    Let us flesh out the idea mentioned above; this would also set up the stage for some other algorithms. Fix round $t .$ Let $n<em>{t}(a)$ be the number of samples from $\operatorname{arm} a$ in round $1,2, \ldots, t . \bar{\mu}</em>{t}(a)$ be the average reward of arm $a$ so far. We would like to use Hoeffding Inequality to derive</p>
]]></content>
      <tags>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title>My New Post</title>
    <url>/2021/01/17/My-New-Post/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Thompson Sampling笔记</title>
    <url>/2021/01/30/Thompson%20Sampling%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>学术</tag>
      </tags>
  </entry>
  <entry>
    <title>mac下搭建hexo个人博客并部署到github</title>
    <url>/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    <content><![CDATA[<p>主要内容：</p>
<ul>
<li><p>github注册与创建仓库</p>
</li>
<li><p>安装git、nodejs、hexo</p>
</li>
<li><p>初始化+创建hexo博客</p>
</li>
<li><p>部署到github上+自动化 </p>
</li>
<li><p>绑定域名、更换主题、设置评论区…（//TODO）</p>
 <a id="more"></a>     
</li>
</ul>
<h3>
  1.前言
</h3>
​    河北疫情导致圣诞与春节间的小假期无法返校，在家上网课而且空余时间没法打发，于是想着扩充下自己的技能树。再加上很久之前就有弄一个自己的博客的想法所以开始着手上网找教程了。不想自己花钱买服务器所以决定用github几番对比之后决定使用hexo。

​    网上的教程有些或多或少的bug。。。导致自己琢磨一些很弱智的问题浪费了很多时间我把自己参考多份方案后的内容总结下来做参考。





<h3>
2. github注册与创建仓库
</h3>




<ul>
<li>在<a href="https://github.com/">github</a> 官网注册账号，可能需要🚀</li>
</ul>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/join.png" alt="新建" style="zoom:30%;"></p>
<ul>
<li>新建一个仓库</li>
</ul>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/create1.png" alt="新建" style="zoom:30%;"></p>
<p>注意仓库的名字必须是 (username/ +) <strong>usrname.github.io</strong> (由于我之前注册过这个名字的仓库，所以github这里提示我名字重复)</p>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/create2.png" alt="新建" style="zoom:30%;"></p>
<h3>
  3.安装nodejs、git、hexo
</h3>

<ul>
<li><a href="https://nodejs.org/en/">node.js</a>下载后安装</li>
</ul>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/nodejs.png" alt="新建" style="zoom:50%;"></p>
<p>终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ node -v <span class="comment">#是否出现安装版本信息，出现说明已经安装了</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://git-scm.com/downloads">Git下载</a>后安装</li>
</ul>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/git.png" alt="新建" style="zoom:50%;"></p>
<p>终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git --version <span class="comment">#是否出现安装版本信息，出现说明已经安装了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Hexo下载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装成功后在你想要存储博客项目的位置创建你的文件夹，我这里将路径设为“PATH/blog”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在你的家目录下创建一个blog文件夹</span></span><br><span class="line">mkdir PATH/blog</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> PATH/blog</span><br><span class="line"><span class="comment"># 初始化目录</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment">#安装必备组件</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 开启本地服务 </span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>此时打开<a href="http://localhost:4000/">http://localhost:4000/</a> 就可以看到运行在本地的hexo页面</p>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/hello_world.png" alt="新建" style="zoom:50%;"></p>
<h3>
  4. 部署到github
</h3>

<ul>
<li><p>将博客关联到之前创建的github仓库上去，打开/blog文件夹下的“_config.yml”文件，这个文件存储的是博客的配置内容。</p>
</li>
<li><p>打开这个文件后在最下找到配置相关的部分将deploy的内容替换为(注意将我repository中的用户名替换为自己的用户名)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;windskyshaoyu&#x2F;windskyshaoyu.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>！ 注意这里有一个神坑，大部分教程最后branch给的是“master”因为github创建仓库时的默认分支是master。但受自由美利坚种族冲突的影响，自2020.10.1起，github取消“master”这一可能带有种族歧视的词汇，默认分支更名为main。所以在部署时应部署到main分支上，也可以在设置中设置其他分支为显示页面可自行摸索。</p>
</li>
</ul>
<p>终端输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除之前的记录</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># g for generate 编译</span></span><br><span class="line">hexo g </span><br><span class="line"></span><br><span class="line"><span class="comment">#d for deploy 部署到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>此时若运行正常网速正常的情况下，便可以在<a href="https://your_user_name.github.io/下看到自己的博客主页。">https://your_user_name.github.io/下看到自己的博客主页。</a></p>
<ul>
<li>每次输入账号密码过于繁琐——关联Github账号，免密提交。</li>
</ul>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用你注册GitHub时的邮箱号，进行秘钥生成</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxxxx@gmail.com&quot;</span></span><br><span class="line"><span class="comment"># 系统就会生成一个隐藏文件夹.ssh</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 应该能看到id_rsa.pub文件</span></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制其中全部内容</span></span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>  打开设置 —&gt; 选择SSH and GPG keys  —&gt; 新建一个ssh key将密钥复制进去，title可以随便填写</p>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh1.png" alt="新建" style="zoom:30%;"></p>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh2.png" alt="新建" style="zoom:30%;"></p>
<p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh3.png" alt="新建" style="zoom:25%;"></p>
<h3>
  5. //TODO
</h3>

<p>关于更换主题，设置评论区等内容我也花了不小的精力探索，主要是评论区的运营商更新比较频繁。。。之前的教程与现在的版本间隔过远需要自己摸索，日后有时间将其整理出来。</p>
]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>只狼-影逝二度</title>
    <url>/2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/</url>
    <content><![CDATA[<p><img src="/2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/index.jpeg" style="zoom:33%;"></p>
<center> 有死之荣，无生之辱</center>

<p>只狼打通了回来补一个通关感受，这个游戏是我目前为止游玩时间最长的单机游戏，也是我第一个肝到全成就的游戏。跟舍友一起打的剑圣，犹记得剑圣跪地时舍友的欢呼和我把手柄一甩的仰天长啸。</p>
<p>宫崎英高，yyds。</p>
<a id="more"></a>
<p>这里只想谈谈对整个游戏的感受，至于打法攻略很多up都有做总结， 推荐<a href="https://www.bilibili.com/video/BV1Nb41177ja?from=search&amp;seid=3555517953000752865">老戴</a>的只狼攻略视频，手残友好。</p>
<h1 id="故事主线"><a href="#故事主线" class="headerlink" title="故事主线"></a>故事主线</h1><p>先讲一下主线，虽然这次主线的叙事不同于以往的魂系列，还是非常明了的，几乎认真玩过的人都能大致知道：</p>
<p>一心盗国二十余年，苇名国以日暮途穷。而此时，日本正处于战国末期，烽火连天，即使是位于山林深处的苇名国也被不少人耽视。但忌惮于剑圣一心的实力，不敢妄动。直到剑圣一心患上不治之症，敌国甚至开始大张旗鼓的准备起战事。</p>
<p>一心盗国时，其得力手下有四：巨型忍者“枭”、蝴蝶夫人、猿之忍者、医师道玄。</p>
<p>其中猿之忍者由于过重的罪业，化身为修罗。被剑圣一心砍断左手才恢复神智，最后隐居某个破旧的寺庙之中，想通过雕刻佛像来偿还自己的罪业。</p>
<p>突然有一天，苇名国一个叫平田的小城被大量的土匪入侵，而且这次土匪入侵并不一般：他们甚至花了大价钱雇佣强力的僧兵来作战，巨型忍者“枭”的义子，御子（中文翻译为皇子，有点误导。九郎并不是皇室，和苇名一族也没有血源关系，也没有管理国家的责任）的贴身的忍者“狼”也被僧兵击败负伤。即使巨型忍者“枭”和蝴蝶夫人前去帮助也无法阻止。</p>
<p>原来策划这起入侵的人，正是巨型忍者“枭”。他策反了蝴蝶夫人，让她绑走年幼的御子九郎，而自己假装不敌诈死，以掩人耳目。</p>
<p>“枭”的计划几乎快要成功之时，突然杀出了一位断臂的忍者。这名忍者就是三年后顺着记忆穿越而来的“狼”。</p>
<p>（这里有两种说法，一种就是物理穿越，还有一种就是单纯的回忆，我更偏向于物理穿越。一直在找证据：下方会有两种说法的具体分析）</p>
<p>断臂的只狼一路杀伐，甚至斩杀了自己的老师-蝴蝶夫人。在即将救到御子时，被诈死的“枭”偷袭，死在了大火之中。</p>
<p>年幼的皇子从大火和废墟之中救出了“狼”，并赋予了自己的龙胤之力，“狼”获得了重生。</p>
<p>“枭”如此大费周张的策划这起事件的原因，也正是因为想得到这“龙胤之力”不朽的力量。</p>
<p>不朽之法有四种：龙胤之力、京城水、变若水和附虫。虽说是三种，其实都是一个根源-从古老的西方（中国）被驱逐而来的樱龙（就是被狼用巨雷枪射爆的那位）。</p>
<p>龙胤，顾名思义就是龙的子嗣，龙力量的继承人。龙胤本身不会死亡，即使被砍伤也不会流出一滴血，伤口会瞬间愈合。并且龙胤可以把这个力量分享给别人，被分享力量的人会受伤，但死亡后会重生。这个重生的力量就被称为“龙胤之力”。</p>
<p>龙胤之力是三种不朽之法中最纯正的，代价最小的。但依然有代价：每次死亡与重生，都会吸取与你有过交集之人的生命力，使之患上名为“龙咳”的病症，且唯一治疗的方法就是用“龙胤滴露”将生命力归还于患有“龙咳”者。</p>
<p>不朽之法其二：京城水。樱龙来到日本后，找到了一块风水之地盘旋与栖息，这块风水之地就是“源之宫”。</p>
<p>但樱龙强大的力量也给源之宫带来了翻天覆的改变：首先是水，生活在上游源头的淤加美贵族外形办成了非人非龙的模样，且寿命变得极长，甚至还可以再用某种办法无限延续自己的寿命：吞噬别人的寿命（俗称+1s）。</p>
<p>不朽之法其三：附虫。水质的改变产生了巨大的王鲤鱼。王鲤鱼一共有两头，也拥有不朽之力。其中一头死后（死因不详）尸体被蠕虫吞噬，这些吞噬王鲤鱼的蠕虫，变成了不朽的附虫，这些附虫在水中不断产卵繁殖。</p>
<p>源之宫，顾名思义，这里是苇名地区水的源头（点击佛渡，手柄按Y键即可查看古地图）。附虫卵随着水源流动到苇名各地，不幸服下卵的人，就会变为附虫者，拥有不死之身，比如狮子猿、死兵卫和仙峰寺上长有附虫的长老。</p>
<p>但附虫可以说是代价非常之大的不死之法：大部分其实都被附虫所控制：二阶段的狮子猿、仙峰寺的长老。即使不被控制，也会相当痛苦，求死不能：死兵卫。</p>
<p>最后是变若水，变若水其实是人为研究的产物，通过研究附虫，试图人造出龙胤。且研究过程中付出了极大的代价：苇名之底的水生村就是试验场，所有的村民都变成了没有意识到活尸（且并没有不死之身）。</p>
<p>水生村本是一个贫穷幽静的村庄，村民淳朴的不像话，他们都无条件的信任着神官大人，而神官本人也憨厚的一匹。</p>
<p>有一天，一个人（还不清楚是谁，有评论说是水生村之前的那个淤加美吹箫哥。可能性很高）找到了神官，让他酿造一种酒（实为变若水），并许诺，只要酿造成功，就能让他成为京城人，可以在源之宫生活。</p>
<p>神官很高兴的将这个消息分享给大家，让大家能一起变为京城人。神官不断的酿造和尝试，给大家分享酿出的酒（变弱水）。最终，全部村民都因为劣质的变若水兽化，失去意识变为活尸。</p>
<p>最后当狼找到以变为活尸的神官时，他还在不断的酿造，不断的呢喃着让大家都变成京城人。</p>
<p>除了水生村外，仙峰寺也在尝试制作变若水，只是不知道是有人指使还是本身被对永生的贪婪。他们抓来前来朝拜的年轻人开始研究，直到狼来到先锋寺时，都能看到遍地的尸体。</p>
<p>仙峰寺里有一种不带附虫的不死老者，应该就劣质变若水的产物（但比水生村强多了）。最终在付出巨大代价后，仙峰寺也确实成功了，他们制作出了非常接近龙胤的赝品：唯一的一个变若之子。并将变若之子藏于内殿之中。</p>
<p>这一节对于龙胤、附虫、变若水的补充信息量有点多，但还是很有必要的。</p>
<p>书接上文，虽然“枭”在“狼”击败蝴蝶夫人后，背后一刀捅死了“狼”泄愤，但他最终还是失败了，以诈死的他不便出手再挟持御子。</p>
<p>物理穿越的“狼”被御子赐予龙胤之力后，取得了回忆，回到了三年之后。</p>
<p>而原本时间线的狼并不知道发生了什么，而且也没有龙胤之力。</p>
<p>最后御子被接到了苇名城保护起来，说是保护，实际上是监禁。而正常时间线上的狼，被告知义父和御子已死。这一切应该是苇名一心的义孙，苇名弦一郎搞的鬼。原因当然也是想得到“龙胤之力”。（至于为什么没把狼杀掉，有可能是出于一心的保护，也有可能是出于弦一郎的自大）</p>
<p>狼失去了活着的目标和动力，被囚禁于废弃的井底，一晃就是三年。</p>
<p>突然有一天，一心让道玄的义女，自己的学生和最信任的人“花菖蒲”（也就是医师永真）找到狼，告诉狼御子还活着，并让狼带着御子永远的逃离苇名城。</p>
<p>忍者知道后立刻动身救出了御子，在即将逃出苇名城的一刻，被弦一郎亲自埋伏，但不敌狼，最后用卑鄙手段砍断了狼的左手，再次抢回御子。</p>
<p>这时弦一郎已经坐不住了，他带着御子去到苇名主城，用各种办法：晓之以情，动之以理，威逼利诱，用各种办法想让御子直接把龙胤之力给他。</p>
<p>而狼在医师永真和一位雕佛师的帮助下，杀进了苇名城，再次击败弦一郎，但弦一郎复活了，原来弦一郎自己也喝了变若水。前面我已经提到了变若水，可能弦一郎疯狂的执念和这变若水有关，也可能无关。</p>
<p>自知不敌的弦一郎一个漂亮的背跃式跳高（跳了半米高）逃跑了。狼成功的救下了御子，他的最高任务是保护御子的周全，并按照原先的计划，想带着御子永远离开苇名。</p>
<p>但御子拒绝了，他要留在苇名，因为御子讨厌自己的龙胤之血，而且在经历了这么多祸端之后，决心要彻底消除它。狼很纠结，因为如果答应御子，等于违抗了义父命令，等于背弃了忍者的信条。</p>
<p>但他最后还是答应了，开始寻找清除龙胤需要的材料：龙之泪。</p>
<p>要获得龙之泪，就要到达“仙乡”，也就上文提到的“源之宫”。</p>
<p>要去往“仙乡”，需要几种“香料”。</p>
<p>其中一种，就是龙胤之血。前面我也提到龙胤即使受伤也不会流血，且伤口会瞬间愈合。</p>
<p>但苇名一心告诉狼：世界上有一种叫做“不死斩”的刀。可以杀死无法死去之人，也可以伤到龙胤。藏于仙峰寺内，让狼去取得。</p>
<p>实际上，“不死斩”一共有两把，一把是赤红色的“拜泪”（败类……中文翻译者是认真的吗？）；另一把是黑色的“开门”。</p>
<p>“开门”可以以无法死去之人为贡品，开启黄泉的大门。一心是知道两把不死斩的存在的，但只告诉了狼“拜泪”的存在和位置。</p>
<p>狼先后到了菩萨谷、水生村和仙峰寺寻找香料，在仙峰寺见到了唯一一个成功的若水之子，取得了不死斩“拜泪”。在于若水之子的交流中得知：即使斩断不死，去除御子龙胤，还是会有新的龙胤产生。一切只不过是轮回罢了，唯一的办法，就是将龙胤送回他的故乡-中国。只有那里，龙出生的地方，才能承受龙胤的力量。</p>
<p>为此狼为变若之子收集了两个蛇神的内脏，变若之子吞下后，化作摇篮。并且流出的眼泪化作了宝石-冰泪。只要御子将冰泪和樱龙之泪一同服下，就能完成摇篮的仪式。</p>
<p>在狼前往苇名各处寻找前往仙乡的材料时，他的义父，巨型忍者“枭”带着忍者突然闯入了苇名，他到这里的目的也只有一个：御子的龙胤之力。</p>
<p>看到御子不合作，“枭”直接命令狼：终止保护御子的命令，现在你和御子已经没有任何关系了。狼其实早已背弃了命令，所以丝毫没有犹豫的拒绝了。</p>
<p>枭想像三年前那样背后偷袭狼，被狼识破并斩杀。</p>
<p>（再补充一下修罗结局：如果这时狼选择遵从意旨，舍弃御子。则代表狼已经放弃了自己最后一丝人性，化为修罗。这时，永真说你已经成为了修罗，并且试图唤醒你。之前和永真对话，狼会问：你的剑术是谁教的？永真会说：我是医生不是武士，怎么会剑术。狼：那如何解释你身上的剑气？永真：因为感兴趣，一心曾教过我一点剑法。狼：这样的剑气绝不可能是感兴趣。永真：我绝对不会杀人的，如果有鬼的话，我会杀鬼吧。当你斩杀阻止你的永真后，年迈的剑圣一心会到来，捧着永真的尸体，说我曾经斩过修罗一样的人，没想到还会斩第二次。随后开战，不得不说，年迈的一心并不比年轻时弱很多。相对于年轻时右手拿刀左手拿钺，裤裆里还藏着五连发手枪，年迈的一心更配得上剑圣这个称号。当你斩杀一心后，枭回来了，手里拿着黑色不死斩，说明弦一郎这只鸡已经被他干掉，他看到一心的尸体说：即使是年迈的一心，你能战胜他我也很震惊，不愧是我的儿子。仰天大笑，这个国家已经在他手中了。然后被狼一刀捅死，枭问为什么，直到他看了狼一眼，大叫一声修罗。狼拿过那把黑色不死斩高举端详，从他沉醉的背影看得出来已经魔化。这一幕正好被御子看到，即使是这样御子也不愿意相信，“你不可能是修罗！”在御子的悲鸣中，修罗路线结束）</p>
<p>御子对狼为了自己手刃义父的事情很自责，其实对于狼来讲，这是他挣脱信条的束缚，获得自我的标志。</p>
<p>在狼踏上仙乡收集龙之泪的最后阶段，剑圣苇名一心终于病死。德川家康如同秃鹫一般嗅到了一心死亡的信息。早已备好的军队瞬间涌入苇名，战争之火瞬间烧毁了半个苇名城。</p>
<p>医师守在死去的一心前告诉狼：御子通过之前密道先逃出了苇名，让狼紧随其后。狼到达时，又遇到了弦一郎，这次弦一郎也拿到了另一把不死斩“开门”来抢夺皇子的龙胤之力，但并没有什么卵用（反而比以前更菜了），依然被狼按在地上暴打。</p>
<p>鼻青脸肿的弦一郎终于意识到了自己的无能，用自己手中的“开门”割破了自己的脖子，以执念召唤出了年轻的、鼎盛时期的剑圣苇名一心。不知是变若水的影响还是“开门”的影响，决定要杀光所有的入侵者。</p>
<p>被狼艰难击败，最后一心似乎恢复了神智，用尽全力控制住自己的身体端坐，狼将其斩首，再次送入黄泉。</p>
<p>随后，狼喂御子服用了樱龙之泪于冰泪，带到了变若之子面前，装进了以化作摇篮的身体。</p>
<p>最后，御子、变若之子和狼将踏上遥远的旅途：将龙送回中国。</p>
<p>以上为“龙之归乡”任务剧情。</p>
<h1 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h1><p>刚开始玩的时候是真的玩不进去，故事叙述风格也迷，开头的苇名国建国史看不懂就算了和后面我要干嘛有什么关系？没有地图引导，去哪里我都搞不灵清，开局就有一个boss两刀砍死我。宫崎英高，屌人搞我，大概就这种感受。</p>
<p>新学期开学后cyw、lbj我们一起一个个boss刷下去，我开始体会到魂类游戏的魅力。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>宿舍内挖矿体验及收益情况</title>
    <url>/2021/04/23/%E5%AE%BF%E8%88%8D%E5%86%85%E6%8C%96%E7%9F%BF%E4%BD%93%E9%AA%8C%E5%8F%8A%E6%94%B6%E7%9B%8A%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>猫咪12分类</title>
    <url>/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<center>利用神经网络、残差神经网络进行猫咪分类训练。</center>

<p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/封面.jpeg" style="zoom:50%;"></p>
<a id="more"></a>
<h3 id="实现的主要部分有"><a href="#实现的主要部分有" class="headerlink" title="实现的主要部分有"></a>实现的主要部分有</h3><ul>
<li>简单的网络结构在猫的种类识别上的应用，测试准确率0.832</li>
<li>使用resNet50在猫的种类识别上的应用，测试准确率0.866</li>
<li>使用数据增强解决过拟合问题，并提高测试准确率，测试准确率0.999</li>
</ul>
<h3 id="项目文件夹说明"><a href="#项目文件夹说明" class="headerlink" title="项目文件夹说明"></a>项目文件夹说明</h3><pre><code>------
cat_kind  项目文件名
    |----cat_data_resNet50  存放用于resNet网络训练的数据
        |----train      训练数据
        |----test       测试数据
    |----cat_kind_data  存放用于简单案例网络训练的数据（train.py）
        |----train      训练数据
        |----test       测试数据
    |----dataAug    数据增强后存放训练集的位置
    |----models     保存训练模型的位置
    |----resnet_example     使用resnet网络的文件夹
        |----predict_on_resnet.py   预测的时候使用的文件
        |----resnet50.py    定义resnet网络的文件
        |----train_on_resnet.py     训练resnet的文件
    |----source_images      数据集的原始文件夹
        |----0类猫
        |----1类猫
        |----2类猫
        |----3类猫
        ...
        |----n类猫
    |----tools      工具文件夹
        |----data_aug.py    数据增强
        |----prepare_data.py    数据预处理
    |----predict.py     使用简单网络进行预测的文件
    |----requirement.txt    环境依赖
    |----train.py       使用简单网络进行训练的文件
</code></pre><h4 id="step1-数据集预处理"><a href="#step1-数据集预处理" class="headerlink" title="step1 数据集预处理"></a>step1 数据集预处理</h4><p>使用文件：prepare_data.py</p>
<p>包括的操作有：</p>
<h5 id="图片重命"><a href="#图片重命" class="headerlink" title="图片重命"></a>图片重命</h5><ul>
<li>在renameJPG()方法实现，重命名的意图有两个，第一是将图片都统一为一种图片类型，<br>第二个目的是给图片添加训练标签（当然也可以将标签写在文件当中，这里只是一种简便的<br>做法）</li>
</ul>
<h5 id="图片转换为统一的格式"><a href="#图片转换为统一的格式" class="headerlink" title="图片转换为统一的格式"></a>图片转换为统一的格式</h5><ul>
<li>图片重命名保存的过程中将图片统一格式</li>
</ul>
<h5 id="图片统一大小"><a href="#图片统一大小" class="headerlink" title="图片统一大小"></a>图片统一大小</h5><ul>
<li>该网络要求输入图片的大小为(100,100),所以运行时要修改out_img_size为(100,100)，数据集保存位置save_dir为cat_kind_data</li>
</ul>
<h5 id="将图片按照一定的比例划分"><a href="#将图片按照一定的比例划分" class="headerlink" title="将图片按照一定的比例划分"></a>将图片按照一定的比例划分</h5><ul>
<li>按照比例9:1将数据划分为训练集和测试集,默认参数为0.9</li>
</ul>
<h4 id="step2-训练"><a href="#step2-训练" class="headerlink" title="step2 训练"></a>step2 训练</h4><ul>
<li>使用文件：train.py，直接执行</li>
</ul>
<h4 id="step3-测试"><a href="#step3-测试" class="headerlink" title="step3 测试"></a>step3 测试</h4><ul>
<li>使用文件：predict.py，直接执行</li>
</ul>
<h3 id="二-使用经典网络ResNet50实现猫的种类识别"><a href="#二-使用经典网络ResNet50实现猫的种类识别" class="headerlink" title="二 使用经典网络ResNet50实现猫的种类识别"></a>二 使用经典网络ResNet50实现猫的种类识别</h3><ul>
<li>由于resnet网络较为复杂，在少量的数据集情况下结果容易出现过拟合，所以首先进行数据增强的处理</li>
</ul>
<h4 id="step1-数据增强"><a href="#step1-数据增强" class="headerlink" title="step1 数据增强"></a>step1 数据增强</h4><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/sample.png" alt></p>
<p>直接运行data_aug.py，然后会在dataAug文件夹下生成12个对应猫种类的文件夹，相应的参数可以在data_aug.py调整</p>
<p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/data_aug.png" alt></p>
<h4 id="step2-数据集预处理"><a href="#step2-数据集预处理" class="headerlink" title="step2 数据集预处理"></a>step2 数据集预处理</h4><p>使用文件：prepare_data.py</p>
<p>包括的操作有：</p>
<h5 id="图片重命名"><a href="#图片重命名" class="headerlink" title="图片重命名"></a>图片重命名</h5><ul>
<li>在renameJPG()方法实现，重命名的意图有两个，第一是将图片都统一为一种图片类型，<br>第二个目的是给图片添加训练标签（当然也可以将标签写在文件当中，这里只是一种简便的<br>做法）</li>
</ul>
<h5 id="图片转换为统一的格式-1"><a href="#图片转换为统一的格式-1" class="headerlink" title="图片转换为统一的格式"></a>图片转换为统一的格式</h5><ul>
<li>图片重命名保存的过程中将图片统一格式</li>
</ul>
<h5 id="图片统一大小-1"><a href="#图片统一大小-1" class="headerlink" title="图片统一大小"></a>图片统一大小</h5><ul>
<li>在resNet中要求图片的大小在197——224之间，这里将图片的大小统一在224*224</li>
</ul>
<h5 id="将图片按照一定的比例划分-1"><a href="#将图片按照一定的比例划分-1" class="headerlink" title="将图片按照一定的比例划分"></a>将图片按照一定的比例划分</h5><ul>
<li>按照比例9:1将数据划分为训练集和测试集</li>
</ul>
<h4 id="step3-定义网络结构"><a href="#step3-定义网络结构" class="headerlink" title="step3 定义网络结构"></a>step3 定义网络结构</h4><ul>
<li><p>网络结构采用Keras搭建好的resNet50，使用文件：resnet_example/resnet50.py</p>
</li>
<li><p>使用文件：resnet_example/resnet50.py,原始文件可从<a href="https://github.com/fchollet/deep-learning-models">deep-learning-models</a><br>获取，为了使得该文件能适应训练加测试，我做了相应的修改</p>
</li>
</ul>
<h4 id="step4-训练"><a href="#step4-训练" class="headerlink" title="step4 训练"></a>step4 训练</h4><ul>
<li>使用文件：resnet_example/train_on_resnet.py</li>
</ul>
<h4 id="step5-测试"><a href="#step5-测试" class="headerlink" title="step5 测试"></a>step5 测试</h4><ul>
<li>使用文件：resnet_example/predict_on_resnet.py</li>
</ul>
<h3 id="三-模型文件及数据集下载"><a href="#三-模型文件及数据集下载" class="headerlink" title="三 模型文件及数据集下载"></a>三 模型文件及数据集下载</h3><p>数据集使用的是来自百度公开数据集的猫咪12分类数据</p>
<p><a href="https://aistudio.baidu.com/aistudio/datasetDetail/10954">12分类数据集</a></p>
<p><a href="http://www.vvindsky.xyz/cat_kind.zip">代码下载</a></p>
]]></content>
      <tags>
        <tag>技术</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title>提利昂·兰尼斯特是龙还是狮的一些猜想</title>
    <url>/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/</url>
    <content><![CDATA[<p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/提利昂插画.png" alt="提利昂插画" style="zoom:33%;"></p>
<p>​    提利昂·兰尼斯特斯特的出身问题一直是冰火论坛里争论不休的热点话题。附庸风雅地来总结下我看到的双方观点论据。</p>
<a id="more"></a>
<p>​    在开始讲两派观点之前先声明下我的观点，我认为小恶魔是龙家，主观上纯粹因为爽，一个如此讨喜的人物配拥有一身龙血，并且可以规避弑亲必死的因果律武器。客观原因在以下的论据中体现，我按我认为的可信度强弱将证据进行了排序。</p>
<h1 id="观点1：小恶魔是龙家的"><a href="#观点1：小恶魔是龙家的" class="headerlink" title="观点1：小恶魔是龙家的"></a>观点1：小恶魔是龙家的</h1><h2 id="证据1-发色与异色瞳（难以辩驳的铁证）"><a href="#证据1-发色与异色瞳（难以辩驳的铁证）" class="headerlink" title="证据1 发色与异色瞳（难以辩驳的铁证）"></a>证据1 发色与异色瞳（难以辩驳的铁证）</h2><p>马丁在人的发色和身材外貌描写上是很注重细节的，无论是私生还是嫡生都可以看到很多关于父子或一个家族中相近的特点存在，如狮子家的金发、龙家的白化病（笑）、大小剥皮的瞳孔，这些细节让冰火的世界充满味道。</p>
<p>说回重点，这是小恶魔在卷一出场时的描写：</p>
<p>「    <strong><em>琼恩发觉自己几乎无法将视线从他身上抽离，他暗想，这才是王者应有的风范。接着他望向兰尼斯特雄狮的弟弟，小恶魔提利昂，此人正摇摇摆摆走在哥哥身边，他是个身高只有哥哥一半的侏儒，鼓动着畸形的双腿努力追上哥哥的脚步，他的头大得不成比例，鼓胀额头下是一张扭曲的怪脸，双眼一碧一黑，从满头长直金发下面向外窥视，他头发的颜色几乎金亮成白。</em></strong>」</p>
<p>重点在 <strong>一碧一黑 </strong>与 <strong>金亮成白</strong>，先说异色瞳这一点，这在冰火世界中目前提到的还有两例分别为<strong>西蕊洋星</strong>与<strong>阿莱莎·坦格利安</strong>，这两人都是龙血。</p>
<p>西蕊洋星是庸王伊耿四世的私生女，寒铁、血鸦都在追求的大美女，她的瞳色是一蓝一绿。（TheMico的西蕊洋星插画👇）</p>
<p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/西蕊洋星.png" alt></p>
<p>阿莱莎·坦格利安是外传血与火中出场的人物，是国王杰赫里斯一世与王后亚莉珊·坦格利安的第二个孩子，一名御龙者，她的龙是红龙梅利亚斯。她天生异瞳，一只是紫罗兰色，另一只是绿色。</p>
<p>「它和我都曾是紅色處女，現在我們都被騎了。</p>
<p>​                                            —— 阿萊莎在駕馭她的龍後，評價她自己和梅麗亞斯」</p>
<p>「我壓在他身上，反覆騎他。今晚我還要再好好享受，我喜歡騎他。</p>
<p>​                                            —— 阿萊莎在她的新婚之夜次日清晨宣稱    」</p>
<p>还有<strong>发色金的发白</strong>，我个人认为这是几乎明示提利昂有龙血了。父亲是泰温，母亲是乔安娜，两只狮子血脉的孩子发色应该是纯正的金色（参考瑟曦与詹姆）但这里描写提利昂发色金的发白就很微妙了。</p>
<h2 id="证据2-病态地迷恋龙"><a href="#证据2-病态地迷恋龙" class="headerlink" title="证据2 病态地迷恋龙"></a>证据2 病态地迷恋龙</h2><p>提利昂从小便对龙很痴迷，在他的命名仪式上，他的叔叔吉利安问他：想要什么东西？幼小的半人说，他想要一条未成年的龙。众人听罢纷纷讪笑，因为最后的龙已经死了一个多世纪——再也没有龙了。甚少哭泣的提利昂知道后，哭了很久。</p>
<p>他熟读《龙、蜥龙和长翼龙：龙族的非自然演化史》、《血龙狂舞真史》等各类有关于龙的书籍。他也因此掌握了许多有关魔龙的知识，例如什么龙骨含铁量极高啊、龙口散播死亡啊、龙的唯一弱点是眼睛blabla，都是马丁老爷子借他的口告诉我们的。</p>
<p>很久以后，提利昂告诉雪诺，他小时候曾经非常认真地想要一条幼龙。雪诺表示难以置信，毕竟这种违反常识的愿望，跟现实睿智的半人联系不到一起。但提利昂却说：</p>
<p>「<strong><em>……只要能骑在龙背上，即便是发育不良，畸形扭曲的丑陋小男孩也可以睥睨全世界。”提利昂推开熊皮，站起身来。“以前我常躲在凯岩城深处的地道，燃起火堆，望着熊熊烈焰，一望就是好几个钟头，一边幻想那是魔龙吐出的烈火。有时候我会幻想我老爸被火烧死，有时候则是我老姐。</em></strong>」</p>
<p>剧中也有提利昂与龙亲密接触龙对他显示亲昵姿态的场面    </p>
<p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/龙提.png" alt></p>
<p>从这里可以看出提利昂应该是有龙血才能和龙有比较亲密的关系。</p>
<h2 id="证据3-龙的三首与出生害死母亲"><a href="#证据3-龙的三首与出生害死母亲" class="headerlink" title="证据3 龙的三首与出生害死母亲"></a>证据3 龙的三首与出生害死母亲</h2><p>这个证据我个人是很推崇的，因为这样的话文章会对仗工整顺畅。</p>
<p>首先说回龙家的族徽:黑底红色三头龙，龙有三个头，这并不是说一条龙长着三个头，而是指三这个数字与龙家割舍不了的关系。</p>
<p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/坦格利安族徽.png" alt></p>
<p>三百多年前，伊耿·坦格利安与他的一个姐姐和一个妹妹，三个人分别骑着三头巨龙，征服了整个维斯特洛大陆，开启了坦格利安王朝。如今，丹妮莉丝带着三条龙再次杀回，龙有了，人呢？如今，我们知道了琼恩·雪诺也是龙家人（书里还是没实锤不过要是囧都不是龙家我就弃坑了）。只剩下最后一个名额，而纵观全局，剩下的那个巨头，就是提利昂。</p>
<p>并且龙妈、囧、提利昂这三人还有一个巧合就是诞生时害死了母亲， 囧、龙妈和小恶魔都是出生时母亲去世，也能从某种程度上构成巧合。</p>
<h2 id="证据4-疯王痴迷乔安娜"><a href="#证据4-疯王痴迷乔安娜" class="headerlink" title="证据4 疯王痴迷乔安娜"></a>证据4 疯王痴迷乔安娜</h2><p>疯王对泰温的老婆乔安娜的迷恋有很多的描写。伊里斯在泰温结婚时闹洞房十分积极，有学士隐晦地记载，伊里斯<strong>“获得了过分的自由”</strong>，伊里斯甚至表示<strong>要是初夜权没废除就好了</strong>，可以说下流猥琐至极。</p>
<p>在泰温当国王之手初期，乔安娜也是随自己丈夫住在君临的，但没多久就被当时的雷拉王后赶回凯岩城，这俩人可是好闺蜜。这之后，乔安娜在凯岩城生下了金色双胞胎。伊里斯听说了乔安娜的生产后曾说<strong>“我娶了错误的女人。”</strong>他派人送去礼金，要求泰温在双胞胎长大后把他们带来君临，并要求乔安娜同往，因为他“太久没瞧见那张俏丽的脸了”。</p>
<p>272AC，伊里斯加冕十年庆典的比武大会上，乔安娜带着两个孩子拜见了伊里斯，醉酒的伊里斯问乔安娜给孩子们喂奶是不是“毁了你那对儿坚挺又骄傲的奶子”。这句话让乔安娜遭到了极大羞辱。273AC，乔安娜在凯岩城生下提利昂并难产而死。</p>
<p>值得一提的是如果确实是疯王侮辱了乔安娜并生下小恶魔，那么疯王侮辱乔安娜就是发生在272AC比武大会的这段时间中。</p>
<h1 id="观点2：小恶魔不是龙家的"><a href="#观点2：小恶魔不是龙家的" class="headerlink" title="观点2：小恶魔不是龙家的"></a>观点2：小恶魔不是龙家的</h1><h2 id="证据1-泰温太骄傲了，不可能吃别人的残羹剩饭"><a href="#证据1-泰温太骄傲了，不可能吃别人的残羹剩饭" class="headerlink" title="证据1 泰温太骄傲了，不可能吃别人的残羹剩饭"></a>证据1 泰温太骄傲了，不可能吃别人的残羹剩饭</h2><p>泰温对乔安娜的爱可以从书中很多细节中看出，据说他们结婚当日泰温露出了笑容，对于泰温来说这是极其少见的情绪外露。各方面的线索都显示他们的婚姻非常幸福，乔安娜深受泰温的信任，不止作为他的妻子，还是他的参谋和朋友。许多人都知道一句俗语描述她对丈夫的影响“泰温大人统治七国”（作为国王之手）但是“乔安娜夫人统治着泰温大人。并且乔安娜死后，泰温再也没有笑过（也受他父亲，笑狮泰陀斯的影响）。</p>
<p>这样一个人物，如此爱自己的妻子，更不可能容许自己的妻子被玷污的。有谣言称乔安娜的初夜在杰赫里斯加冕的当晚就给了伊里斯，并且在伊里斯称王之后还当过一段疯王的情妇。这种说法被派席尔国师否定。在他的信中，他声称“骄傲的泰温伯爵绝不可能吃别人的残羹剩饭”。</p>
<p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/乔安娜.png" alt></p>
<h2 id="证据2-泰温对伊里斯挑衅的反应"><a href="#证据2-泰温对伊里斯挑衅的反应" class="headerlink" title="证据2 泰温对伊里斯挑衅的反应"></a>证据2 泰温对伊里斯挑衅的反应</h2><p>疯王和泰温在年轻时（疯王未疯时）是挚友，也因此疯王力排众议将当时尚且年轻的泰温扶上国王之手的位置。但是随着时间的推移，疯王对泰温的感情逐渐转为了嫉妒。也因此支持提利昂非龙的人们认为疯王对乔安娜的轻浮言论只是为了挑衅和激怒泰温。</p>
<p>除次之外更要提的是，疯王三番五次出言挑逗乔安娜泰温都能忍下来，如果疯王真的与乔安娜有染泰温不可能再给他继续兢兢业业地做国王之手（龙血党认为这只是因为疯王与乔安娜有染这一事未被泰温知晓）。让泰温卸下国王之手位置的居然是疯王给詹姆披上白袍（削去了詹姆继承权，迫使泰温传凯岩城给小恶魔），这对骄傲的泰温来说是很不合理的。</p>
]]></content>
      <tags>
        <tag>冰火</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.png" alt="新建" style="zoom: 33%;"></p>
<p>每次提到排序印象都是，学过排序，但脑子里就剩下个快排，抽个空把所有叫得上名字的排序整理下，日后复习起来也简单些。</p>
<a id="more"></a>
<p>​    分类</p>
<ul>
<li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li>
</ul>
<p>​    基本概念介绍</p>
<h1 id="1-冒泡排序-Bubble-Sort"><a href="#1-冒泡排序-Bubble-Sort" class="headerlink" title="1 冒泡排序 Bubble Sort"></a>1 冒泡排序 Bubble Sort</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    比较基本的排序算法，在每次循环开始时从一端的元素开始向另一端循环，遇到右&gt;左则换位，这样在第一遍循环之后 我们可以保证数组的最右端是最大元素。依次重复n此后可保证数组按顺序排列完毕。</p>
<h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/bubble.gif" alt></p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index &lt;len ;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                value = *pivot;</span><br><span class="line">                *pivot = arr[index];</span><br><span class="line">                pivot = &amp; arr[index];</span><br><span class="line">                *pivot = value;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h1 id="2-选择排序-Selection-Sort"><a href="#2-选择排序-Selection-Sort" class="headerlink" title="2  选择排序 Selection Sort"></a>2  选择排序 Selection Sort</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    也是一个比较基本的排序算法，每次循环时找到数组中最小的元素将其放在数组最左端。循环n次后得到排序完成的数组。</p>
<h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/selection.gif" alt></p>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index&lt;len;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                pivot = &amp;arr[index]; <span class="comment">//指向新的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//与未排序部分的第一位进行替换</span></span><br><span class="line">        value = *pivot;</span><br><span class="line">        *pivot = arr[i];</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h1 id="3-插入排序-Insertion-Sort"><a href="#3-插入排序-Insertion-Sort" class="headerlink" title="3 插入排序 Insertion Sort"></a>3 插入排序 Insertion Sort</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    大体思想为，循环i次时，保证数组的前i位元素都为已经排序好的，每次到i元素</p>
<h2 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/insertion.gif" alt></p>
<h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index&lt;len;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                pivot = &amp;arr[index]; <span class="comment">//指向新的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//与未排序部分的第一位进行替换</span></span><br><span class="line">        value = *pivot;</span><br><span class="line">        *pivot = arr[i];</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><h1 id="4-希尔排序-Shell-Sort"><a href="#4-希尔排序-Shell-Sort" class="headerlink" title="4 希尔排序 Shell Sort"></a>4 希尔排序 Shell Sort</h1><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；(不同颜色表示不同序列 )</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h2 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/shell.gif" alt></p>
<h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">shellSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(vargap = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = Math.<span class="built_in">floor</span>(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class="line">        <span class="keyword">for</span>(vari = gap; i &lt; len; i++) &#123;</span><br><span class="line">            varj = i;</span><br><span class="line">            varcurrent = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><h1 id="5-归并排序-Merge-Sort"><a href="#5-归并排序-Merge-Sort" class="headerlink" title="5 归并排序 Merge Sort"></a>5 归并排序 Merge Sort</h1><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p>
<ul>
<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
<h2 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/merge.gif" alt></p>
<h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">mergeSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        returnarr;</span><br><span class="line">    &#125;</span><br><span class="line">    varmiddle = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    returnmerge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">merge</span><span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    varresult = [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    returnresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><h1 id="6-快速排序-Quick-Sort"><a href="#6-快速排序-Quick-Sort" class="headerlink" title="6 快速排序 Quick Sort"></a>6 快速排序 Quick Sort</h1><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<h2 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quicksort.gif" alt></p>
<h2 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">quickSort</span><span class="params">(arr, left, right)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left =typeofleft !=&#x27;number&#x27;? 0 : left,</span><br><span class="line">        right =typeofright !=&#x27;number&#x27;? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">partition</span><span class="params">(arr, left ,right)</span> </span>&#123;    <span class="comment">// 分区操作</span></span><br><span class="line">    varpivot = left,                     <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(vari = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    returnindex<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">    vartemp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><h1 id="7-堆排序-Heap-Sort"><a href="#7-堆排序-Heap-Sort" class="headerlink" title="7 堆排序 Heap Sort"></a>7 堆排序 Heap Sort</h1><h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">参考博客</a></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
