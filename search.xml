<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Online Learning(1) Intro</title>
      <link href="2022/07/18/Online-Learning-1-Intro/"/>
      <url>2022/07/18/Online-Learning-1-Intro/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/07/18/Online-Learning-1-Intro/cover.jpeg" style="zoom:40%;"></p><p>开坑online learning and bandiys，一直很期望系统地学习下，利用这个暑假争取拿下。🤤</p><a id="more"></a><h2 id="Basic-Setting"><a href="#Basic-Setting" class="headerlink" title="Basic Setting"></a>Basic Setting</h2><p>A bandit problem is a sequential game between a <strong>learner</strong> and an <strong>environment</strong>.</p><p>The game is played over $n$  rounds, where $n$ is a positive natural number called the horizon. In each round $t \in[n] $, the learner first chooses an action $A_t$ from a given set $\mathcal{A}$, and the environment then reveals a reward $X_t \in \mathbb{R}$. </p><p>The learner cannot peek into the future when choosing their actions. The action $A<em>t$  should only depend on the history $H</em>{t-1} = \left(A<em>{1}, X</em>{1}, \ldots, A<em>{t-1}, X</em>{t-1}\right)$.</p><h2 id="Regret"><a href="#Regret" class="headerlink" title="Regret"></a>Regret</h2><blockquote><p><em>DEFINITION : The regret of the learner relative to a policy $\pi$ (not necessarily that followed by the learner) is the difference between the total expected reward using policy $\pi$ for $n$ rounds and the total expected reward collected by the learner over $n$ rounds. The regret relative to a set of policies $\Pi$ is the maximum regret relative to any policy $\pi \in \Pi$ in the set.</em></p></blockquote><p>The set $\Pi$ is often called the <strong>competitor class. ( 与$\Pi$ 中的strategy 对抗)</strong></p><p>Regret measures the performance of the learner relative to the best policy in the competitor class.</p><hr><p>Example:</p><p>Suppose the action set is $\mathcal{A}={1,2, \ldots, k}$. An environment is called a stochastic Bernoulli bandit if the reward $X<em>{t} \in{0,1}$ is binary valued and there exists a vector $\mu \in[0,1]^{k}$ such that the probability that $X</em>{t}=1$ given the learner chose action $A<em>{t}=a$ is $\mu</em>{a}$. The class of stochastic Bernoulli bandits is the set of all such bandits, which are characterised by their mean vectors. If you knew the mean vector associated with the environment, then the optimal policy is to play the fixed action $a^{*}=\operatorname{argmax}<em>{a \in \mathcal{A}} \mu</em>{a}$. This means that for this problem the natural competitor class is the set of $k$ constant polices $\Pi=\left{\pi<em>{1}, \ldots, \pi</em>{k}\right}$, where $\pi_{i}$ chooses action $i$ in every round. The regret over $n$ rounds becomes </p><script type="math/tex; mode=display">R_{n}=n \max _{a \in \mathcal{A}} \mu_{a}-\mathbb{E}\left[\sum_{t=1}^{n} X_{t}\right]</script><h3 id="Asymptotic-analysis-of-regret"><a href="#Asymptotic-analysis-of-regret" class="headerlink" title="Asymptotic  analysis of regret"></a>Asymptotic  analysis of regret</h3><p>A good learner achieves sublinear regret. This means that $R<em>n =o(n)$ or $\lim </em>{n \rightarrow \infty} R<em>{n} / n=0$. The interesting question is under what circumstances is $R</em>{n}=O(\sqrt{n}) \text { or } R_{n}=O(\log (n)) ?$</p><h2 id="Different-settings"><a href="#Different-settings" class="headerlink" title="Different settings:"></a>Different settings:</h2><h3 id="Stochastic-Stationary-Bandits"><a href="#Stochastic-Stationary-Bandits" class="headerlink" title="Stochastic Stationary Bandits"></a>S<strong>tochastic Stationary Bandits</strong></h3><p>A simple problem setting is that of <strong>stochastic stationary bandits</strong>. In this case the environment is restricted to generate the reward in response to each action from a distribution that is specific to that action and independent of the previous action choices and rewards.</p><script type="math/tex; mode=display">X_{t}=\langle a, \theta\rangle+\eta_{t}</script><h3 id="Adversarial-bandits"><a href="#Adversarial-bandits" class="headerlink" title="Adversarial bandits"></a>Adversarial bandits</h3><p>An extreme idea is to drop all assumptions on how the rewards are generated, except that they are chosen without knowledge of the learner’s actions and lie in a bounded set.</p><p>The learner is not expected to find the best sequence of actions, which may be like finding a needle in a haystack. Instead, we usually choose Π to be the set of constant policies and demand that the learner is not much worse than any of these. By defining the regret in this way, the stationarity assumption is transported into the definition of regret rather than constraining the environment.</p><h3 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h3><p>在一般的问题中考虑 learner’s available choices and rewards tomorrow are not affected by their decisions today. 但RL 考虑long term profit</p><h3 id="Partial-Monitoring"><a href="#Partial-Monitoring" class="headerlink" title="Partial Monitoring"></a>Partial Monitoring</h3><p>The setting where the reward is not observed is called <strong>partial monitoring.</strong></p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><ul><li><h3 id="A-B-Testing"><a href="#A-B-Testing" class="headerlink" title="A/B Testing"></a>A/B Testing</h3></li></ul><p>The designers of a company website are trying to decide whether the ‘buy it now’ button should be placed at the top of the product page or at the bottom.</p><p>One way to apply bandits to this problem is to view the two versions of the site as actions. Each time t a user makes a request, a bandit algorithm is used to choose an action $A_t \in \mathcal{A} = {SiteA, SiteB}$, and the reward is $X_t = 1$ if the user purchases the product and  $X_t = 0$ otherwise.</p><ul><li><h3 id="Advert-Placement"><a href="#Advert-Placement" class="headerlink" title="Advert Placement"></a>Advert Placement</h3><p>In advert placement, each round corresponds to a user visiting a website, and the set of actions $\mathcal{A}$ is the set of all available adverts. One could treat this as a standard multi-armed bandit problem, where in each round a policy chooses $A<em>{t} \in \mathcal{A}$, and the reward is $X</em>{t}=1$ if the user clicked on the advert and $X_{t}=0$</p></li><li><h3 id="Dynamic-Pricing"><a href="#Dynamic-Pricing" class="headerlink" title="Dynamic Pricing"></a>Dynamic Pricing</h3><p>Users arrive sequentially, and the learner sets the price.</p><ul><li>(a) the learner never actually observes the valuation of the product, only the binary signal that the price was too low/too high, and</li><li>(b) there is a monotonicity structure in the pricing. If a user purchased an item priced at $10, then they would surely purchase it for $5, but whether or not it would sell when priced at $11 is uncertain.</li></ul></li><li><h3 id="Network-Routing"><a href="#Network-Routing" class="headerlink" title="Network Routing"></a>Network Routing</h3></li></ul><p>Another problem with an interesting structure is network routing, where the learner tries to direct internet traffic through the shortest path on a network. In each round the learner receives the start/end destinations for a packet of data. The set of actions is the set of all paths starting and ending at the appropriate points on some known graph.</p><ul><li><h3 id="Waiting-Problems"><a href="#Waiting-Problems" class="headerlink" title="Waiting Problems"></a>Waiting Problems</h3><p>公交车来的时间、通行时间不确定，但如果坐上了就时间很短。步行时间长，但用时确定。（Learn CDF of uncertain event）</p><p>应该等多久公车后决定步行？</p></li><li><h3 id="Resource-Allocation"><a href="#Resource-Allocation" class="headerlink" title="Resource Allocation"></a>Resource Allocation</h3></li><li><h3 id="Recommendation-类似广告问题，不过问题更复杂"><a href="#Recommendation-类似广告问题，不过问题更复杂" class="headerlink" title="Recommendation(类似广告问题，不过问题更复杂)"></a>Recommendation(类似广告问题，不过问题更复杂)</h3><p>Netflix has to decide which movies to recommend to customers.</p><p>The reward can be measured as some function of (a) whether or not you watched a movie and (b) whether or not you rated it positively.</p></li><li><h3 id="Tree-Search"><a href="#Tree-Search" class="headerlink" title="Tree Search (?)"></a>Tree Search (?)</h3></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> online learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>康米主义蒸汽朋克诗</title>
      <link href="2022/06/14/%E5%BA%B7%E7%B1%B3%E4%B8%BB%E4%B9%89%E8%92%B8%E6%B1%BD%E6%9C%8B%E5%85%8B%E8%AF%97/"/>
      <url>2022/06/14/%E5%BA%B7%E7%B1%B3%E4%B8%BB%E4%B9%89%E8%92%B8%E6%B1%BD%E6%9C%8B%E5%85%8B%E8%AF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/06/14/%E5%BA%B7%E7%B1%B3%E4%B8%BB%E4%B9%89%E8%92%B8%E6%B1%BD%E6%9C%8B%E5%85%8B%E8%AF%97/cover.png" style="zoom:20%;"></p><center>  <font size="20">Reflections</font></center><p></p><p align="right">RS Thomas</p><p></p><html>    <table style="margin：auto ;text-align:center">        <tr>            <td>                <!--左侧内容-->                  The furies are at home in the mirror; <br>                it is their address.<br>                Even the clearest water,<br>                if deep enough can drown.<br> <br>                Never think to surprise them.<br>                Your face approaching ever<br>                so friendly is the white flag they ignore. <br>                There is no truce with the furies. <br><br>                A mirror’s temperature is always at zero. <br>                It is ice in the veins. <br>                Its camera is an X-ray. <br><br>                It is a chalice held out to you in silent communion, <br>                where gaspingly you partake of a shifting<br>                identity never your own.<br>            </td>            <td>                <!--右侧内容-->复仇女神们的居处，<br>就在家家户户的镜中。<br>即使世间至清的水，<br>那深潭亦会带来灭顶之灾。<br><br>他们不会吃惊，<br>容颜永恒。<br>他们无视白旗的友好，<br>怒火永不熄灭。<br><br>镜子凝在零度，<br>它是血中之冰，是X光片。<br>它在沉默的圣飨向你递来圣杯<br><br>在那里，你喘着粗气<br>扮演着一个不断变化的<br>始终不属于你的身份。<br>            </td>        </tr>    </table></html><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KKT与CQ</title>
      <link href="2022/06/12/KKT%E4%B8%8ECQ/"/>
      <url>2022/06/12/KKT%E4%B8%8ECQ/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/06/12/KKT%E4%B8%8ECQ/cover.jpg" style="zoom:48%;"></p><p>KKT已经成为了几乎所有的CS 、MAT学生都绕不开的知识、工具。浅写一下自己在几年的学习中对KKT和CQ的一些理解，方便自己日后复习。</p><a id="more"></a><h1 id="1-Unconstrained-Problem"><a href="#1-Unconstrained-Problem" class="headerlink" title="1 Unconstrained Problem"></a>1 Unconstrained Problem</h1><p>这一部分是non-linear programming 的基础，这不是本篇文章想要讨论的重点，日后可能会继续做一次总结。对于unconstrained的问题大体有2个解法：</p><ol><li>Gradient Descent    (1阶的算法)</li><li>Newton’s method / Quasi Neston’s method（2阶的算法）</li></ol><p>Unconstrained Problem 是解决constrained problem的基础。<strong>barrier method、penalty method</strong> 等都是将constrains 放到objective function之上，通过解决unconstrained problem来得到解（这些解法通常都可以与KKT point \ Duality 等结果相联系）</p><h1 id="2-Constrained-Problem-and-KKT-condition"><a href="#2-Constrained-Problem-and-KKT-condition" class="headerlink" title="2 Constrained Problem and KKT condition"></a>2 Constrained Problem and KKT condition</h1><p>对于问题：</p><script type="math/tex; mode=display">\min _{x \in \mathbb{R}^{n}} f(x) \text { s.t. } g(x) \leq 0, \quad h(x)=0,</script><p>若x’ 是该问题的local solution，<font color="red">且在x’处满足一种CQ</font>，则在x’处必存在以下方程的一组解：</p><p> <strong>1st Order Karush-Kuhn-Tucker conditions</strong> (1阶KKT conditions）</p><script type="math/tex; mode=display">\left\{\begin{array}{l}\text { (i) } \nabla f\left(x^{*}\right)+\nabla g\left(x^{*}\right) \lambda^{*}+\nabla h\left(x^{*}\right) \mu^{*}=0 \quad \text { (multiplier rule) } \\\text { (ii) } h\left(x^{*}\right)=0 \\\text { (iii) } \lambda^{*} \geq 0, \quad g\left(x^{*}\right) \leq 0, \quad\left(\lambda^{*}\right)^{\top} g\left(x^{*}\right)=0 \quad \text { (complementarity conditions). }\end{array}\right.</script><p>KKT condition通过 <strong><em>Farkas Lemma</em></strong>证明的，这一证明可以参考berserkas的教科书。</p><p>从以上的描述中我们再强调下这个定理说描述的事情，若在一个x*处满足一种“Cconstrained Qualification”，那么就一定有满足KKT的解。也就是说，在x处<font color="Red">若有CQ，则KKT是必要条件</font>。</p><p>那么我们现在需要重新了解下：</p><p><center><font size="12">什么是CQ？</font></center></p><h1 id="3-Constrained-Qualification"><a href="#3-Constrained-Qualification" class="headerlink" title="3 Constrained Qualification"></a>3 Constrained Qualification</h1><p>若要了解constrained qualification 需要先了解“cone”：</p><h2 id="Feasible-set-and-Active-Constrain"><a href="#Feasible-set-and-Active-Constrain" class="headerlink" title="Feasible set and Active Constrain"></a>Feasible set and Active Constrain</h2><p><font color="#5555FF">Definition 1</font>:<strong><em>Feasible Set and Active Constraints</em></strong><br>The set</p><script type="math/tex; mode=display">X:=\left\{x \in \mathbb{R}^{n}: g(x) \leq 0, h(x)=0\right\}</script><p>is called feasible set of the problem (1). A point $x \in \mathbb{R}^{n}$ is called feasible if we have $x \in X$. For a feasible point $x \in X$, we define the index set of the active constraints $\mathcal{A}(x)$ and the index set of the inactive constraints $\mathcal{I}(x)$ as follows:</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{A}(x) &:=\left\{i \in\{1, \ldots, m\}: g_{i}(x)=0\right\} \\\mathcal{I}(x) &:=\{1, \ldots, m\} \backslash \mathcal{A}(x)=\left\{i \in\{1, \ldots, m\}: g_{i}(x)<0\right\}\end{aligned}</script><p><font color="#5555FF">Definition 2</font>: <strong><em>Tangent Cone</em></strong><br>Let $X \subset \mathbb{R}^{n}$ be a nonempty set. The tangent cone (or Bouligand cone) of $X$ at a point $x \in X$ is given by</p><script type="math/tex; mode=display">T_{X}(x):=\left\{d \in \mathbb{R}^{n}: \exists\left(\eta_{k}\right)_{k} \in \mathbb{R}_{++},\left(x^{k}\right)_{k} \in X \text { such that } x^{k} \rightarrow x, \quad \eta_{k}\left(x^{k}-x\right) \rightarrow d\right\}</script><p><font color="#5555FF">Definition 3</font>: <strong><em>Linealized Tangent Cone</em></strong></p><p>The set</p><script type="math/tex; mode=display">T_{\ell}(g, h, x):=\left\{d \in \mathbb{R}^{n}: \nabla g_{i}(x)^{\top} d \leq 0 \forall i \in \mathcal{A}(x), \quad \nabla h(x)^{\top} d=0\right\}</script><p>is called the linearized tangent cone at $x \in X$</p><h2 id="几个CQ："><a href="#几个CQ：" class="headerlink" title="几个CQ："></a>几个CQ：</h2><p><strong><em>ACQ</em></strong></p><script type="math/tex; mode=display">T_{\ell}(g, h, x)=T_{X}(x)</script><p><strong><em>GCQ</em></strong></p><script type="math/tex; mode=display">T_{X}\left(x^{*}\right)^{\circ}=T_{\ell}\left(g, h, x^{*}\right)^{\circ}\\\text{where} \\K^{\circ}:=\left\{v \in \mathbb{R}^{n}: v^{\top} d \leq 0 \quad \forall d \in K\right\}</script><p><font color="#5555FF">Definition 4</font>: <strong><em>Constraint Qualification</em></strong><br>Let $x \in X$ be given. A condition that implies the (GCQ) is called Constraint Qualification (CQ) for $x$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小割与最大流</title>
      <link href="2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>最大流与最小割问题常用于matching问题、clustering问题等等…</p><p><strong>最小割问题：</strong>在一个带权重的图中找出一个将所有顶点分为两类的分割方法，切分割的边权重合最小（实际上就是一种对于边的cut）。</p><p><strong>最大流问题：</strong>在一个带权有向图中，找出可能的最大流量从 <strong>S-&gt;T</strong>。</p><p><img src="/2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/cover.png" style="zoom:40%;"></p><a id="more"></a><h1 id="最小割问题"><a href="#最小割问题" class="headerlink" title="最小割问题"></a>最小割问题</h1><p>一个cut相当于将vertex分为两类，其中会切开一些边，找到最小的切分方法。</p><p><img src="/2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/cut.png" style="zoom:40%;"></p><p>最小割问题在研究网络最薄弱环节相关问题上具备广泛应用。而这个问题如今也依旧是一个open problem。</p><p>如今主要有这么两类随机算法来解决这一问题：</p><ol><li><p>LAS VEGAS ALGORITHMS：保证正确性，但运行时间有random性（类如quick sort）</p></li><li><p>MONTE CARLO ALGORITHM：正确性不一定保证，但运行时间efficient</p></li></ol><h2 id="Karger’s-algorithm"><a href="#Karger’s-algorithm" class="headerlink" title="Karger’s algorithm"></a>Karger’s algorithm</h2><p> Pick a random edge, contract it, and repeat <font color="red"> until you only have 2 vertices left</font>.</p><p><img src="/2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/karger.png" style="zoom:40%;"></p><p>正确的概率 $&gt; 1 /\left(\begin{array}{l}<br>n \<br>2<br>\end{array}\right)$ 刚好分得的是正确的2 组</p><h1 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h1><p>对于一个有向图 有起点S、终点T, 计算从S到T的最大流量。</p><p>例如这是一种流：</p><p><img src="/2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/flow.png" style="zoom:40%;"></p><font color="red">对于给定S和T的图，最大割与最小流相等,证明略</font><h2 id="Fold-Fulkerson-Algorithm"><a href="#Fold-Fulkerson-Algorithm" class="headerlink" title="Fold-Fulkerson Algorithm"></a>Fold-Fulkerson Algorithm</h2><p>核心：<font color="red">构建Residual Graph</font></p><p>起始于任意的一个flow</p><p>循环</p><p>​    构建residual graph</p><p>​    在redisual graph上寻找可能的更新path，</p><p>​        若不存在augment path证明目前的flow最大，结束。</p><p>​        若存在augment path, 更新flow。</p><p>结束</p><p><img src="/2022/05/23/%E6%9C%80%E5%B0%8F%E5%89%B2%E4%B8%8E%E6%9C%80%E5%A4%A7%E6%B5%81/Fold-Fulkerson.png" style="zoom:60%;"></p><font color="#A000A0">寻找augment path的方式:</font><ol><li>Non-full forward edges</li><li>Non -empty backward edges</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String Matching问题</title>
      <link href="2022/05/23/String-Matching%E9%97%AE%E9%A2%98/"/>
      <url>2022/05/23/String-Matching%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>对于给定的两个字符串 <em>S1</em> 和 <em>S2</em> 将2个字符串进行匹配解决：S2是否是S1 的子字符串？S2和S1 如何进行“对齐”使得2个字符串最接近？等问题</p><p>最直接以及常见的使用场景例如：查询 DNA上是否含有某个基因，2个DNA是否有相似的片段（可能是相似的基因）</p><p><img src="/2022/05/23/String-Matching%E9%97%AE%E9%A2%98/cover.png" style="zoom:20%;"></p><a id="more"></a><h1 id="完美匹配问题（Matching）"><a href="#完美匹配问题（Matching）" class="headerlink" title="完美匹配问题（Matching）"></a>完美匹配问题（Matching）</h1><p>问题：检测长度为n 的字符串T 上是否含有长度为m的字符串P</p><p>Input: T, P</p><p>Output: 首个matching的index</p><p><strong>Sample Input:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">abcabcabdabba</span><br><span class="line">abcabd</span><br></pre></td></tr></table></figure><p><strong>Sample Output:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="匹配问题采用Knuth-Morris-Pratt-KMP算法。"><a href="#匹配问题采用Knuth-Morris-Pratt-KMP算法。" class="headerlink" title="匹配问题采用Knuth-Morris-Pratt KMP算法。"></a>匹配问题采用<strong>Knuth-Morris-Pratt KMP算法</strong>。</h2><p>Multivating brute-force algorithm:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i &#x3D; 1:n:</span><br><span class="line">for j&#x3D;1:m</span><br><span class="line">if s1[i+j] !&#x3D;s[j]:</span><br><span class="line">     break</span><br><span class="line">  end</span><br><span class="line">  print(i)</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这必然会造成重复计算，如何理解？ 我们首先拆分暴力算法的思路：</p><p>1）在S1位置上循环i = 0…n</p><p>2）在每个i位置上开始循环 比对 T与P</p><p>3）如果我们重复到j发现不重复了 然后在i+1位置上从头开始尝试是否匹配。</p><p>第3步就是我们复杂度高的来源，<font color="#8A2BE2">我们不需要从i到i+1的时候从头把j从0开始重新计算</font>:</p><p><img src="/2022/05/23/String-Matching%E9%97%AE%E9%A2%98/example1.png" alt="image-20220531152652470" style="zoom:30%;"></p><p>那么从j=？ 重新开始呢？假设在T[i]处 已经匹配了p位，那么只需要找到一个k使得 P[1:k]为 P[p-k:p]也即<font color="#8FA0000">“后缀是前缀”</font></p><p>KMP算法分两步：</p><p>1） 构建一个索引：given任意位置，找出最大的<font color="#8FA0000">“后缀是前缀”</font></p><p><img src="/2022/05/23/String-Matching%E9%97%AE%E9%A2%98/example2.png" alt="image-20220531152652470" style="zoom:50%;"></p><p>2）用这个索引进行逐个的检索</p><p>code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 构建索引next[m]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_next</span><span class="params">(<span class="built_in">string</span> P,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = P.length();</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;   <span class="comment">// initialization</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// number of character matched</span></span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(q&lt;m)&#123;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;<span class="number">0</span> <span class="keyword">and</span> P[k] != P[q])&#123;</span><br><span class="line">            k = next[k<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P[k] == P[q]) k=k+<span class="number">1</span>;</span><br><span class="line">        next[q] = k;</span><br><span class="line">        </span><br><span class="line">        q++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#given next[m] 进行T上search P</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP_search</span><span class="params">(<span class="built_in">string</span> T,<span class="built_in">string</span> P )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = P.length();</span><br><span class="line">    <span class="keyword">int</span> n = T.length();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> next[m];</span><br><span class="line">    compute_next(P, next);</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(q&gt;<span class="number">0</span> <span class="keyword">and</span>  P[q]!= T[i])&#123;</span><br><span class="line">            q = next[q<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(P[q] == T[i])&#123;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q == m)&#123;</span><br><span class="line">            <span class="keyword">return</span> i-m+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="对齐问题-Alignment"><a href="#对齐问题-Alignment" class="headerlink" title="对齐问题(Alignment)"></a>对齐问题(Alignment)</h1><p>想想这样一个问题，有2个string A 和B，把B改为A可以有以下几个操作：</p><p>◦ Replace a letter with another letter 改<br>◦ Insert a letter 删<br>◦ Delete a letter 插入</p><p>所以需要找到一个对齐方式例如：</p><p><img src="/2022/05/23/String-Matching%E9%97%AE%E9%A2%98/example4.png" alt="image-20220531152652470" style="zoom:30%;"></p><p>使得修改的cost最小，为此我们首先定义每一个对齐之后修改的“得分”：</p><p>每处的得分为:</p><p>$\delta(delete),\delta(modify),\delta(insert)$</p><p>使用dp算法解决问题：</p><p>Recurrence: For $\mathrm{i}&gt;0, \mathrm{j}&gt;0$</p><script type="math/tex; mode=display">V(i, j)=\max \left\{\begin{array}{cl}V(i-1, j-1)+\delta(S[i], T[j]) & \text { Match/mismatch } \\V(i-1, j)+\delta(S[i],) & \text { Delete } \\V(i, j-1)+\delta(\ldots T[j]) & \text { Insert }\end{array}\right.</script>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纸 绳索 身影</title>
      <link href="2022/04/17/%E8%BA%AB%E5%BD%B1/"/>
      <url>2022/04/17/%E8%BA%AB%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2022/04/17/%E8%BA%AB%E5%BD%B1/cover.png" style="zoom:20%;"></p><p><em>昨夜如梦，像流星划过，忘了他，忘了那双手所干过的一切</em></p><p><em>我再也不会像从前那样玩世不恭，再也不会像从前那样爱你，</em></p><p><em>突然有一天我醒了，看着外面一片白云，火车低低地飞过，一片叶子掉下来，</em></p><p><em>我感觉到一切在生长，一切又在衰老，一切就像你，一切就像我，一切只是一场梦，我再也找不到那些时光。</em></p><p><em>杀死他，再给他一刀，</em></p><p><em>开枪吧，</em></p><p><em>杀了他，干了他，</em></p><p><em>我就还不信了，还不信呢，杀了他！嘿！</em></p><a id="more"></a><iframe width="560" height="315" src="https://www.youtube.com/embed/fKYfH3N9KzA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      
      
      
        <tags>
            
            <tag> 李志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神坛跌向老头环（一）</title>
      <link href="2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/"/>
      <url>2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><video width="350" class="AssetMedia--video" controls="controls" controlslist="nodownload" loop playsinline preload="metadata" style="border-radius: initial;"><source data-testid="AssetMedia--video" src="https://res.cloudinary.com/dno1beosk/video/upload/v1650805856/elden_ring_rt1gwz.mp4" type="video/mp4"></video><p><em>「黄金树的叶子落下，艾尔登法环破碎，永恒女王玛丽卡不见踪迹，黑刀之夜黄金君主被刺杀，之后半神们开始争夺法环的碎片，但是这场战争并没有产生新的 王者，也导致了这个世界开始被伟大意志抛弃。这时，褪色者失落已久的赐福开始发出召唤，数个成名已久的褪色者，以及无名的我们，穿过雾海，回到了交界 地，去争夺艾尔登之王的位置」</em></p><a id="more"></a><p>​    在游戏发售前抢到了体验服网测资格，有幸在网测服当了5分钟白狼战鬼。可恨的是拿到实体盘刚下载完补丁，ps5就过热烧主板返修。一通折腾最终在3月底玩到了老头环，一周目高强度法爷逃课后轻松白金了。截止20220415 一周目全结局，但只是为了刷全成就，大部分支线都没有体验，计划在后面的周目补。第一篇的blog主要总结下我对游戏的感受以及比较认可的主线历史。</p><p><img src="/2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/PS成就.png" style="zoom:20%;"></p><h1 id="游玩感想"><a href="#游玩感想" class="headerlink" title="游玩感想"></a>游玩感想</h1><p>TBH, 在玩之前我是有点担心自己电子ED情况。对比黑魂和只狼，我更欣赏只狼的美术以及叙述方式（不太魂），感觉叙述以及展现方式更为东方。黑魂只玩了20个小时就弃坑了。根据泄露的资料，环简直可以说是魂3的开放世界dlc，并且我个人对于开放世界也有点发怵，我不喜欢满地图地做任务。我更喜欢tlou、战神这样的精致线性箱庭游戏。在真正开机之前，我很有点担心自己会不会玩不下去老头环。但在真正上手游玩之后发现自己的担心完全是多余的。个人认为环比魂让我更有玩下去的动力如下</p><ol><li><strong>热度：</strong> 毋庸置疑，1200w的销量，对于相对小众的魂游戏只能说离谱。有能一起讨论的社区、朋友无疑极大增加了我对这个庞大复杂世界探索的欲望。</li><li><strong>开放世界真他妈做得好:</strong> 无引导开放世界就是开放世界的神！<strong>婊子才会在地图上塞满问号来勾引你去探索</strong>，真男人的地图真的就只是一张地图。</li><li><strong>马丁YYDS</strong>： 纯个人偏好，我很喜欢这次的剧情演出，各种势力的勾结、阴谋、背叛、巧合，这些马丁擅长构造的东西配上魂的叙述方式再合适不过。</li></ol><h1 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h1><p>在开始之前，先回答一下剧情里玩家扮演的角色：首先艾尔登法环是以巨量卢恩铸造的一个“律法”具现化道具，它就是律法的载体。</p><p>在“黄金律法”中，存在着三大定理——回归、因果、存在。其中回归定理便是任何生命都不会死亡，所有流逝的生命皆会回归黄金大树。所以在黑刀之夜，作为拥有神之血脉的黄金王子葛德温与菈妮的死，直接导致了“黄金律法”出现问题，具体的情况也表现为世界中出现了很多死诞者。</p><p>在不断尝试自我修复的过程中，艾尔登法环产生了裂痕，乃至最后被玛丽卡女王直接击碎。随后出现了破碎战争，众半神为争夺艾尔登法环的碎片——大卢恩而战。玩家则是破碎战争之后来到了这片交界地，遵循双指的指引，觐见女王，修复艾尔登法环，成为新的艾尔登之王。</p><p>艾尔登法环的故事发生之地名为“交界地”，在上古时代这片大地存在着许多种族。地面上的龙信仰着龙神，地面下的祖灵之民信仰着祖灵，永恒之城的居民信仰着宵色瞳孔的女神，其中迁徙而出的后裔们信仰着月亮，位于火山的蛇人崇拜着大蛇，位于雪山的巨人们信仰着“独眼的邪神”。</p><p>生命熔炉的力量是以黄金树代表的熔炉百相，即生命与生命之间的距离并没有太过绝对，人也能够拥有龙的特征，所以熔炉骑士能够使用龙甩尾来攻击我们，蛇也能够拥有人的特征，所以火山官邸有着一群蛇人原住民。而命定之死的力量属于“宵色瞳孔的女王”，生命自熔炉诞生，由命定之死又送回熔炉，就像太极中的两仪，相生相克，周而复始。</p><h2 id="上古"><a href="#上古" class="headerlink" title="上古"></a>上古</h2><p>龙族统治的时代，当时的神统御着风暴的法则。关于这一时期的历史记载非常稀少，据说四头龙普拉顿桑克斯是巨龙族的首领，也是交界地的古王。</p><p><img src="/2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/dragon_king.jpeg" alt="dragon" style="zoom:30%;"></p><p>但龙族信仰的神不知为何突然消失了，龙族的势力也逐渐衰退。龙族的栖息地法姆·亚兹拉也日渐崩坏。</p><p><img src="/2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/法姆·亚兹拉.jpeg" alt="dragon"></p><p>龙王作为远古的艾尔登之王，也是奉承神祇之力的风暴王。龙族在大地上名为宁姆格福的地方修建了一座宏伟的大城堡，作为统治交界地的桥头堡。这座大城堡便是风暴山丘上的史东威尔城（Storm veil）。这个音译方式我直呼离谱，推荐改名风息堡。</p><h2 id="无上意志降临"><a href="#无上意志降临" class="headerlink" title="无上意志降临"></a>无上意志降临</h2><p>龙王的统治持续了很长时间，直到艾尔登流星的降临，为它和古龙的时代画上句号。一股世界之外的力量——无上意志，将一颗巨大的黄金流星连同在内的奇异造物，即「艾尔登之兽」送往了交界地。这颗流星坠落在现在称为「亚坛高原」的地方。</p><p><img src="/2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/流星.jpeg" alt="dragon" style="zoom:50%;"></p><p>随着黄金流星而来的还有无上意志的代言人——双指。双指能言善道，会在空中画出秘文。祂们就像执行洗礼的祭司，其使命是在人间选出具有成为艾尔登之兽宿主的潜力的人类（这些被选中的候选者被称为「神人」）。因为艾尔登之兽便是「艾尔登法环」——无上意志的律法之具象化。容纳了艾尔登之兽（即艾尔登法环）的神人将成为无上意志在人间的象征，作为律法的容器，君临交界地。</p><p>无上意志选择了“稀人”（指代外来民族）玛丽卡作为它的代言人，击败了宵色眼眸女王并封印了命定之死。永恒女神玛丽卡借助艾尔登法环的力量构造了黄金律法，至此生命不再死亡而是回归黄金树，人人都能获得黄金树的赐福。真神玛丽卡主掌教权，在战争中表现英勇的蛮族战士葛孚雷被玛丽卡选为配偶称为艾尔登之王主掌政权，政教合一的国度正式拉开序幕，黄金时代降临。</p><h2 id="巨人战争"><a href="#巨人战争" class="headerlink" title="巨人战争"></a>巨人战争</h2><p>黄金树不会允许威胁到自己存在的事物存在，它开始了长期的征伐。位于王城罗德尔北方寒冷的的巨人山顶，有着无法熄灭的灰火。火是能对黄金树造成威胁的事物，于是葛孚雷奉命出征，攻打北方巨人的国度。</p><p>巨人们并不是鼎盛时期黄金王朝的对手，在崇拜的邪神也倒在真神玛莉卡面前时，巨人们向黄金势力投降。既然熄灭不了灰火，玛莉卡决定派遣一个受诅咒的火焰巨人看守灰火，将除火焰巨人之外，所有巨人的肚子上能喷射火焰的器官通通剜去，戴上镣铐，要么作为人体试验材料，要么作为奴隶。（所以我们在游戏中看见的巨人胸口都有一个大大的空洞，那是被活生生剜出来的）</p><p>但在同一时刻，不知为何古龙也发动了对王城罗德尔的突然袭击，对黄金王朝造成打击，我们至今仍可以看见留在王城内的巨大龙尸。</p><h2 id="噩兆"><a href="#噩兆" class="headerlink" title="噩兆"></a>噩兆</h2><p>真神玛丽卡的所作所为似乎遭受到了诅咒，第一个完整的孩子黄金王子<strong><em>葛德温</em></strong>出生之后，她与葛孚雷的子嗣都遭受到了诅咒，孪生兄弟蒙葛特与蒙格便是第一批遭受诅咒的孩子（或许叫他们“恶兆”与“鲜血君王”会比较亲切）。玛莉卡的子嗣们自出生开始便脸上长角，成为了“恶兆之子”。</p><p><img src="/2022/04/15/%E7%A5%9E%E5%9D%9B%E8%B7%8C%E5%90%91%E8%80%81%E5%A4%B4%E7%8E%AF/噩兆.jpeg" alt="dragon" style="zoom:50%;"></p><p>之所以我认为生命熔炉与黄金树并不是一体，最根本原因便是在此，“恶兆之子”明显是生命熔炉的祝福，但是在否定了生命熔炉的黄金时代，黄金树没有任何理由会让神的继任者出现“恶兆”。所以只能解释为，生命熔炉在葛德温之后，便与玛莉卡为代表的黄金树派系分道扬镳，它或许被压制，但是依然在诅咒着黄金王室的血脉。证据便是在王城地下，有着一个名叫”弃置恶兆的下水道“的地方，这里有许许多多身上长角的”恶兆之子“。这些“胖哥哥”或许就是玛丽卡与葛孚雷无数次尝试后，所诞生的“恶兆之子”们。为了不公布于众，玛莉卡将被生命熔炉祝福的孩子们抛弃在了王朝地下水道中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匈牙利算法</title>
      <link href="2021/12/05/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
      <url>2021/12/05/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hungarian-Algorithm"><a href="#Hungarian-Algorithm" class="headerlink" title="Hungarian Algorithm"></a>Hungarian Algorithm</h1><p>The <strong>Hungarian matching algorithm</strong> , also called the Kuhn-Munkres algorithm, is a $O\big(|V|^3\big)$algorithm that can be used to find maximum-weight matchings  in bipartite graphs , which is sometimes called the <strong>assignment problem</strong> . A bipartite graph can easily be represented by an adj matrix, where the weights of edges are the entries. Thinking about the graph in terms of an adjacency matrix is useful for the Hungarian algorithm.</p><a id="more"></a><h2 id="The-Hungarian-Algorithm-for-Graphs"><a href="#The-Hungarian-Algorithm-for-Graphs" class="headerlink" title="The Hungarian Algorithm for Graphs"></a><strong>The Hungarian Algorithm for Graphs</strong></h2><p>Given: the labeling $l$, an equality graph $G_l=(V, E_l)$, an initial matching $M$ in $G_l$, and an unmatched vertex $u \in V$ and $u \notin M$</p><h3 id="Augmenting-the-matching"><a href="#Augmenting-the-matching" class="headerlink" title="Augmenting the matching"></a>Augmenting the matching</h3><ol><li><p>A path is augmenting for $M$ in $G_l$ if it alternates between edges in the matching and edges not in the matching, and the first and last vertices are free vertices, or unmatched, in $M$. We will keep track of a candidate augmenting path starting at the vertex $u$.</p></li><li><p>If the algorithm finds an unmatched vertex $v$, add on to the existing augmenting path $p$ by adding the $u$ to $v$ segment.</p></li><li><p>Flip the matching by replacing the edges in $M$ with the edges in the augmenting path that are not in $M$ (in other words, the edges in $\left.E_l-M\right)$.</p></li></ol><h3 id="Improving-the-labeling"><a href="#Improving-the-labeling" class="headerlink" title="Improving the labeling"></a>Improving the labeling</h3><ol><li>$S \subseteq X$ and $T \subseteq Y$, where $S$ and $T$ represent the candidate augmenting alternating path between the matching and the edges not in the matching.</li><li>Let $N_l(S)$ be the neighbors to each node that is in $S$ along edges in $E_l$ such that $N_l(S)={v \mid \forall u \in S:(u, v) \in E_l}$.</li><li>If $N_{l}(S)=T$, then we cannot increase the size of the alternating path (and therefore can’t further augment), so we need to improve the labeling.</li><li>Let $\delta_{l}$ be the minimum of $l(u)+l(v)-w(u, v)$ over all of the $u \in S$ and $v \notin T$.</li><li>Improve the labeling $l$ to $l^{\prime}$ :</li></ol><ul><li><p>If $r \in S$, then $l^{\prime}(r)=l(r)-\delta_{l}$,</p></li><li><p>If $r \in T$, then $l^{\prime}(r)=l(r)+\delta_{l}$.</p></li><li><p>If $r \notin S$ and $r \notin T$, then $l^{\prime}(r)=l(r)$.</p></li></ul><p>   $l^{\prime}$ is a valid labeling and $E<em>{l} \subset E</em>{l^{\prime}}$.</p><h3 id="Putting-it-all-together-The-Hungarian-Algorithm"><a href="#Putting-it-all-together-The-Hungarian-Algorithm" class="headerlink" title="Putting it all together: The Hungarian Algorithm"></a>Putting it all together: The Hungarian Algorithm</h3><ol><li>Start with some matching $M$, a valid labeling $l$, where $l$ is defined as the labelling $\forall x \in X, y \in Y \mid l(y)=0, l(x)=\max _{y \in Y}(w(x, y))$.</li><li>Do these steps until a perfect matching is found (when $M$ is perfect):</li></ol><ul><li>(a) Look for an augmenting path in $M$.</li><li>(b) If an augmenting path does not exist, improve the labeling and then go back to step (a).</li></ul><h2 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation:"></a>Python Implementation:</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">TOLERANCE = <span class="number">1e-6</span>  <span class="comment"># everything below is considered zero</span></span><br><span class="line">MAX = <span class="number">999999</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improveLabels</span>(<span class="params">val</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; change the labels, and maintain minSlack.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> u <span class="keyword">in</span> S:</span><br><span class="line">        lu[u] -= val</span><br><span class="line">    <span class="keyword">for</span> v <span class="keyword">in</span> V:</span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> T:</span><br><span class="line">            lv[v] += val</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            minSlack[v][<span class="number">0</span>] -= val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">improveMatching</span>(<span class="params">v</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; apply the alternating path from v to the root in the tree.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    u = T[v]</span><br><span class="line">    <span class="keyword">if</span> u <span class="keyword">in</span> Mu:</span><br><span class="line">        improveMatching(Mu[u])</span><br><span class="line">    Mu[u] = v</span><br><span class="line">    Mv[v] = u</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slack</span>(<span class="params">u,v</span>):</span> <span class="keyword">return</span> lu[u]+lv[v]-w[u][v]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">augment</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; augment the matching, possibly improving the lablels on the way.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># select edge (u,v) with u in S, v not in T and min slack</span></span><br><span class="line">        ((val, u), v) = <span class="built_in">min</span>([(minSlack[v], v) <span class="keyword">for</span> v <span class="keyword">in</span> V <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> T])</span><br><span class="line"><span class="comment">#         assert u in S</span></span><br><span class="line"><span class="comment">#         assert val &gt; - TOLERANCE</span></span><br><span class="line">        <span class="keyword">if</span> val &gt; TOLERANCE:</span><br><span class="line">            improveLabels(val)</span><br><span class="line">        <span class="comment"># now we are sure that (u,v) is saturated</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">abs</span>(slack(u,v)) &lt; TOLERANCE  <span class="comment"># test zero slack with tolerance</span></span><br><span class="line">        T[v] = u                            <span class="comment"># add (u,v) to the tree</span></span><br><span class="line">        <span class="keyword">if</span> v <span class="keyword">in</span> Mv:</span><br><span class="line">            u1 = Mv[v]                      <span class="comment"># matched edge,</span></span><br><span class="line">            <span class="keyword">assert</span> <span class="keyword">not</span> u1 <span class="keyword">in</span> S</span><br><span class="line">            S[u1] = <span class="literal">True</span>                    <span class="comment"># ... add endpoint to tree</span></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> V:                     <span class="comment"># maintain minSlack</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> v <span class="keyword">in</span> T <span class="keyword">and</span> minSlack[v][<span class="number">0</span>] &gt; slack(u1,v):</span><br><span class="line">                    minSlack[v] = [slack(u1,v), u1]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            improveMatching(v)              <span class="comment"># v is a free vertex</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxWeightMatching</span>(<span class="params">weights</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; given w, the weight matrix of a complete bipartite graph,</span></span><br><span class="line"><span class="string">        returns the mappings Mu : U-&gt;V ,Mv : V-&gt;U encoding the matching</span></span><br><span class="line"><span class="string">        as well as the value of it.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">global</span> U,V,S,T,Mu,Mv,lu,lv, minSlack, w</span><br><span class="line">    w  = weights</span><br><span class="line">    n  = <span class="built_in">len</span>(w)</span><br><span class="line">    V = <span class="built_in">range</span>(n)</span><br><span class="line">    U   = <span class="built_in">range</span>(n)</span><br><span class="line">    <span class="comment"># initialize the feasible vertex label.</span></span><br><span class="line">    lu = [ <span class="built_in">max</span>([w[u][v] <span class="keyword">for</span> v <span class="keyword">in</span> V]) <span class="keyword">for</span> u <span class="keyword">in</span> U]  </span><br><span class="line">    lv = [ <span class="number">0</span>                         <span class="keyword">for</span> v <span class="keyword">in</span> V]</span><br><span class="line">    Mu = &#123;&#125;                                      </span><br><span class="line">    Mv = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># choose a unmatched vertex u0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(Mu)&lt;n:</span><br><span class="line">        free = [u <span class="keyword">for</span> u <span class="keyword">in</span> U <span class="keyword">if</span> u <span class="keyword">not</span> <span class="keyword">in</span> Mu]      </span><br><span class="line">        u0 = free[<span class="number">0</span>]</span><br><span class="line">        S = &#123;u0: <span class="literal">True</span>&#125;                           </span><br><span class="line">        T = &#123;&#125;</span><br><span class="line">        minSlack = [[slack(u0,v), u0] <span class="keyword">for</span> v <span class="keyword">in</span> V]</span><br><span class="line">        augment()</span><br><span class="line"></span><br><span class="line">    val = <span class="built_in">sum</span>(lu)+<span class="built_in">sum</span>(lv)</span><br><span class="line">    <span class="keyword">return</span>  val</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的心在示波器上跳动</title>
      <link href="2021/12/01/%E6%88%91%E7%9A%84%E5%BF%83%E5%9C%A8%E7%A4%BA%E6%B3%A2%E5%99%A8%E4%B8%8A%E8%B7%B3%E5%8A%A8/"/>
      <url>2021/12/01/%E6%88%91%E7%9A%84%E5%BF%83%E5%9C%A8%E7%A4%BA%E6%B3%A2%E5%99%A8%E4%B8%8A%E8%B7%B3%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我想我现在应该前进了，在将来的某个时刻创造些美好的东西。</p><a id="more"></a><p>我只要还有一点感情，就无法不期待获得对方的感情，不论是爱还是憎。</p><p>我感觉到一切正在生长，一切又在衰老。</p><p>意识到有些事情可能正在发生或者是已经发生</p><p>预感不到具体是什么事情，大概就是有这样一个意识，突然觉得生活好像是有点不一样。</p><p>肉麻的东西无论如何不该被赞美。</p><p>对一切充满了智慧的体系，不管是哲学还是数学，只要他深刻周密，我就对他抱有审美式的爱好。</p><p>我顶喜欢的是自理生活，理成一塌糊涂也罢。</p><p>过去我们在顶礼膜拜中度过光阴时，我们知道什么是生活么？</p><p>在台风中央平静地迎接我的死亡。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 歪诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paper Reading</title>
      <link href="2021/11/28/Parallel%20Lottery/"/>
      <url>2021/11/28/Parallel%20Lottery/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Parallel-Lottery"><a href="#Parallel-Lottery" class="headerlink" title="Parallel Lottery"></a>Parallel Lottery</h1><p><a href="https://pubsonline.informs.org/doi/10.1287/mnsc.2021.4120">Parallel Lotteries: Insights from Alaskan Hunting Permit Allocation</a></p><p><a href="https://pubsonline.informs.org/action/doSearch?text1=Arnosti%2C+Nick&amp;field1=Contrib">Nick Arnosti</a>, <a href="https://pubsonline.informs.org/action/doSearch?text1=Randolph%2C+Tim&amp;field1=Contrib">Tim Randolph</a></p><a id="more"></a><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction:"></a>Introduction:</h1><p>Analyze the parallel lottery that is used to allocate <strong>heterogeneous resources to unit-demand agents.</strong></p><p><img src="/2021/11/28/Parallel%20Lottery/Untitled.png" alt="Untitled" style="zoom:50%;"></p><h1 id="Notation-and-Preliminary"><a href="#Notation-and-Preliminary" class="headerlink" title="Notation and Preliminary"></a>Notation and Preliminary</h1><ol><li>$n$ types of items with quantities $\mu=\left(\mu<em>{1}, \mu</em>{2}\right.\left.\ldots, \mu<em>{n}\right) \in \mathbb{R}</em>{+}^{n} .$ </li><li>Mass $M$ of agents. </li><li>Each agent is identified by a type $v=\left(v<em>{1}, v</em>{2}, \ldots v_{n}\right) \in \mathbb{R}^{n}$ </li></ol><p><strong>Single agent decision problem:</strong></p><p>Given strategy $s$ and win probabilities $p$. </p><ul><li>$s_i$: number of tickets an agent puts on item i.</li><li>$p_i$: Probability of draw a ticket of item i.</li></ul><p>$\chi(s, p)=\left{\chi<em>{i}(s, p)\right}</em>{i=1}^{n}$  summaries the probability of winning each object</p><script type="math/tex; mode=display">\begin{equation}\chi_{i}(s, p):=\left(1-\left(1-p_{i}\right)^{s_{i}}\right) \prod_{j>i}\left(1-p_{j}\right)^{s_{j}}\end{equation}</script><script type="math/tex; mode=display">w(v, s, p):=v \cdot \chi(s, p)</script><p>Optimal Strategy： Greedy Algorithm</p><p><strong>K-Equilibrium</strong></p><p>Consider k ticket <strong>strategy profile</strong> $\Phi(v) = s^k$  ($\sum(s_i) = k$)</p><p>For any k parallel lottery there exists <strong><strong>k-ticket </strong></strong>equilibrium pair $(\Phi, p)$ </p><h1 id="Equilibrium-Efficiency-Analysis"><a href="#Equilibrium-Efficiency-Analysis" class="headerlink" title="Equilibrium Efficiency Analysis"></a>Equilibrium Efficiency Analysis</h1><p>Allocation x is α-Pareto efficient if for every feasible allocation y  ($\alpha\geq 1$).</p><script type="math/tex; mode=display">\begin{equation}\eta\left(\left\{v: \frac{y(v) \cdot v}{x(v) \cdot v} \leq \alpha .\right\}\right)>0\end{equation}</script><p><strong>Theorem 1:</strong> Any equilibrium of the  k-ticket parallel lottery is  $\frac{1}{\left(1-\left(1-\frac{1}{k+1}\right)^{k}\right)}$-Pareto efficient.</p><p>(This converges to $\frac{e}{e-1}$)</p><p>Theorem 1 gives the bound of the inefficiency f k-parallel but didn’t provide any insight into such inefficiency.</p><h2 id="2-types-of-Inefficiency"><a href="#2-types-of-Inefficiency" class="headerlink" title="2 types of Inefficiency"></a>2 types of Inefficiency</h2><h3 id="Trade-Reallocation-Trade-Efficiency"><a href="#Trade-Reallocation-Trade-Efficiency" class="headerlink" title="Trade Reallocation(Trade Efficiency)"></a>Trade Reallocation(Trade Efficiency)</h3><p> A trade reallocation of $x$ is a feasible allocation $y$ such that $\int x(v) d \eta=\int y(v) d \eta$. </p><p>Allocation $x$ is $<strong>\alpha$-trade efficient</strong> if for any $y$ that is a trade reallocation of $x$,  (2) holds. </p><p>An allocation is trade efficient if it is 1-trade efficient</p><p>Any k-ticket equilibrium is $\frac{1}{\left(1-(1-1 / k)^{k}\right)}$-trade efficient.</p><h3 id="Waste-Reallocation-Wasteful-Efficiency"><a href="#Waste-Reallocation-Wasteful-Efficiency" class="headerlink" title="Waste Reallocation(Wasteful Efficiency)"></a>Waste Reallocation(Wasteful Efficiency)</h3><p>A waste reallocation of $x$ is a feasible allocation $y$ such that for every $v$ and every $i$ that is fully allocated under $x, y<em>{i}(v) \leq x</em>{i}(v)$. </p><p>Allocation $x$ is $\epsilon$-wasteful if for any $y$ that is a waste reallocation of $x$, and any $v$, $(v \cdot y(v)) /(v \cdot x(v)) \leq 1+\epsilon .$ </p><p>An allocation is non-wasteful if it is 0-wasteful.</p><p>Any k-ticket equilibrium is $\frac{1}{k}$-waste efficient.</p><h1 id="Effect-of-changing-K"><a href="#Effect-of-changing-K" class="headerlink" title="Effect of changing K"></a>Effect of changing K</h1><p>Only 2 items and we use $v = \frac{v_2}{v_1}$ to denote the agent’s type.  </p><p>Proposition 1  </p><p>With most people strongly prefer item 1($v\ll1$) and some agents nearly indifferent($v\approx1$). </p><p>If $\mu_1+\mu_2 &gt;1$ then in  every non-wasteful and envy-free allocation. Every agent gets an item and item 1 is allocated randomly to those who prefer item 1.(when $k\rightarrow \infty$ the equilibrium behave like this)</p><p>Proposition 2</p><p>Agents with Strong Preferences Prefer Smaller k.</p><p>Example:</p><p><img src="/2021/11/28/Parallel%20Lottery/Untitled%201.png" alt="Untitled" style="zoom:50%;"></p><ul><li><strong><em>Tradeoff Regime:</em></strong>  Increase k befits agent to compete for under demanded items  and hurt agents with strong preference.</li><li><strong><em>Waste Trap Regime:</em></strong> If most agents strongly prefer item 1 then small k will not reduce competition but just cost more waste.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paper Reading</title>
      <link href="2021/11/24/Regulation/"/>
      <url>2021/11/24/Regulation/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Robust-Monopoly-Regulation-AER-RR"><a href="#Robust-Monopoly-Regulation-AER-RR" class="headerlink" title="Robust Monopoly Regulation(AER RR)"></a>Robust Monopoly Regulation(AER RR)</h1><p>Yingni Guo ，Eran Shmaya</p><a id="more"></a><h2 id="1-Introduction-amp-Environment"><a href="#1-Introduction-amp-Environment" class="headerlink" title="1 Introduction &amp; Environment"></a>1 Introduction &amp; Environment</h2><p>There is a monopolistic firm and a mass one of consumers.</p><p> <strong>Inverse-demand function:</strong> </p><p>​        $V:[0,1] \rightarrow[0, \bar{v}]$    </p><p>​        A quantity-price pair $(q, p) \in [0,1] \times[0, \bar{v}]$ is feasible if and only if it is below the inverse-demand function, i.e., $p \leqslant V(q)$.<br>​        The total value to consumers of quantity $q$ is the area under the inverse-demand function given by $\int_{0}^{q} V(z) \mathrm{d} z$</p><p><strong>Optimal total surplus:</strong> </p><script type="math/tex; mode=display">\operatorname{OPT}(V, C)=\max _{q \in[0,1]}\left(\int_{0}^{q} V(z) \mathrm{d} z-C(q)\right)</script><p><strong>Distortion of total surplus(with quantity q):</strong></p><script type="math/tex; mode=display">\operatorname{DSTR}(V, C, q)=\operatorname{OPT}(V, C)-\left(\int_{0}^{q} V(z) \mathrm{d} z-C(q)\right)</script><p><strong>Regulatory policies:</strong></p><p>​            Revenue of the firm: $\rho(q, p)$</p><ol><li>subsidy : $\rho(q, p) = qp + s$​</li><li>tax: $\rho(q, p) = qp - t$</li><li>price cap:  $\rho(q, p) =\min (q p, q k)$</li></ol><p><strong>Consumer surplus and Firm payoff : </strong></p><script type="math/tex; mode=display">\mathrm{CS}(V, \rho, q, p)=\int_{0}^{q} V(z) \mathrm{d} z-\rho(q, p)\\\mathrm{FP}(V, C, \rho, q, p)=\rho(q, p)-C(q)</script><h2 id="2-Problem"><a href="#2-Problem" class="headerlink" title="2 Problem"></a>2 Problem</h2><p>​    The regulator’s payoff is a wseighted sum: $CS + \alpha FP, \alpha \in (0,1)$​</p><p><strong>Complete Information Payoff :</strong></p><script type="math/tex; mode=display">\operatorname{CIP}(V, C)=\max _{\rho, q, p}(\operatorname{CS}(V, \rho, q, p)+\alpha \mathrm{FP}(V, C, \rho, q, p))</script><p><strong>Proposition 1:</strong></p><script type="math/tex; mode=display">\mathrm{CIP}(V, C)=\mathrm{OPT}(V, C)</script><script type="math/tex; mode=display">\rho(q, p)=\left\{\begin{array}{ll}C\left(q^{*}\right) & \text { if }(q, p)=\left(q^{*}, V\left(q^{*}\right)\right) \\0 & \text { otherwise }\end{array}\right.</script><p><strong>Regret:</strong></p><script type="math/tex; mode=display">\operatorname{RGRT}(V, C, \rho, q, p)=\operatorname{CIP}(V, C)-(\operatorname{CS}(V, \rho, q, p)+\alpha \mathrm{FP}(V, C, \rho, q, p))</script><script type="math/tex; mode=display">\begin{aligned} \mathrm{RGRT} &=\mathrm{CIP}-(\mathrm{CS}+\alpha \mathrm{FP})=\mathrm{OPT}-(\mathrm{CS}+\alpha \mathrm{FP}) \\ &=\mathrm{OPT}-(\mathrm{CS}+\mathrm{FP})+(1-\alpha) \mathrm{FP} \\ &=\mathrm{DSTR}+(1-\alpha) \mathrm{FP} \end{aligned}</script><script type="math/tex; mode=display">\underset{\rho}{\operatorname{minimize}} \max _{V, C, q, p} \operatorname{RGRT}(V, C, \rho, q, p)</script><h2 id="3-Main-Result"><a href="#3-Main-Result" class="headerlink" title="3 Main Result"></a>3 Main Result</h2><h3 id="Price-Cap-k"><a href="#Price-Cap-k" class="headerlink" title="Price Cap k"></a>Price Cap k</h3><p><img src="/2021/11/24/Regulation/sample.png" alt="image-20210806094741252"></p><p>$k_{\alpha}=\frac{\bar{v}}{2-\alpha}$</p><p><strong>Proposition 2：</strong>The worst-case regret under any policy is at least $(1-\alpha) k_{\alpha}=\frac{1-\alpha}{2-\alpha} \bar{v}$.</p><p><strong>Theorem 1:</strong></p><p><strong>Lower bound on worst-case regret:</strong></p><script type="math/tex; mode=display">r_{\alpha}=\max _{q \in[0,1], p \in\left[0, k_{\alpha}\right]} \min \left(q(1-\alpha) k_{\alpha}-q p \log q, q\left(k_{\alpha}-p\right)\right)</script><script type="math/tex; mode=display">r_{\alpha}=\bar{v}\left\{\begin{array}{ll}\frac{1-\alpha}{2-\alpha} & \alpha \leqslant \frac{1}{2} \\\frac{(2+\alpha-\sqrt{\alpha(\alpha+4)}) e^{1-\frac{\alpha+\sqrt{\alpha(\alpha+4)}}{2}}}{2(2-\alpha)} & \alpha>\frac{1}{2} .\end{array}, \quad q_{\alpha}=\left\{\begin{array}{ll}1, & \text { if } \alpha \leqslant 1 / 2 \\e^{1-\frac{\alpha+\sqrt{\alpha(\alpha+4)}}{2}}, & \text { if } \alpha>1 / 2\end{array}\right.\right.</script><p><strong>Theorem 2 (Optimal policy).</strong> Let</p><script type="math/tex; mode=display">s_{\alpha}=\sup \left\{q\left(k_{\alpha}-p\right): q \in[0,1], p \in\left[0, k_{\alpha}\right], q(1-\alpha) k_{\alpha}-q p \log q>r_{\alpha}\right\}</script><p>The policy</p><script type="math/tex; mode=display">\rho(q, p)=\min \left(q k_{\alpha}, q p+s\right)</script><p>with $s<em>{\alpha} \leqslant s \leqslant r</em>{\alpha}$ achieves the worst-case regret $r_{\alpha}$.</p><p>$s<em>{\alpha}=\left{\begin{array}{ll}\bar{v} \frac{\alpha}{2-\alpha} &amp; \text { if } \alpha \leqslant \frac{1}{2} \ r</em>{\alpha} &amp; \text { if } \alpha&gt;\frac{1}{2}\end{array}\right.$</p><p><strong>Theorem 3:</strong> Let $\rho$ be an optimal policy. Then</p><ol><li>(Price cap): $\rho(q, p) \leqslant q k<em>{\alpha}$ for every $q \leqslant q</em>{\alpha}$.</li><li><p>(Subsidy): There exists some $(q, p)$ such that $\rho(q, p) \geqslant q p+s_{\alpha}$.</p></li><li><p>(Subsidy cap): $\rho(q, p) \leqslant q p+r_{\alpha}$​ for every $(q, p)$</p></li></ol><p>Trade off between 3 parts:</p><ol><li><p>Giving more surplus to consumer(Surplus redistribution)</p><p>体现在price cap设置上，price cap 限制monopoly firm cannot get more than $k_\alpha$​ from consumer.</p></li><li><p>Underproduction</p><p>For low quantity, subsidy is piece-rate increasing, incentivize the firm to producemore.</p></li><li><p>Overproduction</p><p>The subsidize is capped , so the potential overproduction is under control.</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深北莫算法与Quasi-Newton</title>
      <link href="2021/11/18/%E6%B7%B1%E5%8C%97%E8%8E%AB%E7%AE%97%E6%B3%95%E4%B8%8EQuasi-Newton/"/>
      <url>2021/11/18/%E6%B7%B1%E5%8C%97%E8%8E%AB%E7%AE%97%E6%B3%95%E4%B8%8EQuasi-Newton/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    优化课与同学尝试BFGS的参数选择讨论到12点@_@, 回宿舍路上口瓢把SMBU（深北莫）也读成了BFGS。觉得深北莫算法这“雅号”比BFGS更透着一股亲近感。as</p><p><img src="/2021/11/18/%E6%B7%B1%E5%8C%97%E8%8E%AB%E7%AE%97%E6%B3%95%E4%B8%8EQuasi-Newton/intro.jpeg" style="zoom:33%;"></p><a id="more"></a>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>如何反驳那些认为圣诞老人不存在的幼稚的人们</title>
      <link href="2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/"/>
      <url>2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>圣诞老人是存在的！</p><a id="more"></a><p>“<a href="http://www.guokr.com/article/3908/">圣诞怪谈</a>”中，“圣诞公公不存在”被证实为谣言：</p><blockquote><p>根据大量的历史数据以及 NORAD过去50 多年来追踪圣诞老人所收集的信息，我们坚信圣诞老人确定一定以及肯定是存在的…如今，NORAD使用四种高科技手段：雷达、卫星、Santa Cam和喷气式战斗机，来追踪圣诞老人…圣诞夜当晚，NORAD会为我们传来圣诞老人带着他的驯鹿环游世界的图像和视频…</p></blockquote><p>但是，小朋友们，虽然这更加坚定了你心中“圣诞老人存在”的信念，可如果依然有可恶的幼稚的无趣的人说“那些都是骗人的，哄小孩的，明明就没有圣诞老人”，你还是不能只凭这些来反驳。想让他们哑口无言，看看下面的教学吧（原图自<a href="http://survivingtheworld.net/">Surviving the World</a>）。</p><h2 id="圣诞老人的存在性"><a href="#圣诞老人的存在性" class="headerlink" title="圣诞老人的存在性"></a>圣诞老人的存在性</h2><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/1.jpeg" alt="img" style="zoom:50%;"></p><p>真的有圣诞老人哦</p><p>不要理那些可恶的“大孩子”们说的话</p><p>圣诞老人当然存在了！！</p><p>事实上证明这件事一点儿也不难</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/2.jpeg" alt="img" style="zoom:50%;"></p><p>首先呢，你要明白有无数多个宇宙同时存在</p><p>（小朋友们，这一点很好理解吧- __,-）</p><p>多到你根本记不住在多少个宇宙里你喷了香体喷剂，</p><p>多少个宇宙里你忘了喷，或者多少个你甚至连腋窝都没有（囧）</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/2.jpeg" alt="img" style="zoom:50%;"></p><p>所以，这就意味着圣诞老人不仅是存在的，</p><p>而且还可能有宇宙总数的一半那么多个！</p><p>（某些<a href="http://www.guokr.com/article/3914/">死理性派</a>是不是以为圣诞老人只有一个呢）</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/4.jpeg" alt="img" style="zoom:50%;"></p><p>“但是，哼哼”，某些人会说，</p><p>“就算是有一半的宇宙里存在着圣诞老人，我们也在那些圣诞老人不存在的宇宙里。”</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/5.jpeg" alt="img" style="zoom:50%;"></p><p>好吧，就算他们说的是对的</p><p>但是在这无数多个宇宙中</p><p>至少有一个圣诞老人会穿梭于不同的宇宙之间</p><p>而且至少有一个圣诞老人会穿梭到我们的宇宙来</p><p><img src="/2021/10/17/%E5%A6%82%E4%BD%95%E5%8F%8D%E9%A9%B3%E9%82%A3%E4%BA%9B%E8%AE%A4%E4%B8%BA%E5%9C%A3%E8%AF%9E%E8%80%81%E4%BA%BA%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B9%BC%E7%A8%9A%E7%9A%84%E4%BA%BA%E4%BB%AC/4.jpeg" alt="img" style="zoom:50%;"></p><p>所以说，保持着你们童真的梦想，</p><p>开心的等着圣诞老人吧</p><p>如果那些大孩子一直反对你的观点</p><p>无视掉他们</p><p>他们不懂物理</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P,NP,NPC,NP-hard</title>
      <link href="2021/07/09/P-NP-NPC-NP-hard/"/>
      <url>2021/07/09/P-NP-NPC-NP-hard/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>很久远以前在最优化学习时接触过P，NP等的定义。各类影视作品诸如《嫌疑人x的现身》，《基本演绎法》中也会出现这一“fancy”的设定。但很长一段时间内脑海里留下的也只是相对模糊的印象，最近看到北大文学系一博主在08年发布的分析，讲的十分透彻，通篇搬运在这里，方便日后复习。</p><a id="more"></a><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>你会经常看到网上出现“这怎么做，这不是NP问题吗”、“这个只有搜了，这已经被证明是NP问题了”之类的话。你要知道，大多数人此时所说的NP问题其实都是指的NPC问题。他们没有搞清楚NP问题和NPC问题的概念。NP问题并不是那种“只有搜才行”的问题，NPC问题才是。好，行了，基本上这个误解已经被澄清了。下面的内容都是在讲什么是P问题，什么是NP问题，什么是NPC问题，你如果不是很感兴趣就可以不看了。接下来你可以看到，把NP问题当成是 NPC问题是一个多大的错误。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>还是先用几句话简单说明一下时间复杂度。时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有$O(1)$的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是$O(n)$，比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于$O(n^2)$的复杂度。还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是$O(a^n)$的指数级复杂度，甚至$O(n!)$的阶乘级复杂度。不会存在$O(2n^2)$的复杂度，因为前面的那个”2”是一个系数，根本不会影响到整个程序的时间增长。同样地，$O (n^3+n^2)$的复杂度也就是$O(n^3)$的复杂度。因此，我们会说，一个的程序的效率比$O(100n^2)$的效率低，尽管在n很小的时候，前者优于后者，但后者时间随数据规模增长得慢，最终O(n^3)的复杂度将远远超过$O(n^2)$。我们也说，$O(n^{100})$的复杂度小于$O(1.01^n)$的复杂度。</p><p>容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是$O(1),O(log(n)),O(n^a)$等，我们把它叫做多项式级的复杂度，因为它的规模n出现在底数的位置；另一种是$O(a^n)$和$O(n!)$型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。</p><h1 id="P-与NP"><a href="#P-与NP" class="headerlink" title="P 与NP"></a>P 与NP</h1><p>自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为“不可解问题”(Undecidable Decision Problem)。<a href="http://www.matrix67.com/blog/article.asp?id=62">The Halting Problem</a>就是一个著名的不可解问题，在我的Blog上有过专门的介绍和证明。</p><p>再比如，输出从1到n这n个数的全排列。不管你用什么方法，你的复杂度都是阶乘级，因为你总得用阶乘级的时间打印出结果来。有人说，这样的“问题”不是一个“正规”的问题，正规的问题是让程序解决一个问题，输出一个“YES”或“NO”（这被称为判定性问题），或者一个什么什么的最优值（这被称为最优化问题）。那么，根据这个定义，我也能举出一个不大可能会有多项式级算法的问题来：Hamilton回路。问题是这样的：给你一个图，问你能否找到一条经过每个顶点一次且恰好一次（不遗漏也不重复）最后又走回来的路（满足这个条件的路径叫做Hamilton回路）。这个问题现在还没有找到多项式级的算法。事实上，这个问题就是我们后面要说的NPC问题。</p><p><strong>下面引入P类问题的概念：如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。</strong></p><p>P是英文单词多项式<em>Polynomial</em>的第一个字母。哪些问题是P类问题呢？通常NOI和NOIP不会出不属于P类问题的题目。我们常见到的一些信息奥赛的题目都是P问题。道理很简单，一个用穷举换来的非多项式级时间的超时程序不会涵盖任何有价值的算法。</p><p><strong>接下来引入NP （Non-deterministic Polynomial）问题的概念：如果一个问题可以找到一个能在多项式的时间里验证一个解，那么这个问题就属于NP问题。</strong></p><p>这个就有点难理解了，或者说容易理解错误。在这里强调（回到我竭力想澄清的误区上），<strong>NP问题不是非P类问题。</strong>NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做出来的，他就可以说，因为我找到了一个比100 小的解。<strong>在这个题中，找一个解很困难，但验证一个解很容易</strong>。</p><p>验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满足题意的方案也不会来骗我去选它。这就是NP问题。当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。</p><p><strong>之所以要定义NP问题，是因为通常只有NP问题才可能找到多项式的算法。</strong>我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。相信读者很快明白，信息学中的号称最困难的问题——“NP问题”，实际上是在探讨NP问题与P类问题的关系。</p><p> 很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。</p><p> NP问题一直都是信息学的巅峰。巅峰，意即很引人注目但难以解决。在信息学研究中，这是一个耗费了很多时间和精力也没有解决的终极问题，好比物理学中的大统一和数学中的歌德巴赫猜想等。目前为止这个问题还“啃不动”。但是，一个总的趋势、一个大方向是有的。<strong>人们普遍认为，P=NP不成立，也就是说，多数人相信，存在至少一个不可能有多项式级复杂度的算法的NP问题。</strong>人们如此坚信P≠NP是有原因的，就是在研究NP问题的过程中找出了一类非常特殊的NP问题叫做NP-完全问题，也即所谓的 NPC问题。C是英文单词“完全”的第一个字母。正是NPC问题的存在，使人们相信P≠NP。下文将花大量篇幅介绍NPC问题，你从中可以体会到NPC问题使P=NP变得多么不可思议。</p><h1 id="Reduce与NPC"><a href="#Reduce与NPC" class="headerlink" title="Reduce与NPC"></a>Reduce与NPC</h1><p>为了说明NPC问题，我们先引入一个概念——约化(Reducibility，有的资料上叫“归约”)。<strong>简单地说，一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。</strong></p><p>《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。</p><p>  “问题A可约化为问题B”有一个重要的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</p><p>很显然，约化具有一项重要的性质：约化具有传递性。如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。这个道理非常简单，就不必阐述了。现在再来说一下约化的标准概念就不难理解了：如果能找到这样一个变化法则，对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。<strong>当然，我们所说的“可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项式的时间里完成的。</strong>约化的过程只有用多项式的时间完成才有意义。</p><p> 好了，从约化的定义中我们看到，一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。再回想前面讲的P和NP问题，联想起约化的传递性，自然地，我们会想问，如果不断地约化上去，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，<strong>那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？</strong></p><p>答案居然是肯定的。也就是说，<strong>存在这样一个NP问题，所有的NP问题都可以约化成它。</strong>换句话说，只要解决了这个问题，那么所有的NP问题都解决了。这种问题的存在难以置信，并且更加不可思议的是，这种问题不只一个，它有很多个，它是一类问题。这一类问题就是传说中的NPC 问题，也就是NP-完全问题。NPC问题的出现使整个NP问题的研究得到了飞跃式的发展。我们有理由相信，NPC问题是最复杂的问题。再次回到全文开头，我们可以看到，人们想表达一个问题不存在多项式的高效算法时应该说它“属于NPC问题”。此时，我的目的终于达到了，我已经把NP问题和NPC问题区别开了。到此为止，本文已经写了近5000字了，我佩服你还能看到这里来，同时也佩服一下自己能写到这里来。</p><p> NPC问题的定义非常简单。同时满足下面两个条件的问题就是NPC问题：</p><ol><li>首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。证明一个问题是 NPC问题也很简单。先证明它至少是一个NP问题，</li><li>再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足；至于第一个NPC问题是怎么来的，下文将介绍），这样就可以说它是NPC问题了。</li></ol><p><strong>既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那么所有的NP问题都能用这个算法解决了，NP也就等于P 了。</strong>因此，给NPC找一个多项式算法太不可思议了。因此，前文才说，“正是NPC问题的存在，使人们相信P≠NP”。我们可以就此直观地理解，NPC问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度的搜索。</p><p>顺便讲一下NP-Hard问题。NP-Hard问题是这样一种问题，<strong>它满足NPC问题定义的第二条但不一定要满足第一条</strong>（就是说，NP-Hard问题要比 NPC问题的范围广）。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。</p><h1 id="第一个NPC-与NPC的越化"><a href="#第一个NPC-与NPC的越化" class="headerlink" title="第一个NPC 与NPC的越化"></a>第一个NPC 与NPC的越化</h1><p>第一个NPC问题：<strong><em>satisifiable problem</em></strong></p><p>给定一串逻辑表达式，<strong>判断是否存在</strong>输入w，使表达式为真。</p><p> 不要以为NPC问题是一纸空谈。NPC问题是存在的。确实有这么一个非常具体的问题属于NPC问题。下文即将介绍它。下文即将介绍逻辑电路问题。这是第一个NPC问题。其它的NPC问题都是由这个问题约化而来的。因此，逻辑电路问题是NPC类问题的“鼻祖”。逻辑电路问题是指的这样一个问题：给定一个逻辑电路，问是否存在一种输入使输出为True。 什么叫做逻辑电路呢？一个逻辑电路由若干个输入，一个输出，若干“逻辑门”和密密麻麻的线组成。看下面一例，不需要解释你马上就明白了。<br> ┌───┐<br> │ 输入1├─→┐  ┌──┐<br> └───┘  └─→┤  │<br>           │ or ├→─┐<br> ┌───┐  ┌─→┤  │  │  ┌──┐<br> │ 输入2├─→┤  └──┘  └─→┤  │<br> &amp;<br>nbsp;└───┘  │        ┌─→┤AND ├──→输出<br>        └────────┘┌→┤  │<br> ┌───┐  ┌──┐      │ └──┘<br> │ 输入3├─→┤ NOT├─→────┘<br> └───┘  └──┘<br>  这是个较简单的逻辑电路，当输入1、输入2、输入3分别为True、True、False或False、True、False时，输出为True。有输出无论如何都不可能为True的逻辑电路吗？有。下面就是一个简单的例子。<br> ┌───┐<br> │输入1 ├→─┐  ┌──┐<br> └───┘  └─→┤  │<br>           │AND ├─→┐<br>        ┌─→┤  │  │<br>        │  └──┘  │ ┌──┐<br>        │        └→┤  │<br> ┌───┐  │          │AND ├─→输出<br> │输入2 ├→─┤ ┌──┐   ┌→┤  │<br> └───┘  └→┤NOT ├→──┘ └──┘<br>          └──┘</p><p>上面这个逻辑电路中，无论输入是什么，输出都是False。我们就说，这个逻辑电路不存在使输出为True的一组输入。回到上文，<strong>给定一个逻辑电路，问是否存在一种输入使输出为True，这即逻辑电路问题。</strong>逻辑电路问题属于NPC问题。这是有严格证明的。它显然属于NP问题，并且可以直接证明所有的NP问题都可以约化到它（不要以为NP问题有无穷多个将给证明造成不可逾越的困难）。证明过程相当复杂，其大概意思是说任意一个NP问题的输入和输出都可以转换成逻辑电路的输入和输出（想想计算机内部也不过是一些 0和1的运算），因此对于一个NP问题来说，问题转化为了求出满足结果为True的一个输入（即一个可行解）。</p><p>有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题。现在被证明是NPC问题的有很多，任何一个找到了多项式算法的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。P=NP问题还有许多有趣的东西，有待大家自己进一步的挖掘。攀登这个信息学的巅峰是我们这一代的终极目标。现在我们需要做的，至少是不要把概念弄混淆了。</p><p>一些著名的NPC问题： Satisifiable Problem (例如3CNF-SAT), Vertex Cover, Hamilton-Path)</p><p><img src="/Users/windsky/Library/Application Support/typora-user-images/image-20220522224738955.png" alt="image-20220522224738955" style="zoom:35%;"></p><p><a href="http://www.matrix67.com/blog/archives/105">原文链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据与隐私</title>
      <link href="2021/06/08/Data-privacy/"/>
      <url>2021/06/08/Data-privacy/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img align="cente" src="/2021/06/08/Data-privacy/index.jpeg" style="zoom:67%;"></p><p>大数据技术在提升社会协作效率、给人们带来诸多便利与舒适的同时, 也逐渐引发了一系列问题, “大数据杀熟”便是恶果之一。</p><a id="more"></a><p>​    所谓“大数据杀熟”, 通俗说来就是平台(主要是互联网平台)充分利用自身所掌握的大数据技术对<strong>消费市场进行更为精准与细腻的划分</strong>, 在此基础上主要<strong>对熟人(习惯、依赖该平台的较为忠诚的用户)进行不当地利益宰割</strong>, 从而使大数据技术成为部分经营者追求超额利润的有力工具。也就是说, 面临同样的商品或服务, 具有忠诚度的用户群体看到并为此实际支付的价格反而比新客户或一般用户要贵,   而且这种行为极具隐蔽性。一言以蔽之, 大数据技术加剧了经营者和相对人之间的的信息不平等, 消费者很难通过网络对经营者价格歧视的抗辩进行甄别</p><p>​    究其本质, “大数据杀熟”的技术原理就是互联网平台凭借其所掌握的极其庞大且维度异常丰富的数据, 诸如用户的个人身份信息、位置信息、聊天记录以及支付信息等一切有可能被线上记录的数字化信息, 然后通过一整套复杂、高效而又极其先进的数据运算、分析和挖掘技术对碎片化、零散的用户数字化信息进行全方位的扫描、分析与研究(数据标注), 然后通过一些关键词的标注对用户进行细致归类, 从而生成独特的 <font color="EE695E"><strong>用户画像</strong>。</font></p><h1 id="1-主因"><a href="#1-主因" class="headerlink" title="1 主因"></a>1 主因</h1><p>1.数据高度集中，互联网的发展建立在用户数据的规模智商，用户规模越大整个互联网越能发挥出更大的效用，综合价值成集合式增长。 相较于传统经济样态, 互联网经济的边际成本非常低, 收益却可以很高,自然导致了数据的集中于垄断。</p><p>2.用户”粘性“，用户粘性是各大互联网产品重要的指标。用户长久的习惯于使用某一平台，由于用户对便利、稳定的追求使得有被”杀熟“的可能。</p><p>3.不同平台间的隐私窃取。微信与京东，支付宝与淘宝等的相互泄漏数据很易使得用户的偏好或购物倾向被泄漏，从而引导消费、杀熟等。粘贴板、输入法等获取信息。</p><font color="red">矛盾：</font><p>公司需要用户数据刻画用户画像，以此来提供服务</p><p>VS</p><p>公民隐私泄漏给互联网公司利用用户隐私数据创造价格歧视的机会</p><p>据此，按照通行的观点，价格歧视往往被分为三级：</p><p>一级价格歧视，即看人报价，报出对方能够接受的最高价，攫取最大利润；传统商业社会中，游商采用这种方式比较多；</p><p>二级价格歧视，即根据批量大小定价，从而获得最好的周转率，批量大的消费者获得实惠；从商家角度看，虽然单一商品获利降低，但由于销量增加，也可以获得更大的利润；</p><p>三级价格歧视，是根据销售区域的不同进行差异化定价。</p><p>对于大数据杀熟，我国法律中已经有相应的规则进行规范。《中华人民共和国消费者权益保护法》第十九条规定：商店提供商品应明码标价。该法第十条规定：消费者享有公平交易的权利。明码标价意味着商品价格展示不应因为消费者不同而不同，由于不同的消费者看到的价格不同，因而大数据杀熟违反了明码标价的原则。消费者权益保护法规定消费者获得公平交易的权利，也从另一个角度说明了相同商品或服务的定价应一视同仁。</p><h2 id="数据安全法，6-10通过"><a href="#数据安全法，6-10通过" class="headerlink" title="数据安全法，6.10通过"></a>数据安全法，6.10通过</h2><h1 id="2-数据中个人隐私保护的技术分析"><a href="#2-数据中个人隐私保护的技术分析" class="headerlink" title="2 数据中个人隐私保护的技术分析"></a>2 数据中个人隐私保护的技术分析</h1><h2 id="2-1-将id去敏？"><a href="#2-1-将id去敏？" class="headerlink" title="2.1  将id去敏？"></a>2.1  将id去敏？</h2><p>例如在用户数据需要被使用时，使用去敏手段，如：将名字等敏感的个人信息去除。</p><p>问题： How anonymous ?</p><p>2006 netflix收集大量用户评分一次来训练自己的评分预测功能：</p><p>1， 将uid改为无意义代码</p><p>2，随机修改部分用户评分</p><p><a href="https://ieeexplore.ieee.org/document/4531148">Robust De-anonymization of Large Sparse Datasets</a></p><p>(利用了imdb的数据库，correlation 可以)</p><p>马萨诸塞州，医疗数据。</p><font color="red">考虑彼此反推数据，如何加密？</font><h2 id="2-2-只发布粗粒度的统计数据？"><a href="#2-2-只发布粗粒度的统计数据？" class="headerlink" title="2.2 只发布粗粒度的统计数据？"></a>2.2 只发布粗粒度的统计数据？</h2><script type="math/tex; mode=display">\begin{array}{l}\begin{array}{|c|c|c|}\hline \text { Age } & \text { Gender } & \text { Employed? } \\\hline<18 & \mathrm{M} & \text { Yes } \\\hline<18 & \mathrm{~F} & \text { No } \\\hline<18 & \mathrm{M} & \text { No } \\\hline \geq 18 & \mathrm{~F} & \text { Yes } \\\hline \geq 18 & \mathrm{~F} & \text { Yes } \\\hline\end{array}\\{\text { Original dataset }}\end{array}</script><script type="math/tex; mode=display">\begin{array}{l}\begin{array}{|c|c|c|}\hline \text { Age } & \text { Employed? } & \text { Count } \\\hline<18 & \text { Yes } & 1 \\\hline<18 & \text { No } & 2 \\\hline \geq 18 & \text { Yes } & 2 \\\hline \geq 18 & \text { No } & 0 \\\hline\end{array}\\\begin{array}{|c|c|c|}\hline \text { Age } & \text { Gender } & \text { Count } \\\hline<18 & \mathrm{M} & 2 \\\hline<18 & \mathrm{~F} & 1 \\\hline \geq 18 & \mathrm{M} & 0 \\\hline \geq 18 & \mathrm{~F} & 2 \\\hline\end{array}\\\end{array}</script><p>很容易可以从发布的两份数据中反推出必有两个大于18岁女性，有工作。</p><p>（数据重构攻击）</p><p>可能解决方法：</p><p>1，对统计结果加上有权重的噪音，处理outlier</p><p>2， 统计结果上，将outlier划入相对大的群体，减少outlier</p><h2 id="2-3-Deferential-Privacy"><a href="#2-3-Deferential-Privacy" class="headerlink" title="2.3  Deferential Privacy"></a>2.3  Deferential Privacy</h2><script type="math/tex; mode=display">\exp (-\varepsilon) \leq \frac{\operatorname{Pr}[A(D)=O]}{\operatorname{Pr}\left[A\left(D^{\prime}\right)=O\right]} \leq \exp (\varepsilon)</script><p>对任意“相邻”数据集 $D$ 和 $D^{\prime}$ 及任意输出 $O$ 都成立</p><p>1,拉普拉斯噪声</p><script type="math/tex; mode=display">\operatorname{pdf}(x)=\frac{1}{2 \lambda} \exp \left(-\frac{|x|}{\lambda}\right)</script><p>lambda为 相邻数据集查询发生的最大改变量 / $\epsilon$</p><ol><li><p>random answer</p><p>引入随机量计入答案，保证统计量依然准确可感。</p></li></ol><p><img align="cente" src="/2021/06/08/Data-privacy/random_answer.png" style="zoom:67%;"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
            <tag> 分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cryptocurrency</title>
      <link href="2021/06/02/Cryptocurrency/"/>
      <url>2021/06/02/Cryptocurrency/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/06/02/Cryptocurrency/BTC_Logo.svg.png" style="zoom:10%;"></p><p>Basic introduction of cryptocurrency</p><a id="more"></a><h1 id="1-What-is-cryptocurrency"><a href="#1-What-is-cryptocurrency" class="headerlink" title="1 What is cryptocurrency?"></a>1 What is cryptocurrency?</h1><p>Cryptocurrency is a form of payment that can be exchanged online for goods and services. Many companies have issued their own currencies, often called tokens, and these can be traded specifically for the good or service that the company provides. Think of them as you would arcade tokens or casino chips. You’ll need to exchange real currency for the cryptocurrency to access the good or service.</p><p>Cryptocurrencies work using a technology called <strong>blockchain</strong>. Blockchain is a <strong>decentralized</strong> technology spread across many computers that manages and records transactions. Part of the appeal of this technology is its security.</p><h1 id="2-Why-popular"><a href="#2-Why-popular" class="headerlink" title="2 Why popular?"></a>2 Why popular?</h1><p>Cryptocurrencies appeal to their supporters for a variety of reasons. Here are some of the most popular:</p><ul><li>Supporters see cryptocurrencies such as Bitcoin as the currency of the future and are racing to buy them now, presumably before they become more valuable（升值）</li><li>Some supporters like the fact that cryptocurrency removes central banks from managing the money supply, since over time these banks tend to reduce the value of money via inflation（私密）</li><li>Other supporters like the technology behind cryptocurrencies, the blockchain, because it’s a decentralized processing and recording system and can be more secure than traditional payment systems（技术控）</li></ul><h1 id="3-How-it-works？"><a href="#3-How-it-works？" class="headerlink" title="3 How it works？"></a>3 How it works？</h1><h2 id="3-1-Decentralize"><a href="#3-1-Decentralize" class="headerlink" title="3.1 Decentralize:"></a>3.1 Decentralize:</h2><p>In traditional electronic trading， there will always be a trusted third party either country\Bank or big company like Alibaba. In cryptocurrency there is no such “Center”.</p><h2 id="3-2-Block-Chain"><a href="#3-2-Block-Chain" class="headerlink" title="3.2 Block Chain:"></a>3.2 Block Chain:</h2><p>Since, there is no centralized third party we need another way to verify and record transaction. The main idea behind cryptocurrency is to let everyone keep the whole e-ledger—<strong>the block chain</strong>.</p><p>In every 5 minutes someone will pack all the transactions(<strong>block</strong>) then he will broadcast to everyone and link the new block to the block chain.Every block will be encrypted by hash function.For bitcoin, it uses POW algorithm wich is based on SHA256. </p><center>  <font color="blue">SHA256</font>(<font color="green">Plain Text</font>) = <font color="green">010101101010..0101</font>(256 bit)</center><p><img src="/2021/06/02/Cryptocurrency/blockchain_demo.png" style="zoom:50%;"></p><p>In short:</p><p><center>Ledger-Trust+Cryptography=<font color="#4182D1">Cryptocurrency</font></center></p><p><img src="/2021/06/02/Cryptocurrency/VSbank.png" style="zoom:50%;"></p><h2 id="3-3-Why-this-works"><a href="#3-3-Why-this-works" class="headerlink" title="3.3 Why this works?"></a>3.3 Why this works?</h2><ol><li><p>It satisfy the basic requirements to be used as “currency”. </p><p><strong>currency = transaction history</strong></p></li><li><p>Althoug there is no provement of non-solvable property of SHA256 but we can assume it is not possible to solve it. So it is hard(expensive, 51% attack) to forgery.</p><p><strong>Fraud is computationally infeasible</strong></p></li></ol><h1 id="4-What-is-mining"><a href="#4-What-is-mining" class="headerlink" title="4 What is mining?"></a>4 What is mining?</h1><h2 id="4-1-Block-reward"><a href="#4-1-Block-reward" class="headerlink" title="4.1 Block reward"></a>4.1 Block reward</h2><p><strong>Block Award</strong>:</p><p>Once a new block is added to the block chain, the people who finish such job will get rewarded for 25 bit coins<strong>(halve after every 210000 blocks,and for now each block is rewarded for 12.5 btc)</strong></p><h2 id="4-2-Who-can-get-reward"><a href="#4-2-Who-can-get-reward" class="headerlink" title="4.2 Who can get reward?"></a>4.2 Who can get reward?</h2><p>To get the reward one must get the opportunity to add a new block. This is where cryptography works. </p><p>SHA256 algorithms will translate plaintext into 256 binary code, the cryptocurrency protocol will announce, for example: first 30 bits should be 0 for next block. Miners will try different keys until one lucky miner find the key that satisfies the requirement.</p><p>SHA256(。。。+transaction+Time Stamp+。。。+<font color="green">key</font>) = <font color="red">0000…000</font>1010111</p><h2 id="4-3-Proof-of-work"><a href="#4-3-Proof-of-work" class="headerlink" title="4.3 Proof of work"></a>4.3 Proof of work</h2><p>The miners may get conflict signals recording conflict transactions. Miners should always t<strong>rsust one with more computational work.</strong></p><p>Some times conflict may come from the broadcast speed.For example one may get 2 blocks at the same time, then he sholud keep both blocks and one of them will gradually get longer and longer than another one, then based on <strong>proof of work</strong> protocol he should take the longer one.</p><p>Some time fraud may come from fraud. It is obvious that to make others trust your record you have to make sure your chain grows faster than the true chain, which means you have to posses at least 51% computation power which is not possible.</p><p><img src="/2021/06/02/Cryptocurrency/proofWork.png" style="zoom:50%;"></p><h1 id="5-Problems"><a href="#5-Problems" class="headerlink" title="5 Problems"></a>5 Problems</h1><h2 id="5-1-Speculation-and-fraud"><a href="#5-1-Speculation-and-fraud" class="headerlink" title="5.1 Speculation and fraud"></a>5.1 Speculation and fraud</h2><p>Cryptocurrencies have been compared to Ponzi schemes, pyramid schemes and economic bubbles, such as housing market bubbles. Howard Marks of Oaktree Capital Management stated in 2017 that digital currencies were “nothing but an unfounded fad (or perhaps even a pyramid scheme), based on a willingness to ascribe value to something that has little or none beyond what people will pay for it”, and compared them to the tulip mania (1637), South Sea Bubble (1720), and dot-com bubble (1999). The New Yorker has explained the debate based on interviews with blockchain founders in an article about the “argument over whether Bitcoin, Ethereum, and the blockchain are transforming the world”.</p><p>(泡沫与庞氏骗局)</p><h2 id="5-2-legal-concern"><a href="#5-2-legal-concern" class="headerlink" title="5.2 legal concern"></a>5.2 legal concern</h2><p>Cryptocurrency networks display a lack of regulation that has been criticized as enabling criminals who seek to evade taxes and launder money. Money laundering issues are also present in regular bank transfers, however with bank-to-bank wire transfers for instance, the account holder must at least provide a proven identity.</p><p>（洗钱，非法汇款等）</p><h2 id="5-3-Environment-concern"><a href="#5-3-Environment-concern" class="headerlink" title="5.3 Environment concern"></a>5.3 Environment concern</h2><p>挖矿带来的电力的浪费，环境污染，硬件消耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic Auction Theory</title>
      <link href="2021/05/24/auction/"/>
      <url>2021/05/24/auction/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/05/24/auction/index.jpeg" style="zoom:90%;"></p><p><center>Basic Auction theory</center></p><a id="more"></a><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>​    Auction theory can be approached from different angles – from the perspective of game theory (auctions are bayesian games of incomplete information), contract or mechanism design theory (auctions are allocation mechanisms), market microstructure (auctions are models of price formation), as well as in the context of different applications (procurement, patent licensing, public finance, etc.).</p><p>​    Generally speaking, the higher the bidder offer the higher chance he will get the good but also he will get less profit, vice versa.</p><p>The basic auction environment consists of:</p><ul><li>Bidders <script type="math/tex">i=1, \ldots, n</script></li><li>One object to be sold</li><li>Bidder <script type="math/tex">i</script> observes a “signal” <script type="math/tex">S_{i} \sim F(\cdot)</script>, with typical realization <script type="math/tex">s_{i} \in</script> <script type="math/tex">[\underline{s}, \bar{s}]</script>, and assume <script type="math/tex">F</script> is continuous.</li><li>Bidders’ signals <script type="math/tex">S_{1}, \ldots, S_{n}</script> are independent.</li><li>Bidder $i$ ‘s value <script type="math/tex">v_{i}\left(s_{i}\right)=s_{i}</script></li></ul><h1 id="2-Different-Auction-Forms"><a href="#2-Different-Auction-Forms" class="headerlink" title="2 Different Auction Forms"></a>2 Different Auction Forms</h1><h2 id="1-English-auction-oral-ascending"><a href="#1-English-auction-oral-ascending" class="headerlink" title="1) English auction(oral ascending):"></a>1) English auction(oral ascending):</h2><p>All bidders start in the auction with a price of zero. The price rises continuously, and bidders may drop out at any point in time. Once they drop out, they cannot reenter. The auction ends when only one bidder is left, and this bidder pays the price at which the second-to-last bidder dropped out.</p><h2 id="2-Dutch-Auction-descending-price"><a href="#2-Dutch-Auction-descending-price" class="headerlink" title="2) Dutch Auction(descending price)"></a>2) Dutch Auction(descending price)</h2><p>A Dutch auction is one of several similar types of auctions for buying or selling goods.Most commonly, it means an auction in which the auctioneer begins with a high asking price in the case of selling, and lowers it until some participant accepts the price, or it reaches a predetermined reserve price. This type of price auction is most commonly used for goods that are required to be sold quickly such as flowers, fresh produce or  tobacco.</p><h2 id="3-First-price-sealed-bid-auction"><a href="#3-First-price-sealed-bid-auction" class="headerlink" title="3) First-price sealed-bid auction"></a>3) First-price sealed-bid auction</h2><p>Also known as blind bid all bidders simultaneously submit sealed bids so that no bidder knows the bid of any other participant. The highest bidder pays the price that was submitted.</p><h2 id="4-Second-price-sealed-bid-auction-vickery-auction"><a href="#4-Second-price-sealed-bid-auction-vickery-auction" class="headerlink" title="4) Second-price sealed-bid auction(vickery auction)"></a>4) Second-price sealed-bid auction(vickery auction)</h2><p>In a Vickrey, or second price, auction, bidders are asked to submit sealed bids <script type="math/tex">b_{1}, \ldots, b_{n}</script>. The bidder who submits the highest bid is awarded the object, and pays the amount of the second highest bid.</p><h1 id="3-First-price-sealed-bid-auction-FPSD"><a href="#3-First-price-sealed-bid-auction-FPSD" class="headerlink" title="3 First-price sealed-bid auction(FPSD)"></a>3 First-price sealed-bid auction(FPSD)</h1><p>In a FPSD auction the bidders sealed bids <script type="math/tex">b_1,b_2\dots b_n</script> the bidders who submits the highest bid is awarded the object and pays his bid.</p><p>Under these rules the bidder will not bid higher than their values, by doing so they may get negative profit. By bidding lower than their true value they may make profit some time.</p><h2 id="A-The-first-order-condition-approach"><a href="#A-The-first-order-condition-approach" class="headerlink" title="A The first order condition approach"></a>A The first order condition approach</h2><p>We will look for an equilibrium where each bidder uses a bid strategy that is a strictly increasing, continuous, and differentiable function of his value. To do this we assume that different bidders use the same bid function <script type="math/tex">b_j = b(s_j)</script> for different j. </p><p>Bidder i’s expected profit as a  function of his bid <script type="math/tex">b_i</script> and signal <script type="math/tex">s_i</script></p><script type="math/tex; mode=display">U\left(b_{i}, s_{i}\right)=\left(s_{i}-b_{i}\right) \cdot \operatorname{Pr}\left[b_{j}=b\left(S_{j}\right) \leq b_{i}, \forall j \neq i\right]</script><p>Thus, bidder i chooses b to solve:</p><script type="math/tex; mode=display">\max _{b_{i}}\left(s_{i}-b_{i}\right) F^{n-1}\left(b^{-1}\left(b_{i}\right)\right)</script><p>The first order condition is:</p><script type="math/tex; mode=display">\left(s_{i}-b_{i}\right)(n-1) F^{n-2}\left(b^{-1}\left(b_{i}\right)\right) f\left(b^{-1}\left(b_{i}\right)\right) \frac{1}{b^{\prime}\left(b^{-1}\left(b_{i}\right)\right)}-F^{n-1}\left(b^{-1}\left(b_{i}\right)\right)=0</script><p>At a symmetric equilibrium, <script type="math/tex">b_{i}=b\left(s_{i}\right)</script>, so the first order condition reduces to a differential equation (here I’ll drop the $i$ subscript):</p><script type="math/tex; mode=display">b^{\prime}(s)=(s-b(s))(n-1) \frac{f(s)}{F(s)}</script><p>This can be solved, using the boundary condition that <script type="math/tex">b(\underline{s})=\underline{s}</script>, to obtain:</p><script type="math/tex; mode=display">b(s)=s-\frac{\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}}{F^{n-1}(s)}</script><p>It is easy to check that b(s) is increasing and differentiable. So any symmetric equilibrium with these properties must involve bidders using the strategy  b(s).</p><h2 id="The-envelope-theorem-approach"><a href="#The-envelope-theorem-approach" class="headerlink" title="The envelope theorem approach"></a>The envelope theorem approach</h2><p>For bidder i, his equilibrium payoff is:</p><script type="math/tex; mode=display">U\left(s_{i}\right)=\left(s_{i}-b\left(s_{i}\right)\right) F^{n-1}\left(s_{i}\right)\label{usi_1}</script><p>Because i is playing the best-response in equilibrium, so:</p><script type="math/tex; mode=display">U\left(s_{i}\right)=\max _{b_{i}}\left(s_{i}-b_{i}\right) F^{n-1}\left(b^{-1}\left(b_{i}\right)\right)</script><p>Applying the Envelope Theorem we can get:</p><script type="math/tex; mode=display">\left.\frac{d}{d s} U(s)\right|_{s=s_{i}}=F^{n-1}\left(b^{-1}\left(b\left(s_{i}\right)\right)=F^{n-1}\left(s_{i}\right)\right.</script><p>and also:</p><script type="math/tex; mode=display">U\left(s_{i}\right)=U(\underline{s})+\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s} \label{usi_2}</script><p>As b(s) is increasing a bidder with signal $\underline{s}$ will never win the auction so we have $U(\underline{s})=0$, combine $\eqref{usi_1}$ and $\eqref{usi_2}$ we can easily get:</p><script type="math/tex; mode=display">b(s)=s-\frac{\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}}{F^{n-1}(s)}</script><h1 id="4-Vickery-auction-Second-price-auction"><a href="#4-Vickery-auction-Second-price-auction" class="headerlink" title="4 Vickery auction( Second price auction)"></a>4 Vickery auction( Second price auction)</h1><p>In a Vickrey, or second price auction, bidders are asked to submit sealed bids <script type="math/tex">b_{1}, \ldots, b_{n}</script>. The bidder who submits the highest bid is awarded the object, and pays the amount of the second highest bid.</p><p><strong>Proposition 1</strong> <em>In a second price auction, it is a weakly dominant strategy to bid one’s value <script type="math/tex">b_i(s_i) = s_i</script></em></p><p>(Easy to be proved, omitted here)</p><p>Since each bidder will bid their value, the seller’s revenue (the amount paid in equilibrium) will be equal to the second highest value. Let <script type="math/tex">S^{i: n}</script> denote the $i$ th highest of $n$ draws from distribution <script type="math/tex">F</script> (so <script type="math/tex">S^{i: n}</script> is a random variable with typical realization <script type="math/tex">\left.s^{i: n}\right)</script>. Then the seller’s expected revenue is <script type="math/tex">\mathbb{E}\left[S^{2: n}\right] .</script></p><h1 id="5-Revenue-equivalence"><a href="#5-Revenue-equivalence" class="headerlink" title="5 Revenue equivalence"></a>5 Revenue equivalence</h1><p>What is the revenue from the first price auction? It is the expected winning bid, or the expected bid of the bidder with the highest signal, <script type="math/tex">E[b(S^{1:n})]</script> To sharpen this, define <script type="math/tex">G(s)=F^{n-1}(s) .</script>Then <script type="math/tex">G</script> is the probability that if you take <script type="math/tex">n-1</script> draws from <script type="math/tex">F</script>, all will be below <script type="math/tex">s</script> (i.e. it is the cdf of <script type="math/tex">S^{1: n-1}</script> ). Then,</p><script type="math/tex; mode=display">b(s)=s-\frac{\int_{\underline{s}}^{s} F^{n-1}(\tilde{s}) d \tilde{s}}{F^{n-1}(s)}=\frac{1}{F^{n-1}(s)} \int_{\underline{s}}^{s} \tilde{s} d F^{n-1}(\tilde{s})=\mathbb{E}\left[S^{1: n-1} \mid S^{1: n-1} \leq s\right]</script><p>That is, if a bidder has signal s, he sets his bid equal to the expectation of the highest of the other n-1​ values, conditional on all those values being less than his own. Using this fact, the expected revenue is:</p><script type="math/tex; mode=display">\mathbb{E}\left[b\left(S^{1: n}\right)\right]=\mathbb{E}\left[S^{1: n-1} \mid S^{1: n-1} \leq S^{1: n}\right]=\mathbb{E}\left[S^{2: n}\right]</script><p>equal to the expectation of the second highest value. We have shown: </p><p><strong>Proposition 2</strong> <em>The first and second price auction yield the same revenue in expectation.</em></p><p>The result above is a special case of the celebrated “revenue equivalence theorem” .</p><p><strong>Revenue Equivalence Theorem</strong> :<em>Suppose n bidders have values</em> <script type="math/tex">s_{1}, \ldots, s_{n}</script> <em>identically and independently distributed with cdf <script type="math/tex">F(\cdot) .</script> Then all auction mechanisms that (i) always award the object to the bidder with highest value in equilibrium, and (ii) give a bidder with valuation <script type="math/tex">\underline{s}</script> zero profits, generates the same revenue in expectation.</em></p><p><strong>proof:</strong></p><p>We consider the general class of auctions where bidders submit bids <script type="math/tex">b_1,\dots,b_n</script>. An auction rule specifies for all i,</p><script type="math/tex; mode=display">\begin{aligned}x_{i} &: B_{1} \times \ldots \times B_{n} \rightarrow[0,1] \\t_{i} &: B_{1} \times \ldots \times B_{n} \rightarrow \mathbb{R}\end{aligned}</script><p>where <script type="math/tex">x_{i}(\cdot)</script> gives the probability $i$ will get the object and <script type="math/tex">t_{i}(\cdot)</script> gives $i$ ‘s required payment as a function of the bids <script type="math/tex">\left(b_{1}, \ldots, b_{n}\right)</script> . (For example in a first price auction, <script type="math/tex">x_{1}\left(b_{1}, \ldots, b_{n}\right)</script> equals 1 if <script type="math/tex">b_{1}</script> is the highest bid, and otherwise zero. Meanwhile <script type="math/tex">t_{1}\left(b_{1}, \ldots, b_{n}\right)</script> equals zero unless <script type="math/tex">b_{1}</script> is highest, in which case <script type="math/tex">t_{1}=b_{1}</script>)</p><p>Given the auction rule, bidder $i$ ‘s expected payoff as a function of his signal and bid is:</p><script type="math/tex; mode=display">U_{i}\left(s_{i}, b_{i}\right)=s_{i} \mathbb{E}_{b_{-i}}\left[x_{i}\left(b_{i}, b_{-i}\right)\right]-\mathbb{E}_{b_{-i}}\left[t_{i}\left(b_{i}, b_{-i}\right)\right]</script><p>Let <script type="math/tex">b_{i}(\cdot), b_{-i}(\cdot)</script> denote an equilibrium of the auction game. Bidder $i$ ‘s equilibrium payoff is:</p><script type="math/tex; mode=display">U_{i}\left(s_{i}\right)=U_{i}\left(s_{i}, b\left(s_{i}\right)\right)=s_{i} F^{n-1}\left(s_{i}\right)-\mathbb{E}_{s_{-i}}\left[t_{i}\left(b_{i}\left(s_{i}\right), b_{-i}\left(s_{-i}\right)\right]\right.</script><p>where we use (i) to write <script type="math/tex">\mathbb{E}_{s_{-i}}\left[x_{i}\left(b\left(s_{i}\right), b\left(s_{-i}\right)\right)\right]=F^{n-1}\left(s_{i}\right)</script>.<br>Using the fact that <script type="math/tex">b\left(s_{i}\right)</script> must maximize $i$ ‘s payoff given <script type="math/tex">s_{i}</script> and opponent strategies <script type="math/tex">b_{-i}(\cdot)</script>, the envelope theorem implies that:</p><script type="math/tex; mode=display">\left.\frac{d}{d s} U_{i}(s)\right|_{s=s_{i}}=\mathbb{E}_{b_{-i}}\left[x_{i}\left(b_{i}\left(s_{i}\right), b_{-i}\left(s_{-i}\right)\right)\right]=F^{n-1}\left(s_{i}\right)</script><p>and also</p><script type="math/tex; mode=display">U_{i}\left(s_{i}\right)=U_{i}(\underline{s})+\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}=\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s},</script><p>where we use $(i i)$ to write <script type="math/tex">U_{i}(\underline{s})=0</script> Combining our expressions for <script type="math/tex">U_{i}\left(s_{i}\right)</script>, we get bidder $i$ ‘s expected payment given his signal:</p><script type="math/tex; mode=display">\mathbb{E}_{s_{-i}}\left[t_{i}\left(b_{i}, b_{-i}\right)\right]=s_{i} F^{n-1}\left(s_{i}\right)-\int_{\underline{s}}^{s_{i}} F^{n-1}(\tilde{s}) d \tilde{s}=\int_{\underline{s}}^{s_{i}} \tilde{s} d F^{n-1}(\tilde{s})</script><p>where the last equality is from integration by parts. Since <script type="math/tex">x_{i}(\cdot)</script> does not enter into this expression, bidder i’s expected equilibrium payment given his signal is the same under all auction rules that satisfy (i) and (ii). Indeed, i’s expected payment given <script type="math/tex">s_{i}</script> is equal to:</p><script type="math/tex; mode=display">\mathbb{E}\left[S^{1: n-1} \mid S^{1: n-1}<s_{i}\right]=\mathbb{E}\left[S^{2: n} \mid S^{1: n}=s_{i}\right]</script><p>So the seller’s revenue is:</p><script type="math/tex; mode=display">\mathbb{E}[\text { Revenue }]=\sum \mathbb{E}_{s_{i}}\left[i \text { 's expected payment } \mid s_{i}\right]=\mathbb{E}\left[S^{2: n}\right]</script>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gurobi在python中的使用</title>
      <link href="2021/04/30/Gurobi-in-Python/"/>
      <url>2021/04/30/Gurobi-in-Python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>简单学习了下gurobi 在python中的应用，日后估计会经常使用，在此做个记录方便以后掌握。</p><a id="more"></a><h1 id="Gurobi-配置"><a href="#Gurobi-配置" class="headerlink" title="Gurobi 配置"></a>Gurobi 配置</h1><p>在<a href="http://www.gurobi.cn/NewsView1.Asp?id=4">gurobi中国</a>按照要求填写一份pdf文档，然后需要去学信网搞一份学生身份验证。发给指定的邮箱地址后不久会有工作人员发来激活码。一个学生账户最多同时持有2份cd key，绑定机器，在激活前确定机器是否是你的常用机器。</p><p>收到回复邮件后，按邮件指示下载并激活。（gurobi.lic 许可文件要保存在相应目录下。）</p><p>可以配合anaconda在jupyter lab上使用，conda install gurobi需要加source，建议直接上网找。</p><h1 id="Gurobi-基本使用"><a href="#Gurobi-基本使用" class="headerlink" title="Gurobi 基本使用"></a>Gurobi 基本使用</h1><p>基本的使用范例为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 创建模型对象</span></span><br><span class="line">m=Model(name = <span class="string">&#x27;modelname&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加自变量，创建了一个长度为10的整型向量</span></span><br><span class="line">x = m.addVars(<span class="number">10</span>, lb=<span class="number">0</span>, vtype=GRB.INTEGER, name=<span class="string">&#x27;price&#x27;</span>) <span class="comment"># </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写着写着发现官方是有资源的。。建议参考<a href="http://www.vvindsky.xyz/resources/Gurobi_tutorial.pdf">文档</a>与<a href="http://www.gurobi.cn/picexhview.asp?id=90">视频</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关今年夏天</title>
      <link href="2021/04/28/blog/"/>
      <url>2021/04/28/blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>意识到自己快要毕业这个事，是在球场上。    </p><a id="more"></a><p>盯着对面运球的人、嘴里喷着垃圾话的时候突然想到，1个月后大概就再也不会在这个场上跟对面这b打球了。</p><p>大学四年做了些什么？思来想去大概也就是写在CV上的那一页，多少觉得有些失败。TA楼顶的天台，坐着就能让目光越过丛树，望见行政楼背后的土坡卖力模仿着山脉起伏，弯下去的弧线衬起紫色的凤凰。本想着是个适合恋爱的好去处，但似乎四年也没能去上几次。</p><p>高考前对大学的期望是诗、酒与自由，料不到的是为了GPA的苟且。这个学校可以称得上是师范学院，在这里不断地上课、上课、上课，完全没有研究的时间，也没有思考的时间，更没有参加校外活动的时间。只是不断地上课、上课、上课，一直上到你的心灵枯竭，创造力也消失了。你成为了一部机器，不断地对那些如潮水般涌来的天真学生重复同样枯燥乏味的教材。</p><p>他们不了解为什么你变得这样乏味，因而对你失去了尊敬。大家也受了你的传染。不断上课、上课，上课的原因是，这是经营一所学校最经济的方法，让外界的人误以为学生得到了完整的教育。我们日复一日地过着无聊的生活，单调乏味的日子让人几年后想起来不禁怀疑，究竟自己是怎么过的，而时间已悄悄溜走了。</p><p>寻思着，除了课堂，9w5大概是花在了认识身边这群人上。半潇石、牛夹、莱昂诺·暴风、no_nick_name_pls、舒服喷子、活肌肉、批话王里的一群b…无论是学术、打球、lol或去rush b，总有一伙人一起。</p><p>毕业与分别的氛围总不可遏制地从身边传来。10:40起床遇到赶去上10:30课的蝗鸣儿：“没几节课可上了，去教室坐坐。”路过a316听到大四金融陶一舟在和家里商量什么时候先寄一批东西回家。和层小姐吃海底捞也被揶揄以后大学生优惠只能蹭她的。</p><p>有次跟软淑懵在if三楼闲聊，从代餐的佳格麦片聊到要是以后功成名就了，她就请我去“深圳最牛逼的楼顶天台”。如果我们泯然众人，就相约十年后回校我请她吃潘。转身回宿舍的时候想，以后八成不会再有她敷着面膜、我踹着拖鞋油头在三楼平台东一句、西一句扯淡的机会。</p><p>今早被闹铃吵地迷糊时，走廊里随着淋浴声传来龙大黑人的歌：</p><p><center>我怕我 没有机会</center></p><p><center> 跟你说一声再见</center></p><p><center>因为也许就再也见不到你</center></p><p><center>明天我要离开</center></p><p><center>熟悉的地方和你</center></p><p><center>要分离</center></p><p><center>我眼泪就掉下去</center></p><p align="center"><font face="STKaiti ">  </font></p><p>大学四年都不是个爱去教室上课的主，但最近喜欢赶早去会饮点杯咖啡，猫在诚道教室的最后一排刷手机发呆。偶尔在前排遇到个很久没见的熟人，摆摆手打个招呼之后总感觉有些怅然若失。他们就这样在某一天突然消失。没有解释，甚至连个像样的告别也没有，就像用一把锋锐无声的大砍刀，将温暖的血液奔流不息、脉搏还在静静跳动的纽带，一刀斩断。</p><p>村上春树在《海边的卡夫卡》里说：</p><p></p><p align="left"><font face="STKaiti "> &nbsp&nbsp&nbsp&nbsp 我们大家都在持续失去宝贵的东西。宝贵的机会和可能性，无法挽回的感情。这是生存的一个意义。  </font></p><br>我想，在夏天遇见的，就在夏天告别吧。<p></p><p>一直没能想好要起一个什么标题。if的毕业晚宴合唱了一首今年夏天，我决定拿来做标题。</p><p><img src="/2021/04/28/blog/test.png" alt="结尾"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>猫咪分类实现</title>
      <link href="2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/"/>
      <url>2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/封面.jpeg" style="zoom:25%;"></p><center>利用神经网络、残差神经网络进行猫咪分类训练。</center><a id="more"></a><h3 id="实现的主要部分有"><a href="#实现的主要部分有" class="headerlink" title="实现的主要部分有"></a>实现的主要部分有</h3><ul><li>简单的网络结构在猫的种类识别上的应用，测试准确率0.832</li><li>使用resNet50在猫的种类识别上的应用，测试准确率0.866</li><li>使用数据增强解决过拟合问题，并提高测试准确率，测试准确率0.999</li></ul><h3 id="项目文件夹说明"><a href="#项目文件夹说明" class="headerlink" title="项目文件夹说明"></a>项目文件夹说明</h3><pre><code>------cat_kind  项目文件名    |----cat_data_resNet50  存放用于resNet网络训练的数据        |----train      训练数据        |----test       测试数据    |----cat_kind_data  存放用于简单案例网络训练的数据（train.py）        |----train      训练数据        |----test       测试数据    |----dataAug    数据增强后存放训练集的位置    |----models     保存训练模型的位置    |----resnet_example     使用resnet网络的文件夹        |----predict_on_resnet.py   预测的时候使用的文件        |----resnet50.py    定义resnet网络的文件        |----train_on_resnet.py     训练resnet的文件    |----source_images      数据集的原始文件夹        |----0类猫        |----1类猫        |----2类猫        |----3类猫        ...        |----n类猫    |----tools      工具文件夹        |----data_aug.py    数据增强        |----prepare_data.py    数据预处理    |----predict.py     使用简单网络进行预测的文件    |----requirement.txt    环境依赖    |----train.py       使用简单网络进行训练的文件</code></pre><h4 id="step1-数据集预处理"><a href="#step1-数据集预处理" class="headerlink" title="step1 数据集预处理"></a>step1 数据集预处理</h4><p>使用文件：prepare_data.py</p><p>包括的操作有：</p><h5 id="图片重命名"><a href="#图片重命名" class="headerlink" title="图片重命名"></a>图片重命名</h5><ul><li>在renameJPG()方法实现，重命名的意图有两个，第一是将图片都统一为一种图片类型，第二个目的是给图片添加训练标签（当然也可以将标签写在文件当中，这里只是一种简便的做法）</li></ul><h5 id="图片转换为统一的格式"><a href="#图片转换为统一的格式" class="headerlink" title="图片转换为统一的格式"></a>图片转换为统一的格式</h5><ul><li>图片重命名保存的过程中将图片统一格式</li></ul><h5 id="图片统一大小"><a href="#图片统一大小" class="headerlink" title="图片统一大小"></a>图片统一大小</h5><ul><li>该网络要求输入图片的大小为(100,100),所以运行时要修改out_img_size为(100,100)，数据集保存位置save_dir为cat_kind_data</li></ul><h5 id="将图片按照一定的比例划分"><a href="#将图片按照一定的比例划分" class="headerlink" title="将图片按照一定的比例划分"></a>将图片按照一定的比例划分</h5><ul><li>按照比例9:1将数据划分为训练集和测试集,默认参数为0.9</li></ul><h4 id="step2-训练"><a href="#step2-训练" class="headerlink" title="step2 训练"></a>step2 训练</h4><ul><li>使用文件：train.py，直接执行</li></ul><h4 id="step3-测试"><a href="#step3-测试" class="headerlink" title="step3 测试"></a>step3 测试</h4><ul><li>使用文件：predict.py，直接执行</li></ul><h3 id="二-使用经典网络ResNet50实现猫的种类识别"><a href="#二-使用经典网络ResNet50实现猫的种类识别" class="headerlink" title="二 使用经典网络ResNet50实现猫的种类识别"></a>二 使用经典网络ResNet50实现猫的种类识别</h3><ul><li>由于resnet网络较为复杂，在少量的数据集情况下结果容易出现过拟合，所以首先进行数据增强的处理</li></ul><h4 id="step1-数据增强"><a href="#step1-数据增强" class="headerlink" title="step1 数据增强"></a>step1 数据增强</h4><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/sample.png" alt></p><p>直接运行data_aug.py，然后会在dataAug文件夹下生成12个对应猫种类的文件夹，相应的参数可以在data_aug.py调整</p><p><img src="/2021/04/23/%E7%8C%AB%E5%92%AA12%E5%88%86%E7%B1%BB/data_aug.png" alt></p><h4 id="step2-数据集预处理"><a href="#step2-数据集预处理" class="headerlink" title="step2 数据集预处理"></a>step2 数据集预处理</h4><p>使用文件：prepare_data.py</p><p>包括的操作有：</p><h5 id="图片重命名-1"><a href="#图片重命名-1" class="headerlink" title="图片重命名"></a>图片重命名</h5><ul><li>在renameJPG()方法实现，重命名的意图有两个，第一是将图片都统一为一种图片类型，<br>第二个目的是给图片添加训练标签（当然也可以将标签写在文件当中，这里只是一种简便的<br>做法）</li></ul><h5 id="图片转换为统一的格式-1"><a href="#图片转换为统一的格式-1" class="headerlink" title="图片转换为统一的格式"></a>图片转换为统一的格式</h5><ul><li>图片重命名保存的过程中将图片统一格式</li></ul><h5 id="图片统一大小-1"><a href="#图片统一大小-1" class="headerlink" title="图片统一大小"></a>图片统一大小</h5><ul><li>在resNet中要求图片的大小在197——224之间，这里将图片的大小统一在224*224</li></ul><h5 id="将图片按照一定的比例划分-1"><a href="#将图片按照一定的比例划分-1" class="headerlink" title="将图片按照一定的比例划分"></a>将图片按照一定的比例划分</h5><ul><li>按照比例9:1将数据划分为训练集和测试集</li></ul><h4 id="step3-定义网络结构"><a href="#step3-定义网络结构" class="headerlink" title="step3 定义网络结构"></a>step3 定义网络结构</h4><ul><li><p>网络结构采用Keras搭建好的resNet50，使用文件：resnet_example/resnet50.py</p></li><li><p>使用文件：resnet_example/resnet50.py,原始文件可从<a href="https://github.com/fchollet/deep-learning-models">deep-learning-models</a><br>获取，为了使得该文件能适应训练加测试，我做了相应的修改</p></li></ul><h4 id="step4-训练"><a href="#step4-训练" class="headerlink" title="step4 训练"></a>step4 训练</h4><ul><li>使用文件：resnet_example/train_on_resnet.py</li></ul><h4 id="step5-测试"><a href="#step5-测试" class="headerlink" title="step5 测试"></a>step5 测试</h4><ul><li>使用文件：resnet_example/predict_on_resnet.py</li></ul><h3 id="三-模型文件及数据集下载"><a href="#三-模型文件及数据集下载" class="headerlink" title="三 模型文件及数据集下载"></a>三 模型文件及数据集下载</h3><p>数据集使用的是来自百度公开数据集的猫咪12分类数据</p><p><a href="https://aistudio.baidu.com/aistudio/datasetDetail/10954">12分类数据集</a></p><p><a href="http://www.vvindsky.xyz/cat_kind.zip">代码下载</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021春晚</title>
      <link href="2021/04/21/2021%E6%98%A5%E6%99%9A/"/>
      <url>2021/04/21/2021%E6%98%A5%E6%99%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/logo.png" style="zoom:30%;"></p><center>你的下一片a14何必是a14</center><a id="more"></a><p>没有全程跟着发布会看，但发布会结束的时候还没睡，所以算是第一时间知道了发布会的消息，当天晚上在论坛逛到三点半讨论新的ipad pro ，不得不说cook牛逼。</p><p>一个个来吧。</p><h1 id="AirTag"><a href="#AirTag" class="headerlink" title="AirTag"></a>AirTag</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/airtag.png" style="zoom:30%;"></p><p>没啥好说的，有钱可以玩玩。</p><p>目前看了一些评测，远距离就像是个查找我的iphone一样不够灵敏。10m之内才能使用最新的UWB技术精准制导。</p><p>以前想的给猫猫狗狗带一个来防走失看来也不是那么可行。</p><p>只能说一个蜂鸣器+蓝牙+UWB不值这个价格，logo值👍。</p><h1 id="iMac"><a href="#iMac" class="headerlink" title="iMac"></a>iMac</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/imac.png" style="zoom:50%;"></p><p>苹果还是放不下🌈的，更令人眼前一亮的是妙控三件套的新配色。鼠标、键盘和触控板的那个薄荷绿色看起来很舒服。不过至于imac的话其实个人感觉新配色有些张扬，这个苹果设计还是太空灰的性冷淡风更对味道。</p><p>看到论坛上很多hackintosh的老哥们很欣喜因为新版的妙控键盘支持指纹解锁，这大概是指纹解锁首次下放黑果群体。</p><p>配置上升级为m1,屏幕统一变为24寸5k，前置摄像头由万年不变的720升级成了1080，发布会上还重点宣传了音频系统的提升。</p><p>接口方面，2个雷电4+两个普通type c，新版更新了磁力充电口，并且网线可以插在电源适配器上（虽然不知道为什么突兀加了这么个设计）。看到演示会演示充电方式的时候我第一反应是：</p><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/胖虎.jpg" style="zoom:50%;"></p><p>不得不吐槽这个充电线的外观缺了点苹果的elegant味。</p><p>总的来说可以定义为一款桌面端的MacBook air吧，下次回家给家里爸妈整一台，他们不需要游戏性能，能看个剧、处理下简单的办公就够用，也看着很漂亮，完美。</p><h1 id="新配色iphone"><a href="#新配色iphone" class="headerlink" title="新配色iphone"></a>新配色iphone</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/iphone.jpg" style="zoom:50%;"></p><p>好看，买。</p><p>🌈+紫，cook的心意够明显了。</p><h1 id="革命者"><a href="#革命者" class="headerlink" title="革命者"></a>革命者</h1><p><img src="/2021/04/21/2021%E6%98%A5%E6%99%9A/ipad.png" style="zoom:20%;"></p><p>以下内容是我主观想法，如果日后发现我的观点是错的，那我就回来改，所以我大概率永远是对的😊。</p><p>先谈性能，很多人在吹M1多牛逼，ipad背刺air云云。。但就我手里的这款ipad pro 2018而言，在2018年他发售之时就开始有这样的论调了。A12X或是A12Z都远远不是ipad与笔记本竞争的关键，系统才是。</p><p>ipad pro这么香都不耽误mba出货无非就是生态。我买个mba，软件生态齐活了。但我买个ipad，不配键鼠套装就是一纯爱奇艺浏览器，顶天写个笔记看个课件，办公就别想了。</p><p>那么如果我配键鼠呢？一代键鼠的价格和使用体验太拉了，罗技等厂家的二创比他高到不知哪里，二代键鼠体验要好上不少。但依然无法摆脱一个问题，笔记本10分钟做完的ppt，我在ipad上要做半个小时。笔记本上剪个视频、修个图各种快捷键素材库云云都很完善，而ipad根本没有跟上。</p><p>那我为什么说这款ipad pro是个革命者呢？</p><p>apple下场做芯片了，Intel命数已尽。这样一个牙膏厂能霸占市场这么久真是天下苦intel久矣。m1芯片的大规模量产铺货乃至推广到ipad pro上基本宣告apple自研芯片的成熟。而且以苹果更新迭代的速度，年年都是宣传性能40、50%这样子往上飞跃，intel哪里见过这阵仗，到现在都守着14nm老本。Apple yes! </p><p>之前看到过一句话，<strong>一个行业的改革多由其他行业的佼佼者入场而引发</strong>。</p><p>说回pad本身，基本宣告安卓系pad的出局，这价格，这品质，这logo（笑。其他厂商没得打，能击败这代ipad pro的只有可能是下一代ipad pro。</p><p>手持ipad pro2018也在考虑是否更换iPad pro2021，主要看头在WWDC上，我个人感觉ipad OS应该有大动作，不然没有理由不上A14X、A14Z而上M1，此前我一直以为M1 的M是for Mac的意思。</p><p>如果ipad os能有合适的作为，整个操作系统又是一次大洗牌。开发者一份工挣ipad群体和mac群体两份钱，这势必会带动mac os软件生态改善，又接着带来更多用户加入mac os生态，一个良性组合拳打的漂亮。</p><p>当然一切都是颅内臆想出来的，ipad os怎么向mac os融合是个麻烦，这两套设备硬件上的差别太大了，如何设计交互是个大问题，但这是苹果，值得一个期待。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 科技 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只狼-影逝二度</title>
      <link href="2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/"/>
      <url>2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/03/13/%E5%8F%AA%E7%8B%BC-%E5%BD%B1%E9%80%9D%E4%BA%8C%E5%BA%A6/index.jpeg" style="zoom:33%;"></p><center> 有死之荣，无生之辱</center><p>只狼打通了回来补一个通关感受，这个游戏是我目前为止游玩时间最长的单机游戏，也是我第一个肝到全成就的游戏。跟舍友一起打的剑圣，犹记得剑圣跪地时舍友的欢呼和我把手柄一甩的仰天长啸。</p><p>宫崎英高，yyds。</p><a id="more"></a><p>这里只想谈谈对整个游戏的感受，至于打法攻略很多up都有做总结， 推荐<a href="https://www.bilibili.com/video/BV1Nb41177ja?from=search&amp;seid=3555517953000752865">老戴</a>的只狼攻略视频，手残友好。</p><h1 id="故事主线"><a href="#故事主线" class="headerlink" title="故事主线"></a>故事主线</h1><p>先讲一下主线，这次主线的叙事不同于以往的魂系列。剧情还是相对明了的，认真玩过不跳过场动画的人都能大致知道。不过由于运用“插叙”的展开方式，有些内容玩到后期才能理解，这里顺序介绍故事剧情。</p><p>一心盗国二十余年，苇名国以日暮途穷。而此时，日本正处于战国末期，烽火连天，即使是位于山林深处的苇名国也被不少人耽视。但忌惮于剑圣一心的实力，不敢妄动。直到剑圣一心患上不治之症，敌国甚至开始大张旗鼓的准备起战事。</p><p>一心盗国时，其得力手下有四：巨型忍者“枭”、蝴蝶夫人、猿之忍者、医师道玄。</p><p>其中猿之忍者由于过重的罪业，化身为修罗。被剑圣一心砍断左手才恢复神智，最后隐居某个破旧的寺庙之中，想通过雕刻佛像来偿还自己的罪业。</p><p>突然有一天，苇名国一个叫平田的小城被大量的土匪入侵，而且这次土匪入侵并不一般：他们甚至花了大价钱雇佣强力的僧兵来作战，巨型忍者“枭”的义子，御子（中文翻译为皇子，有点误导。九郎并不是皇室，和苇名一族也没有血源关系，也没有管理国家的责任）的贴身的忍者“狼”也被僧兵击败负伤。即使巨型忍者“枭”和蝴蝶夫人前去帮助也无法阻止。</p><p>原来策划这起入侵的人，正是巨型忍者“枭”。他策反了蝴蝶夫人，让她绑走年幼的御子九郎，而自己假装不敌诈死，以掩人耳目。</p><p>“枭”的计划几乎快要成功之时，突然杀出了一位断臂的忍者。这名忍者就是三年后顺着记忆穿越而来的“狼”。</p><p>（这里有两种说法，一种就是物理穿越，还有一种就是单纯的回忆，我更偏向于物理穿越。一直在找证据：下方会有两种说法的具体分析）</p><p>断臂的只狼一路杀伐，甚至斩杀了自己的老师-蝴蝶夫人。在即将救到御子时，被诈死的“枭”偷袭，死在了大火之中。</p><p>年幼的皇子从大火和废墟之中救出了“狼”，并赋予了自己的龙胤之力，“狼”获得了重生。</p><p>“枭”如此大费周张的策划这起事件的原因，也正是因为想得到这“龙胤之力”不朽的力量。</p><p>不朽之法有四种：龙胤之力、京城水、变若水和附虫。虽说是三种，其实都是一个根源-从古老的西方（中国）被驱逐而来的樱龙（就是被狼用巨雷枪射爆的那位）。</p><p>龙胤，顾名思义就是龙的子嗣，龙力量的继承人。龙胤本身不会死亡，即使被砍伤也不会流出一滴血，伤口会瞬间愈合。并且龙胤可以把这个力量分享给别人，被分享力量的人会受伤，但死亡后会重生。这个重生的力量就被称为“龙胤之力”。</p><p>龙胤之力是三种不朽之法中最纯正的，代价最小的。但依然有代价：每次死亡与重生，都会吸取与你有过交集之人的生命力，使之患上名为“龙咳”的病症，且唯一治疗的方法就是用“龙胤滴露”将生命力归还于患有“龙咳”者。</p><p>不朽之法其二：京城水。樱龙来到日本后，找到了一块风水之地盘旋与栖息，这块风水之地就是“源之宫”。</p><p>但樱龙强大的力量也给源之宫带来了翻天覆的改变：首先是水，生活在上游源头的淤加美贵族外形办成了非人非龙的模样，且寿命变得极长，甚至还可以再用某种办法无限延续自己的寿命：吞噬别人的寿命（俗称+1s）。</p><p>不朽之法其三：附虫。水质的改变产生了巨大的王鲤鱼。王鲤鱼一共有两头，也拥有不朽之力。其中一头死后（死因不详）尸体被蠕虫吞噬，这些吞噬王鲤鱼的蠕虫，变成了不朽的附虫，这些附虫在水中不断产卵繁殖。</p><p>源之宫，顾名思义，这里是苇名地区水的源头（点击佛渡，手柄按Y键即可查看古地图）。附虫卵随着水源流动到苇名各地，不幸服下卵的人，就会变为附虫者，拥有不死之身，比如狮子猿、死兵卫和仙峰寺上长有附虫的长老。</p><p>但附虫可以说是代价非常之大的不死之法：大部分其实都被附虫所控制：二阶段的狮子猿、仙峰寺的长老。即使不被控制，也会相当痛苦，求死不能：死兵卫。</p><p>最后是变若水，变若水其实是人为研究的产物，通过研究附虫，试图人造出龙胤。且研究过程中付出了极大的代价：苇名之底的水生村就是试验场，所有的村民都变成了没有意识到活尸（且并没有不死之身）。</p><p>水生村本是一个贫穷幽静的村庄，村民淳朴的不像话，他们都无条件的信任着神官大人，而神官本人也憨厚的一匹。</p><p>有一天，一个人（还不清楚是谁，有评论说是水生村之前的那个淤加美吹箫哥。可能性很高）找到了神官，让他酿造一种酒（实为变若水），并许诺，只要酿造成功，就能让他成为京城人，可以在源之宫生活。</p><p>神官很高兴的将这个消息分享给大家，让大家能一起变为京城人。神官不断的酿造和尝试，给大家分享酿出的酒（变弱水）。最终，全部村民都因为劣质的变若水兽化，失去意识变为活尸。</p><p>最后当狼找到以变为活尸的神官时，他还在不断的酿造，不断的呢喃着让大家都变成京城人。</p><p>除了水生村外，仙峰寺也在尝试制作变若水，只是不知道是有人指使还是本身被对永生的贪婪。他们抓来前来朝拜的年轻人开始研究，直到狼来到先锋寺时，都能看到遍地的尸体。</p><p>仙峰寺里有一种不带附虫的不死老者，应该就劣质变若水的产物（但比水生村强多了）。最终在付出巨大代价后，仙峰寺也确实成功了，他们制作出了非常接近龙胤的赝品：唯一的一个变若之子。并将变若之子藏于内殿之中。</p><p>这一节对于龙胤、附虫、变若水的补充信息量有点多，但还是很有必要的。</p><p>书接上文，虽然“枭”在“狼”击败蝴蝶夫人后，背后一刀捅死了“狼”泄愤，但他最终还是失败了，以诈死的他不便出手再挟持御子。</p><p>物理穿越的“狼”被御子赐予龙胤之力后，取得了回忆，回到了三年之后。</p><p>而原本时间线的狼并不知道发生了什么，而且也没有龙胤之力。</p><p>最后御子被接到了苇名城保护起来，说是保护，实际上是监禁。而正常时间线上的狼，被告知义父和御子已死。这一切应该是苇名一心的义孙，苇名弦一郎搞的鬼。原因当然也是想得到“龙胤之力”。（至于为什么没把狼杀掉，有可能是出于一心的保护，也有可能是出于弦一郎的自大）</p><p>狼失去了活着的目标和动力，被囚禁于废弃的井底，一晃就是三年。</p><p>突然有一天，一心让道玄的义女，自己的学生和最信任的人“花菖蒲”（也就是医师永真）找到狼，告诉狼御子还活着，并让狼带着御子永远的逃离苇名城。</p><p>忍者知道后立刻动身救出了御子，在即将逃出苇名城的一刻，被弦一郎亲自埋伏，但不敌狼，最后用卑鄙手段砍断了狼的左手，再次抢回御子。</p><p>这时弦一郎已经坐不住了，他带着御子去到苇名主城，用各种办法：晓之以情，动之以理，威逼利诱，用各种办法想让御子直接把龙胤之力给他。</p><p>而狼在医师永真和一位雕佛师的帮助下，杀进了苇名城，再次击败弦一郎，但弦一郎复活了，原来弦一郎自己也喝了变若水。前面我已经提到了变若水，可能弦一郎疯狂的执念和这变若水有关，也可能无关。</p><p>自知不敌的弦一郎一个漂亮的背跃式跳高（跳了半米高）逃跑了。狼成功的救下了御子，他的最高任务是保护御子的周全，并按照原先的计划，想带着御子永远离开苇名。</p><p>但御子拒绝了，他要留在苇名，因为御子讨厌自己的龙胤之血，而且在经历了这么多祸端之后，决心要彻底消除它。狼很纠结，因为如果答应御子，等于违抗了义父命令，等于背弃了忍者的信条。</p><p>但他最后还是答应了，开始寻找清除龙胤需要的材料：龙之泪。</p><p>要获得龙之泪，就要到达“仙乡”，也就上文提到的“源之宫”。</p><p>要去往“仙乡”，需要几种“香料”。</p><p>其中一种，就是龙胤之血。前面我也提到龙胤即使受伤也不会流血，且伤口会瞬间愈合。</p><p>但苇名一心告诉狼：世界上有一种叫做“不死斩”的刀。可以杀死无法死去之人，也可以伤到龙胤。藏于仙峰寺内，让狼去取得。</p><p>实际上，“不死斩”一共有两把，一把是赤红色的“拜泪”（败类……中文翻译者是认真的吗？）；另一把是黑色的“开门”。</p><p>“开门”可以以无法死去之人为贡品，开启黄泉的大门。一心是知道两把不死斩的存在的，但只告诉了狼“拜泪”的存在和位置。</p><p>狼先后到了菩萨谷、水生村和仙峰寺寻找香料，在仙峰寺见到了唯一一个成功的若水之子，取得了不死斩“拜泪”。在于若水之子的交流中得知：即使斩断不死，去除御子龙胤，还是会有新的龙胤产生。一切只不过是轮回罢了，唯一的办法，就是将龙胤送回他的故乡-中国。只有那里，龙出生的地方，才能承受龙胤的力量。</p><p>为此狼为变若之子收集了两个蛇神的内脏，变若之子吞下后，化作摇篮。并且流出的眼泪化作了宝石-冰泪。只要御子将冰泪和樱龙之泪一同服下，就能完成摇篮的仪式。</p><p>在狼前往苇名各处寻找前往仙乡的材料时，他的义父，巨型忍者“枭”带着忍者突然闯入了苇名，他到这里的目的也只有一个：御子的龙胤之力。</p><p>看到御子不合作，“枭”直接命令狼：终止保护御子的命令，现在你和御子已经没有任何关系了。狼其实早已背弃了命令，所以丝毫没有犹豫的拒绝了。</p><p>枭想像三年前那样背后偷袭狼，被狼识破并斩杀。</p><p>（再补充一下修罗结局：如果这时狼选择遵从意旨，舍弃御子。则代表狼已经放弃了自己最后一丝人性，化为修罗。这时，永真说你已经成为了修罗，并且试图唤醒你。之前和永真对话，狼会问：你的剑术是谁教的？永真会说：我是医生不是武士，怎么会剑术。狼：那如何解释你身上的剑气？永真：因为感兴趣，一心曾教过我一点剑法。狼：这样的剑气绝不可能是感兴趣。永真：我绝对不会杀人的，如果有鬼的话，我会杀鬼吧。当你斩杀阻止你的永真后，年迈的剑圣一心会到来，捧着永真的尸体，说我曾经斩过修罗一样的人，没想到还会斩第二次。随后开战，不得不说，年迈的一心并不比年轻时弱很多。相对于年轻时右手拿刀左手拿钺，裤裆里还藏着五连发手枪，年迈的一心更配得上剑圣这个称号。当你斩杀一心后，枭回来了，手里拿着黑色不死斩，说明弦一郎这只鸡已经被他干掉，他看到一心的尸体说：即使是年迈的一心，你能战胜他我也很震惊，不愧是我的儿子。仰天大笑，这个国家已经在他手中了。然后被狼一刀捅死，枭问为什么，直到他看了狼一眼，大叫一声修罗。狼拿过那把黑色不死斩高举端详，从他沉醉的背影看得出来已经魔化。这一幕正好被御子看到，即使是这样御子也不愿意相信，“你不可能是修罗！”在御子的悲鸣中，修罗路线结束）</p><p>御子对狼为了自己手刃义父的事情很自责，其实对于狼来讲，这是他挣脱信条的束缚，获得自我的标志。</p><p>在狼踏上仙乡收集龙之泪的最后阶段，剑圣苇名一心终于病死。德川家康如同秃鹫一般嗅到了一心死亡的信息。早已备好的军队瞬间涌入苇名，战争之火瞬间烧毁了半个苇名城。</p><p>医师守在死去的一心前告诉狼：御子通过之前密道先逃出了苇名，让狼紧随其后。狼到达时，又遇到了弦一郎，这次弦一郎也拿到了另一把不死斩“开门”来抢夺皇子的龙胤之力，但并没有什么卵用（反而比以前更菜了），依然被狼按在地上暴打。</p><p>鼻青脸肿的弦一郎终于意识到了自己的无能，用自己手中的“开门”割破了自己的脖子，以执念召唤出了年轻的、鼎盛时期的剑圣苇名一心。不知是变若水的影响还是“开门”的影响，决定要杀光所有的入侵者。</p><p>被狼艰难击败，最后一心似乎恢复了神智，用尽全力控制住自己的身体端坐，狼将其斩首，再次送入黄泉。</p><p>随后，狼喂御子服用了樱龙之泪于冰泪，带到了变若之子面前，装进了以化作摇篮的身体。</p><p>最后，御子、变若之子和狼将踏上遥远的旅途：将龙送回中国。</p><p>以上为“龙之归乡”任务剧情。</p><h1 id="瞎扯"><a href="#瞎扯" class="headerlink" title="瞎扯"></a>瞎扯</h1><p>刚开始玩的时候是真的玩不进去，故事叙述风格也迷，开头的苇名国建国史看不懂就算了和后面我要干嘛有什么关系？没有地图引导，去哪里我都搞不灵清，开局就有一个boss两刀砍死我。宫崎英高，屌人搞我，大概就这种感受。</p><p>新学期开学后cyw、lbj我们一起一个个boss刷下去，开始能慢慢体会到魂类游戏的魅力。</p><p>//TODO：对魂类游戏的观感、关卡设计、美术风格、战斗交互。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/index.png" alt="新建" style="zoom: 33%;"></p><p>每次提到排序印象都是，学过排序，但脑子里就剩下个快排，抽个空把所有叫得上名字的排序整理下，日后复习起来也简单些。</p><a id="more"></a><p>​    分类</p><ul><li>比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li><li>非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 </li></ul><p>​    基本概念介绍</p><h1 id="1-冒泡排序-Bubble-Sort"><a href="#1-冒泡排序-Bubble-Sort" class="headerlink" title="1 冒泡排序 Bubble Sort"></a>1 冒泡排序 Bubble Sort</h1><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    比较基本的排序算法，在每次循环开始时从一端的元素开始向另一端循环，遇到右&gt;左则换位，这样在第一遍循环之后 我们可以保证数组的最右端是最大元素。依次重复n此后可保证数组按顺序排列完毕。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/bubble.gif" alt></p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp;arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index &lt;len ;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                value = *pivot;</span><br><span class="line">                *pivot = arr[index];</span><br><span class="line">                pivot = &amp; arr[index];</span><br><span class="line">                *pivot = value;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h1 id="2-选择排序-Selection-Sort"><a href="#2-选择排序-Selection-Sort" class="headerlink" title="2  选择排序 Selection Sort"></a>2  选择排序 Selection Sort</h1><h2 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    也是一个比较基本的排序算法，每次循环时找到数组中最小的元素将其放在数组最左端。循环n次后得到排序完成的数组。</p><h2 id="动图演示-1"><a href="#动图演示-1" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/selection.gif" alt></p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index&lt;len;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                pivot = &amp;arr[index]; <span class="comment">//指向新的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//与未排序部分的第一位进行替换</span></span><br><span class="line">        value = *pivot;</span><br><span class="line">        *pivot = arr[i];</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><h1 id="3-插入排序-Insertion-Sort"><a href="#3-插入排序-Insertion-Sort" class="headerlink" title="3 插入排序 Insertion Sort"></a>3 插入排序 Insertion Sort</h1><h2 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    大体思想为，循环i次时，保证数组的前i位元素都为已经排序好的，每次到i元素</p><h2 id="动图演示-2"><a href="#动图演示-2" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/insertion.gif" alt></p><h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>* arr,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span>* pivot = &amp; arr[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = i+<span class="number">1</span>;index&lt;len;index++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[index]&lt;*pivot)&#123;</span><br><span class="line">                pivot = &amp;arr[index]; <span class="comment">//指向新的最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//与未排序部分的第一位进行替换</span></span><br><span class="line">        value = *pivot;</span><br><span class="line">        *pivot = arr[i];</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><h1 id="4-希尔排序-Shell-Sort"><a href="#4-希尔排序-Shell-Sort" class="headerlink" title="4 希尔排序 Shell Sort"></a>4 希尔排序 Shell Sort</h1><h2 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h2><p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；(不同颜色表示不同序列 )</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h2 id="动图演示-3"><a href="#动图演示-3" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/shell.gif" alt></p><h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">shellSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(vargap = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>); gap &gt; <span class="number">0</span>; gap = Math.<span class="built_in">floor</span>(gap / <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行</span></span><br><span class="line">        <span class="keyword">for</span>(vari = gap; i &lt; len; i++) &#123;</span><br><span class="line">            varj = i;</span><br><span class="line">            varcurrent = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><h1 id="5-归并排序-Merge-Sort"><a href="#5-归并排序-Merge-Sort" class="headerlink" title="5 归并排序 Merge Sort"></a>5 归并排序 Merge Sort</h1><h2 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h2 id="动图演示-4"><a href="#动图演示-4" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/merge.gif" alt></p><h2 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">mergeSort</span><span class="params">(arr)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length;</span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        returnarr;</span><br><span class="line">    &#125;</span><br><span class="line">    varmiddle = Math.<span class="built_in">floor</span>(len / <span class="number">2</span>),</span><br><span class="line">        left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">        right = arr.slice(middle);</span><br><span class="line">    returnmerge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">merge</span><span class="params">(left, right)</span> </span>&#123;</span><br><span class="line">    varresult = [];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length&gt;<span class="number">0</span> &amp;&amp; right.length&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"> </span><br><span class="line">    returnresult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><h1 id="6-快速排序-Quick-Sort"><a href="#6-快速排序-Quick-Sort" class="headerlink" title="6 快速排序 Quick Sort"></a>6 快速排序 Quick Sort</h1><h2 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h2><p>​    快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h2 id="动图演示-5"><a href="#动图演示-5" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/2021/02/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/quicksort.gif" alt></p><h2 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">quickSort</span><span class="params">(arr, left, right)</span> </span>&#123;</span><br><span class="line">    varlen = arr.length,</span><br><span class="line">        partitionIndex,</span><br><span class="line">        left =typeofleft !=&#x27;number&#x27;? 0 : left,</span><br><span class="line">        right =typeofright !=&#x27;number&#x27;? len - 1 : right;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">        partitionIndex = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, partitionIndex<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    returnarr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">partition</span><span class="params">(arr, left ,right)</span> </span>&#123;    <span class="comment">// 分区操作</span></span><br><span class="line">    varpivot = left,                     <span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">        index = pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(vari = index; i &lt;= right; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    returnindex<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">function <span class="title">swap</span><span class="params">(arr, i, j)</span> </span>&#123;</span><br><span class="line">    vartemp = arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><h1 id="7-堆排序-Heap-Sort"><a href="#7-堆排序-Heap-Sort" class="headerlink" title="7 堆排序 Heap Sort"></a>7 堆排序 Heap Sort</h1><h2 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html">参考博客</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thompson Sampling笔记</title>
      <link href="2021/01/30/Thompson%20Sampling%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/30/Thompson%20Sampling%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提利昂·兰尼斯特是龙还是狮的一些猜想</title>
      <link href="2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/"/>
      <url>2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/提利昂插画.png" alt="提利昂插画" style="zoom:33%;"></p><p>​    提利昂·兰尼斯特斯特的出身问题一直是冰火论坛里争论不休的热点话题。附庸风雅地来总结下我看到的双方观点论据。</p><a id="more"></a><p>​    在开始讲两派观点之前先声明下我的观点，我认为小恶魔是龙家，主观上纯粹因为爽，一个如此讨喜的人物配拥有一身龙血，并且可以规避弑亲必死的因果律武器。客观原因在以下的论据中体现，我按我认为的可信度强弱将证据进行了排序。</p><h1 id="观点1：小恶魔是龙家的"><a href="#观点1：小恶魔是龙家的" class="headerlink" title="观点1：小恶魔是龙家的"></a>观点1：小恶魔是龙家的</h1><h2 id="证据1-发色与异色瞳（难以辩驳的铁证）"><a href="#证据1-发色与异色瞳（难以辩驳的铁证）" class="headerlink" title="证据1 发色与异色瞳（难以辩驳的铁证）"></a>证据1 发色与异色瞳（难以辩驳的铁证）</h2><p>马丁在人的发色和身材外貌描写上是很注重细节的，无论是私生还是嫡生都可以看到很多关于父子或一个家族中相近的特点存在，如狮子家的金发、龙家的白化病（笑）、大小剥皮的瞳孔，这些细节让冰火的世界充满味道。</p><p>说回重点，这是小恶魔在卷一出场时的描写：</p><p>「    <strong><em>琼恩发觉自己几乎无法将视线从他身上抽离，他暗想，这才是王者应有的风范。接着他望向兰尼斯特雄狮的弟弟，小恶魔提利昂，此人正摇摇摆摆走在哥哥身边，他是个身高只有哥哥一半的侏儒，鼓动着畸形的双腿努力追上哥哥的脚步，他的头大得不成比例，鼓胀额头下是一张扭曲的怪脸，双眼一碧一黑，从满头长直金发下面向外窥视，他头发的颜色几乎金亮成白。</em></strong>」</p><p>重点在 <strong>一碧一黑 </strong>与 <strong>金亮成白</strong>，先说异色瞳这一点，这在冰火世界中目前提到的还有两例分别为<strong>西蕊洋星</strong>与<strong>阿莱莎·坦格利安</strong>，这两人都是龙血。</p><p>西蕊洋星是庸王伊耿四世的私生女，寒铁、血鸦都在追求的大美女，她的瞳色是一蓝一绿。（TheMico的西蕊洋星插画👇）</p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/西蕊洋星.png" alt></p><p>阿莱莎·坦格利安是外传血与火中出场的人物，是国王杰赫里斯一世与王后亚莉珊·坦格利安的第二个孩子，一名御龙者，她的龙是红龙梅利亚斯。她天生异瞳，一只是紫罗兰色，另一只是绿色。</p><p>「它和我都曾是紅色處女，現在我們都被騎了。</p><p>​                                            —— 阿萊莎在駕馭她的龍後，評價她自己和梅麗亞斯」</p><p>「我壓在他身上，反覆騎他。今晚我還要再好好享受，我喜歡騎他。</p><p>​                                            —— 阿萊莎在她的新婚之夜次日清晨宣稱    」</p><p>还有<strong>发色金的发白</strong>，我个人认为这是几乎明示提利昂有龙血了。父亲是泰温，母亲是乔安娜，两只狮子血脉的孩子发色应该是纯正的金色（参考瑟曦与詹姆）但这里描写提利昂发色金的发白就很微妙了。</p><h2 id="证据2-病态地迷恋龙"><a href="#证据2-病态地迷恋龙" class="headerlink" title="证据2 病态地迷恋龙"></a>证据2 病态地迷恋龙</h2><p>提利昂从小便对龙很痴迷，在他的命名仪式上，他的叔叔吉利安问他：想要什么东西？幼小的半人说，他想要一条未成年的龙。众人听罢纷纷讪笑，因为最后的龙已经死了一个多世纪——再也没有龙了。甚少哭泣的提利昂知道后，哭了很久。</p><p>他熟读《龙、蜥龙和长翼龙：龙族的非自然演化史》、《血龙狂舞真史》等各类有关于龙的书籍。他也因此掌握了许多有关魔龙的知识，例如什么龙骨含铁量极高啊、龙口散播死亡啊、龙的唯一弱点是眼睛blabla，都是马丁老爷子借他的口告诉我们的。</p><p>很久以后，提利昂告诉雪诺，他小时候曾经非常认真地想要一条幼龙。雪诺表示难以置信，毕竟这种违反常识的愿望，跟现实睿智的半人联系不到一起。但提利昂却说：</p><p>「<strong><em>……只要能骑在龙背上，即便是发育不良，畸形扭曲的丑陋小男孩也可以睥睨全世界。”提利昂推开熊皮，站起身来。“以前我常躲在凯岩城深处的地道，燃起火堆，望着熊熊烈焰，一望就是好几个钟头，一边幻想那是魔龙吐出的烈火。有时候我会幻想我老爸被火烧死，有时候则是我老姐。</em></strong>」</p><p>剧中也有提利昂与龙亲密接触龙对他显示亲昵姿态的场面    </p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/龙提.png" alt></p><p>从这里可以看出提利昂应该是有龙血才能和龙有比较亲密的关系。</p><h2 id="证据3-龙的三首与出生害死母亲"><a href="#证据3-龙的三首与出生害死母亲" class="headerlink" title="证据3 龙的三首与出生害死母亲"></a>证据3 龙的三首与出生害死母亲</h2><p>这个证据我个人是很推崇的，因为这样的话文章会对仗工整顺畅。</p><p>首先说回龙家的族徽:黑底红色三头龙，龙有三个头，这并不是说一条龙长着三个头，而是指三这个数字与龙家割舍不了的关系。</p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/坦格利安族徽.png" alt></p><p>三百多年前，伊耿·坦格利安与他的一个姐姐和一个妹妹，三个人分别骑着三头巨龙，征服了整个维斯特洛大陆，开启了坦格利安王朝。如今，丹妮莉丝带着三条龙再次杀回，龙有了，人呢？如今，我们知道了琼恩·雪诺也是龙家人（书里还是没实锤不过要是囧都不是龙家我就弃坑了）。只剩下最后一个名额，而纵观全局，剩下的那个巨头，就是提利昂。</p><p>并且龙妈、囧、提利昂这三人还有一个巧合就是诞生时害死了母亲， 囧、龙妈和小恶魔都是出生时母亲去世，也能从某种程度上构成巧合。</p><h2 id="证据4-疯王痴迷乔安娜"><a href="#证据4-疯王痴迷乔安娜" class="headerlink" title="证据4 疯王痴迷乔安娜"></a>证据4 疯王痴迷乔安娜</h2><p>疯王对泰温的老婆乔安娜的迷恋有很多的描写。伊里斯在泰温结婚时闹洞房十分积极，有学士隐晦地记载，伊里斯<strong>“获得了过分的自由”</strong>，伊里斯甚至表示<strong>要是初夜权没废除就好了</strong>，可以说下流猥琐至极。</p><p>在泰温当国王之手初期，乔安娜也是随自己丈夫住在君临的，但没多久就被当时的雷拉王后赶回凯岩城，这俩人可是好闺蜜。这之后，乔安娜在凯岩城生下了金色双胞胎。伊里斯听说了乔安娜的生产后曾说<strong>“我娶了错误的女人。”</strong>他派人送去礼金，要求泰温在双胞胎长大后把他们带来君临，并要求乔安娜同往，因为他“太久没瞧见那张俏丽的脸了”。</p><p>272AC，伊里斯加冕十年庆典的比武大会上，乔安娜带着两个孩子拜见了伊里斯，醉酒的伊里斯问乔安娜给孩子们喂奶是不是“毁了你那对儿坚挺又骄傲的奶子”。这句话让乔安娜遭到了极大羞辱。273AC，乔安娜在凯岩城生下提利昂并难产而死。</p><p>值得一提的是如果确实是疯王侮辱了乔安娜并生下小恶魔，那么疯王侮辱乔安娜就是发生在272AC比武大会的这段时间中。</p><h1 id="观点2：小恶魔不是龙家的"><a href="#观点2：小恶魔不是龙家的" class="headerlink" title="观点2：小恶魔不是龙家的"></a>观点2：小恶魔不是龙家的</h1><h2 id="证据1-泰温太骄傲了，不可能吃别人的残羹剩饭"><a href="#证据1-泰温太骄傲了，不可能吃别人的残羹剩饭" class="headerlink" title="证据1 泰温太骄傲了，不可能吃别人的残羹剩饭"></a>证据1 泰温太骄傲了，不可能吃别人的残羹剩饭</h2><p>泰温对乔安娜的爱可以从书中很多细节中看出，据说他们结婚当日泰温露出了笑容，对于泰温来说这是极其少见的情绪外露。各方面的线索都显示他们的婚姻非常幸福，乔安娜深受泰温的信任，不止作为他的妻子，还是他的参谋和朋友。许多人都知道一句俗语描述她对丈夫的影响“泰温大人统治七国”（作为国王之手）但是“乔安娜夫人统治着泰温大人。并且乔安娜死后，泰温再也没有笑过（也受他父亲，笑狮泰陀斯的影响）。</p><p>这样一个人物，如此爱自己的妻子，更不可能容许自己的妻子被玷污的。有谣言称乔安娜的初夜在杰赫里斯加冕的当晚就给了伊里斯，并且在伊里斯称王之后还当过一段疯王的情妇。这种说法被派席尔国师否定。在他的信中，他声称“骄傲的泰温伯爵绝不可能吃别人的残羹剩饭”。</p><p><img src="/2021/01/20/%E5%B0%8F%E6%81%B6%E9%AD%94%E6%8F%90%E5%88%A9%E6%98%82%C2%B7%E5%85%B0%E5%B0%BC%E6%96%AF%E7%89%B9%E6%98%AF%E5%90%A6%E4%B8%BA%E9%BE%99%E7%A7%8D%E7%9A%84%E4%B8%80%E4%BA%9B%E7%8C%9C%E6%83%B3/乔安娜.png" alt></p><h2 id="证据2-泰温对伊里斯挑衅的反应"><a href="#证据2-泰温对伊里斯挑衅的反应" class="headerlink" title="证据2 泰温对伊里斯挑衅的反应"></a>证据2 泰温对伊里斯挑衅的反应</h2><p>疯王和泰温在年轻时（疯王未疯时）是挚友，也因此疯王力排众议将当时尚且年轻的泰温扶上国王之手的位置。但是随着时间的推移，疯王对泰温的感情逐渐转为了嫉妒。也因此支持提利昂非龙的人们认为疯王对乔安娜的轻浮言论只是为了挑衅和激怒泰温。</p><p>除次之外更要提的是，疯王三番五次出言挑逗乔安娜泰温都能忍下来，如果疯王真的与乔安娜有染泰温不可能再给他继续兢兢业业地做国王之手（龙血党认为这只是因为疯王与乔安娜有染这一事未被泰温知晓）。让泰温卸下国王之手位置的居然是疯王给詹姆披上白袍（削去了詹姆继承权，迫使泰温传凯岩城给小恶魔），这对骄傲的泰温来说是很不合理的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 冰火 </tag>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MAB学习笔记</title>
      <link href="2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2021/01/20/MAB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/sample.png" alt="新建" style="zoom:=40%;"></p><p>​    <strong>M</strong>ulti <strong>A</strong>rmed <strong>B</strong>andit(<strong>MAB</strong>) is a simple but very powerful framework for algorithms that make decisions over time under uncertainty. An enormous body of work has accumulated over the years.</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​    </p><p>​    与多臂老虎机相类似的问题还有餐馆选择问题，当我们到达一个新地方不久，是每次去我们熟悉的最好吃的餐馆还是去探索新餐馆找可能更好吃的菜品。</p><p>下面是摘自wiki的一段描述:</p><p>​    In probability theory, the multi-armed bandit problem (sometimes called the K-or N-armed bandit problem) is a problem in which a fixed limited set of resources must be allocated between competing (alternative) choices in a way that maximizes their expected gain, when each choice’s properties are only partially known at the time of allocation, and may become better understood as time passes or by allocating resources to the choice.</p><p>​    通俗点讲,当我们在玩老虎机时，老虎机有多个摇臂可供选择，每个摇臂对应的收益分布是固定但未知的，玩家需要在有限次的次数下做出最合适的选择。那么极端地想，我们每次摇臂就有两种倾向：</p><ul><li>尝试新的“老虎臂”，也许会得到比之前更好的结果(Explore)</li></ul><ul><li>利用已知的老虎臂做最好的选择(Exploit)</li></ul><p>下面介绍一些基本的算法</p><h1 id="1-Unioform-Exploration"><a href="#1-Unioform-Exploration" class="headerlink" title="1. Unioform Exploration"></a>1. Unioform Exploration</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>​    这个均匀探索算法的思想很简单，是一个 <em>Explore-first</em> 的算法。首先确定好Exploration Phase 和 Exploitation Phase的大小，然后在Exploration Phase中均匀地探索每个摇臂，用期望来描述这个摇臂对应的收益，之后在Exploitation Phase中根据之前的最大收益选择进行游戏。</p><p>​    大体流程如下:</p><ol><li>Exploration Phase: try  each arm N times</li><li>Select the arm $\hat{\alpha}$ with the highest reward </li><li>Explotiation Phase: play arm $\hat{\alpha}$  in all remaining rounds</li></ol><h2 id="Regret-analysis"><a href="#Regret-analysis" class="headerlink" title="Regret analysis"></a>Regret analysis</h2><p>​    在进行exploit的时候我们会用之前explore得到的收益的平均值$\bar{\mu}(\alpha)$ 作为对真实期望$\mu(\alpha)$的估计，如果想要最后分析得到的结果准确我们应使这两个结果之间的差值尽量小，我们这里使用Hoeffding inequality对其进行分析。</p><p>​    By defining the confidence radius $r(\alpha) = \sqrt{\frac{2logT}{N}}$ , using  Hoeffding inequality, we get :</p><script type="math/tex; mode=display">\operatorname{Pr}\{|\bar{\mu}(a)-\mu(a)| \leq r(a)\} \geq 1-\frac{2}{T^{4}}</script><p>​    我们定义$\bar{\mu}(\alpha)$ 在这个范围内为 <strong>clean event</strong>, 反之为 <strong>bad event</strong>.可以看到bad event的order 为 $T^{-4}$可以忽略不计，在后面的推导证明中，可以姑且不考虑bad event的影响。</p><p>​    后面的证明推导将采用英文QAQ。</p><p>​    For simplicity, let us start with the case of K = 2 arms. Consider the clean event. We will show that if we chose the worse arm, it is not so bad because the expected rewards for the two arms would be close.</p><p>​    Let the best arm be $\alpha^{✳️}$ and suppose the algorithm chooses the other arm $a \neq a^{✳️} .$ This must have been because its average reward was better than that of $a^{✳️} ;$ in other words, $\bar{\mu}(a)&gt;\bar{\mu}\left(a^{✳️}\right) .$ Since this is a clean event, we have:</p><script type="math/tex; mode=display">\mu(a)+r(a) \geq \bar{\mu}(a)>\bar{\mu}\left(a^{*}\right) \geq \mu\left(a^{*}\right)-r\left(a^{*}\right)</script><p>​    Re-arranging the terms, it follows that</p><script type="math/tex; mode=display">\mu\left(a^{*}\right)-\mu(a) \leq r(a)+r\left(a^{*}\right)=O\left(\sqrt{\frac{\log T}{N}}\right)</script><p>​    Thus, each round in the exploitation phase contributes at most $O\left(\sqrt{\frac{\log T}{N}}\right)$ to regret. And each round in exploration trivially contributes at most $1 .$ We derive an upper bound on the regret, which consists of two parts: for the first N rounds of exploration, and then for the remaining T - 2N rounds of exploitation:</p><p>​    Recall that we can select any value for $N,$ as long as it is known to the algorithm before the first round. So, we can choose $N$ so as to (approximately) minimize the right-hand side. Noting that the two summands are, resp., monotonically increasing and monotonically decreasing in $N,$ <strong>we set $N$ so that they are (approximately) equal</strong>. For $N=T^{2 / 3}(\log T)^{1 / 3},$ we obtain:</p><script type="math/tex; mode=display">R(T) \leq O\left(T^{2 / 3}(\log T)^{1 / 3}\right)</script><p>​    To complete the proof, we have to analyze the case of the “bad event”. Since regret can be at most T (because each round contributes at most 1), and the bad event happens with a very small probability (1/T 4), the (expected) regret from this case can be neglected. Formally,</p><script type="math/tex; mode=display">\begin{aligned}\mathbb{E}[R(T)] &=\mathbb{E}[R(T) \mid \text { clean event }] \times \operatorname{Pr}[\text { clean event }]+\mathbb{E}[R(T) \mid \text { bad event }] \times \operatorname{Pr}[\text { bad event }] \\& \leq \mathbb{E}[R(T) \mid \text { clean event }]+T \times O\left(T^{-4}\right) \\& \leq O\left(\sqrt{\log T} \times T^{2 / 3}\right)\end{aligned}</script><p>​    This complete the proff of K=2 arms.</p><p>​    For $K&gt;2$ arms, we have to apply the union bound for (1) over the $K$ arms, and then follow the same argument as above. Note that the value of $T$ is greater than $K,$ since we need to explore each arm at least once. For the final regret computation, we will need to take into account the dependence on $K$ :<br>specifically, regret accumulated in exploration phase is now upper-bounded by $K N .$ Working through the proof, we obtain $R(T) \leq N K+O\left(\sqrt{\frac{\log T}{N}} \times T\right) .$ As before, we approximately minimize it by approximately minimizing the two summands. Specifically, we plug in $N=(T / K)^{2 / 3} \cdot O(\log T)^{1 / 3} .$ Completing the proof same way as in $(5)$ we obtain:</p><p><strong><em>Explore First Algortihm achieves regret:</em></strong>$\mathbb{E}[R(T)] \leq T^{2 / 3} \times O(K \log T)^{1 / 3}$</p><h1 id="2-Adaptive-Exploration"><a href="#2-Adaptive-Exploration" class="headerlink" title="2 Adaptive Exploration"></a>2 Adaptive Exploration</h1><p>​    Both exploration-first and epsilon-greedy have a big flaw that the exploration schedule does not depend on the history of the observed rewards. Whereas it is usually better to adapt exploration to the observed rewards. Informally, we refer to this distinction as adaptive vs non-adaptive exploration. In the remainder of this article we present two algorithms that implement adaptive exploration and achieve better regret. </p><p>​    Let’s start with the case of $K=2$ arms. One natural idea is to alternate them until we find that one armi s much better than the other, at which time we abandon the inferior one. But how to define “one arm is much better” exactly?</p><h2 id="Clean-evnt-and-confidence-bounds"><a href="#Clean-evnt-and-confidence-bounds" class="headerlink" title="Clean evnt and confidence bounds"></a>Clean evnt and confidence bounds</h2><p>​    Let us flesh out the idea mentioned above; this would also set up the stage for some other algorithms. Fix round $t .$ Let $n<em>{t}(a)$ be the number of samples from $\operatorname{arm} a$ in round $1,2, \ldots, t . \bar{\mu}</em>{t}(a)$ be the average reward of arm $a$ so far. We would like to use Hoeffding Inequality to derive</p>]]></content>
      
      
      
        <tags>
            
            <tag> 学术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下搭建hexo个人博客并部署到github</title>
      <link href="2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/"/>
      <url>2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要内容：</p><ul><li><p>github注册与创建仓库</p></li><li><p>安装git、nodejs、hexo</p></li><li><p>初始化+创建hexo博客</p></li><li><p>部署到github上+自动化 </p></li><li><p>绑定域名、更换主题、设置评论区…（//TODO）</p> <a id="more"></a>     </li></ul><h3>  1.前言</h3>​    河北疫情导致圣诞与春节间的小假期无法返校，在家上网课而且空余时间没法打发，于是想着扩充下自己的技能树。再加上很久之前就有弄一个自己的博客的想法所以开始着手上网找教程了。不想自己花钱买服务器所以决定用github几番对比之后决定使用hexo。​    网上的教程有些或多或少的bug。。。导致自己琢磨一些很弱智的问题浪费了很多时间我把自己参考多份方案后的内容总结下来做参考。<h3>2. github注册与创建仓库</h3><ul><li>在<a href="https://github.com/">github</a> 官网注册账号，可能需要🚀</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/join.png" alt="新建" style="zoom:30%;"></p><ul><li>新建一个仓库</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/create1.png" alt="新建" style="zoom:30%;"></p><p>注意仓库的名字必须是 (username/ +) <strong>usrname.github.io</strong> (由于我之前注册过这个名字的仓库，所以github这里提示我名字重复)</p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/create2.png" alt="新建" style="zoom:30%;"></p><h3>  3.安装nodejs、git、hexo</h3><ul><li><a href="https://nodejs.org/en/">node.js</a>下载后安装</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/nodejs.png" alt="新建" style="zoom:50%;"></p><p>终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node -v <span class="comment">#是否出现安装版本信息，出现说明已经安装了</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://git-scm.com/downloads">Git下载</a>后安装</li></ul><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/git.png" alt="新建" style="zoom:50%;"></p><p>终端中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --version <span class="comment">#是否出现安装版本信息，出现说明已经安装了</span></span><br></pre></td></tr></table></figure><ul><li>Hexo下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装成功后在你想要存储博客项目的位置创建你的文件夹，我这里将路径设为“PATH/blog”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在你的家目录下创建一个blog文件夹</span></span><br><span class="line">mkdir PATH/blog</span><br><span class="line"><span class="comment"># 进入目录</span></span><br><span class="line"><span class="built_in">cd</span> PATH/blog</span><br><span class="line"><span class="comment"># 初始化目录</span></span><br><span class="line">hexo init</span><br><span class="line"><span class="comment">#安装必备组件</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 开启本地服务 </span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>此时打开<a href="http://localhost:4000/">http://localhost:4000/</a> 就可以看到运行在本地的hexo页面</p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/hello_world.png" alt="新建" style="zoom:50%;"></p><h3>  4. 部署到github</h3><ul><li><p>将博客关联到之前创建的github仓库上去，打开/blog文件夹下的“_config.yml”文件，这个文件存储的是博客的配置内容。</p></li><li><p>打开这个文件后在最下找到配置相关的部分将deploy的内容替换为(注意将我repository中的用户名替换为自己的用户名)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;windskyshaoyu&#x2F;windskyshaoyu.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure><p>！ 注意这里有一个神坑，大部分教程最后branch给的是“master”因为github创建仓库时的默认分支是master。但受自由美利坚种族冲突的影响，自2020.10.1起，github取消“master”这一可能带有种族歧视的词汇，默认分支更名为main。所以在部署时应部署到main分支上，也可以在设置中设置其他分支为显示页面可自行摸索。</p></li></ul><p>终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#部署插件</span></span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment">#清除之前的记录</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># g for generate 编译</span></span><br><span class="line">hexo g </span><br><span class="line"></span><br><span class="line"><span class="comment">#d for deploy 部署到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>此时若运行正常网速正常的情况下，便可以在<a href="https://your_user_name.github.io/下看到自己的博客主页。">https://your_user_name.github.io/下看到自己的博客主页。</a></p><ul><li>每次输入账号密码过于繁琐——关联Github账号，免密提交。</li></ul>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用你注册GitHub时的邮箱号，进行秘钥生成</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;xxxxxxx@gmail.com&quot;</span></span><br><span class="line"><span class="comment"># 系统就会生成一个隐藏文件夹.ssh</span></span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment">#ls 应该能看到id_rsa.pub文件</span></span><br><span class="line">ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制其中全部内容</span></span><br><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><p>  打开设置 —&gt; 选择SSH and GPG keys  —&gt; 新建一个ssh key将密钥复制进去，title可以随便填写</p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh1.png" alt="新建" style="zoom:30%;"></p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh2.png" alt="新建" style="zoom:30%;"></p><p><img src="/2021/01/18/mac%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%88%B0github/ssh3.png" alt="新建" style="zoom:25%;"></p><h3>  5. //TODO</h3><p>关于更换主题，设置评论区等内容我也花了不小的精力探索，主要是评论区的运营商更新比较频繁。。。之前的教程与现在的版本间隔过远需要自己摸索，日后有时间将其整理出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My New Post</title>
      <link href="2021/01/17/My-New-Post/"/>
      <url>2021/01/17/My-New-Post/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
